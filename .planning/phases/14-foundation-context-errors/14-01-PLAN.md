---
phase: 14-foundation-context-errors
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/errors.ts
  - src/api/errors.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "ApiError instances serialize to { code, message, data } JSON format"
    - "BadRequestError, UnauthorizedError, ForbiddenError, NotFoundError, ValidationFailedError all extend ApiError"
    - "handleApiError() converts ApiError to correct HTTP status response"
    - "handleApiError() returns 500 for non-ApiError exceptions"
    - "Production mode hides internal error details (stack traces, SQL)"
    - "Development mode includes error.message in 500 responses"
  artifacts:
    - src/api/errors.ts
    - src/api/errors.test.ts
  key_links:
    - "ApiError.toJSON() produces PocketBase-compatible format"
    - "ApiError.toResponse() creates Response with correct status code"
    - "handleApiError() checks Bun.env for development mode detection"
---

<objective>
Create the ApiError class hierarchy and error handling utilities for BunBase custom routes.

Purpose: Establish PocketBase-compatible error format (`{ code, message, data }`) for all API responses. This unified error system ensures custom routes return consistent, type-safe error responses.

Output: `src/api/errors.ts` with ApiError base class, common error subclasses (BadRequest, Unauthorized, Forbidden, NotFound, ValidationFailed), and `handleApiError()` utility function.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-foundation-context-errors/14-RESEARCH.md

Source files to understand existing patterns:
@src/api/server.ts (lines 75-101: existing errorResponse and mapErrorToStatus patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ApiError class hierarchy</name>
  <files>src/api/errors.ts</files>
  <action>
Create `src/api/errors.ts` with:

1. **ValidationError interface** for field-level errors:
```typescript
export interface ValidationError {
  code: string;
  message: string;
}
```

2. **ApiError base class**:
- Constructor: `(code: number, message: string, data?: Record<string, ValidationError>)`
- Properties: `readonly code`, `readonly data`
- Method: `toJSON()` returns `{ code, message, data }`
- Method: `toResponse()` returns `Response.json(this.toJSON(), { status: this.code })`
- Use `Object.setPrototypeOf(this, new.target.prototype)` for proper instanceof checks

3. **Error subclasses** (each extends ApiError with preset status code):
- `BadRequestError` (400) - default message: "Bad request"
- `UnauthorizedError` (401) - default message: "Unauthorized"
- `ForbiddenError` (403) - default message: "Forbidden"
- `NotFoundError` (404) - default message: "Not found"
- `ConflictError` (409) - default message: "Conflict"
- `ValidationFailedError` (422) - default message: "Validation failed", accepts data param

4. **isDevelopment() helper** (not exported):
- Returns true if `Bun.env.NODE_ENV === 'development'` OR `Bun.env.BUNBASE_DEV === 'true'`

5. **handleApiError() function**:
- If error instanceof ApiError: return `error.toResponse()`
- Else: log with `console.error('Unhandled error:', error)`
- For non-ApiError: return 500 response with generic message in production, `error.message` in development
- Production 500 response: `{ code: 500, message: 'Internal server error', data: {} }`

Export all error classes and handleApiError function.
  </action>
  <verify>bun run src/api/errors.ts (should compile without errors)</verify>
  <done>File exists with all error classes and handleApiError function</done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for error system</name>
  <files>src/api/errors.test.ts</files>
  <action>
Create `src/api/errors.test.ts` with tests for:

1. **ApiError base class tests**:
- `toJSON()` returns correct format `{ code, message, data }`
- `toResponse()` returns Response with correct status and JSON body
- Constructor sets code, message, and data properties
- Default data is empty object `{}`

2. **Subclass tests** (for each: BadRequestError, UnauthorizedError, ForbiddenError, NotFoundError, ConflictError, ValidationFailedError):
- Has correct default message
- Has correct status code
- Can override message via constructor
- instanceof ApiError returns true

3. **ValidationFailedError specific tests**:
- Accepts data parameter with field errors
- Field errors appear in toJSON() output

4. **handleApiError() tests**:
- ApiError returns correct response (status + body)
- Non-ApiError returns 500 in production mode
- Non-ApiError includes message in development mode (set BUNBASE_DEV=true)
- Logs unexpected errors to console

Use bun:test with describe/test/expect pattern.
  </action>
  <verify>bun test src/api/errors.test.ts</verify>
  <done>All tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Export error utilities from api module</name>
  <files>src/api/errors.ts</files>
  <action>
Verify the exports are correct for consumer use:

1. All error classes exported
2. ValidationError interface exported
3. handleApiError function exported
4. Type exports work correctly

Add JSDoc comments to all exports for editor autocomplete/documentation:
- ApiError: "Base API error class producing PocketBase-compatible JSON responses"
- Each subclass: Brief description of when to use (e.g., "400 Bad Request - invalid input")
- handleApiError: "Convert any error to an API response. ApiError instances are converted directly; other errors become 500s."
  </action>
  <verify>Check that `import { BadRequestError, handleApiError } from './errors'` works in a test</verify>
  <done>All exports documented and working</done>
</task>

</tasks>

<verification>
Run the full test suite to ensure no regressions:
```bash
bun test src/api/errors.test.ts
```

Verify error format matches PocketBase:
```bash
# In a test, create BadRequestError with validation data and check toJSON()
```
</verification>

<success_criteria>
- [ ] `src/api/errors.ts` exists with all error classes
- [ ] ApiError.toJSON() produces `{ code, message, data }` format
- [ ] All 6 error subclasses (BadRequest, Unauthorized, Forbidden, NotFound, Conflict, ValidationFailed) exist
- [ ] handleApiError() handles both ApiError and unknown errors
- [ ] Production mode hides internal error details
- [ ] Tests pass for all error classes and handleApiError()
</success_criteria>

<output>
After completion, create `.planning/phases/14-foundation-context-errors/14-01-SUMMARY.md`
</output>
