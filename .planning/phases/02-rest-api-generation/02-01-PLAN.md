---
phase: 02-rest-api-generation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/api/server.ts
  - src/api/server.test.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/collections/:name/records returns list of records with items array and totalItems count"
    - "GET /api/collections/:name/records/:id returns single record or 404"
    - "POST /api/collections/:name/records creates record and returns 201"
    - "PATCH /api/collections/:name/records/:id updates record and returns updated version"
    - "DELETE /api/collections/:name/records/:id removes record and returns 204"
    - "Invalid collection name returns 404"
    - "Validation errors return 400"
  artifacts:
    - path: "src/api/server.ts"
      provides: "HTTP server with CRUD routes"
      exports: ["createServer", "startServer"]
    - path: "src/api/server.test.ts"
      provides: "Endpoint tests for all CRUD operations"
      min_lines: 80
  key_links:
    - from: "src/api/server.ts"
      to: "src/core/records.ts"
      via: "import and call"
      pattern: "import.*from.*records"
    - from: "src/api/server.ts"
      to: "Bun.serve()"
      via: "route definition"
      pattern: "Bun\\.serve.*routes"
---

<objective>
Create HTTP server with CRUD endpoints for collection records using TDD

Purpose: Expose Phase 1 record operations via REST API following PocketBase conventions
Output: Working HTTP server at port 8090 with all CRUD endpoints tested
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-rest-api-generation/02-RESEARCH.md

# Phase 1 provides record operations
@src/core/records.ts
@src/core/database.ts
@src/core/schema.ts
</context>

<feature>
  <name>REST API CRUD Endpoints</name>
  <files>src/api/server.ts, src/api/server.test.ts</files>
  <behavior>
    API endpoints wrap Phase 1 record operations:

    | Method | Path | Action | Success | Error |
    |--------|------|--------|---------|-------|
    | GET | /api/collections/:name/records | listRecords | 200 + {items, totalItems} | 404 if collection not found |
    | GET | /api/collections/:name/records/:id | getRecord | 200 + record | 404 if not found |
    | POST | /api/collections/:name/records | createRecord | 201 + record | 400 validation, 404 collection |
    | PATCH | /api/collections/:name/records/:id | updateRecord | 200 + record | 400 validation, 404 not found |
    | DELETE | /api/collections/:name/records/:id | deleteRecord | 204 No Content | 404 not found |

    Error mapping:
    - "not found" in message -> 404
    - "Validation failed" in message -> 400
    - "already exists" in message -> 409
    - Unhandled -> 500

    Response format:
    - List: { items: Record[], totalItems: number }
    - Single: Record object directly
    - Error: { error: string }
  </behavior>
  <implementation>
    1. Create src/api/server.ts with:
       - createServer(port: number) function that returns Bun.Server
       - Route handlers for each endpoint
       - Error-to-status-code mapping helper
       - Response helper functions (jsonResponse, errorResponse)

    2. Use Bun.serve() routes object (not Express, per CLAUDE.md)

    3. Each handler:
       - Extract params from req.params
       - Parse body with await req.json() for POST/PATCH
       - Call Phase 1 function (createRecord, getRecord, etc.)
       - Return Response.json() with appropriate status
       - Catch errors and map to status codes

    4. Export startServer() convenience function for main entry point
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for all CRUD endpoints</name>
  <files>src/api/server.test.ts</files>
  <action>
Create comprehensive test suite for REST API endpoints.

**Test file structure:**
```typescript
import { test, expect, describe, beforeAll, afterAll, beforeEach } from "bun:test";
import { initializeDatabase, getDatabase } from "../core/database";
import { createCollection, deleteCollection } from "../core/schema";
// Import server creation function (will fail - RED phase)
import { createServer } from "./server";
```

**Test cases to write:**

1. **Setup/teardown:**
   - beforeAll: init database, create test collection "posts" with title (text, required), content (text)
   - afterAll: delete test collection, stop server
   - beforeEach: clear all records from posts table

2. **GET /api/collections/:name/records (list):**
   - Returns 200 with empty items array when no records
   - Returns 200 with items array containing records
   - Returns totalItems count matching items.length
   - Returns 404 when collection doesn't exist

3. **GET /api/collections/:name/records/:id (get single):**
   - Returns 200 with record when found
   - Returns 404 when record not found
   - Returns 404 when collection not found

4. **POST /api/collections/:name/records (create):**
   - Returns 201 with created record including id, created_at, updated_at
   - Returns 400 when validation fails (missing required field)
   - Returns 404 when collection not found

5. **PATCH /api/collections/:name/records/:id (update):**
   - Returns 200 with updated record
   - Updates updated_at timestamp
   - Returns 400 when validation fails
   - Returns 404 when record not found
   - Returns 404 when collection not found

6. **DELETE /api/collections/:name/records/:id (delete):**
   - Returns 204 No Content on success
   - Returns 404 when record not found
   - Returns 404 when collection not found

**Use test port 8091** to avoid conflicts.

Run tests with `bun test src/api/server.test.ts` - they should FAIL (server.ts doesn't exist yet).
  </action>
  <verify>
`bun test src/api/server.test.ts 2>&1 | head -20` shows import error or test failures (RED state)
  </verify>
  <done>
Test file exists with 15+ test cases covering all CRUD operations and error scenarios. Tests fail because server.ts doesn't exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement server to make tests pass</name>
  <files>src/api/server.ts</files>
  <action>
Create HTTP server implementation to pass all tests.

**File: src/api/server.ts**

1. **Imports:**
```typescript
import { initializeDatabase } from "../core/database";
import {
  createRecord,
  getRecord,
  listRecords,
  updateRecord,
  deleteRecord
} from "../core/records";
```

2. **Helper functions:**
```typescript
function errorResponse(message: string, status: number): Response {
  return Response.json({ error: message }, { status });
}

function mapErrorToStatus(error: Error): number {
  const msg = error.message.toLowerCase();
  if (msg.includes("not found")) return 404;
  if (msg.includes("validation failed")) return 400;
  if (msg.includes("already exists")) return 409;
  return 500;
}
```

3. **createServer function:**
```typescript
export function createServer(port: number = 8090) {
  return Bun.serve({
    port,
    routes: {
      "/api/collections/:name/records": {
        GET: (req) => { /* list handler */ },
        POST: async (req) => { /* create handler */ }
      },
      "/api/collections/:name/records/:id": {
        GET: (req) => { /* get single handler */ },
        PATCH: async (req) => { /* update handler */ },
        DELETE: (req) => { /* delete handler */ }
      }
    },
    fetch(req) {
      return errorResponse("Not found", 404);
    }
  });
}
```

4. **Route handler implementation:**

Each handler follows the pattern:
- Extract params: `const { name, id } = req.params;`
- Try/catch around Phase 1 function call
- Map errors to status codes
- Return appropriate Response

**Key implementation details:**
- POST returns 201 Created
- DELETE returns new Response(null, { status: 204 })
- List returns { items, totalItems: items.length }
- GET single returns record directly or 404 if null
- All error responses use { error: string } format

5. **Export startServer convenience:**
```typescript
export function startServer(port: number = 8090) {
  initializeDatabase();
  const server = createServer(port);
  console.log(`BunBase running at http://localhost:${port}`);
  return server;
}
```

Run `bun test src/api/server.test.ts` - all tests should PASS (GREEN state).
  </action>
  <verify>
`bun test src/api/server.test.ts` shows all tests passing
  </verify>
  <done>
Server implementation complete. All 15+ endpoint tests pass. Server exports createServer and startServer functions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Manual endpoint verification with curl</name>
  <files>-</files>
  <action>
Verify endpoints work with actual HTTP requests.

1. Create a test script that:
   - Starts the server
   - Creates a test collection
   - Tests each endpoint with curl-style requests

2. Run verification:
```bash
# Start server in background (create simple test file)
cat > /tmp/test-server.ts << 'EOF'
import { startServer } from "./src/api/server";
import { createCollection, deleteCollection } from "./src/core/schema";

const server = startServer(8090);

// Create test collection
try { deleteCollection("test_posts"); } catch {}
createCollection("test_posts", [
  { name: "title", type: "text", required: true },
  { name: "body", type: "text", required: false }
]);

console.log("Server ready for testing");
console.log("Test collection: test_posts");
EOF

# In one terminal: bun run /tmp/test-server.ts
# Test with fetch (using Bun's built-in):
```

3. Test each endpoint manually:
   - POST to create a record
   - GET list to see it
   - GET single by ID
   - PATCH to update it
   - DELETE to remove it
   - Verify 404 on deleted record

This is a sanity check that the API works end-to-end.
  </action>
  <verify>
All CRUD operations work via HTTP requests. Can create, read, update, delete records through the API.
  </verify>
  <done>
Manual verification confirms API endpoints work correctly with HTTP requests.
  </done>
</task>

</tasks>

<verification>
Phase 2 success criteria from ROADMAP.md:

1. Developer can list all records in a collection via GET request
   - Test: `bun test` + manual curl/fetch to /api/collections/:name/records

2. Developer can retrieve a single record by ID via GET request
   - Test: `bun test` + manual curl/fetch to /api/collections/:name/records/:id

3. Developer can create a new record via POST request and receive the created record
   - Test: `bun test` verifies 201 status and record in response

4. Developer can update an existing record via PATCH request
   - Test: `bun test` verifies update returns modified record

5. Developer can delete a record via DELETE request
   - Test: `bun test` verifies 204 No Content response

All criteria are verified by the test suite.
</verification>

<success_criteria>
- [ ] src/api/server.ts exists with createServer and startServer exports
- [ ] src/api/server.test.ts exists with 15+ test cases
- [ ] `bun test src/api/server.test.ts` passes all tests
- [ ] GET /api/collections/:name/records returns { items, totalItems }
- [ ] POST returns 201 Created with record
- [ ] DELETE returns 204 No Content
- [ ] 404 returned for missing collections/records
- [ ] 400 returned for validation failures
</success_criteria>

<output>
After completion, create `.planning/phases/02-rest-api-generation/02-01-SUMMARY.md`
</output>
