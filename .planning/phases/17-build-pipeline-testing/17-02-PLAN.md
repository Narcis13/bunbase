---
phase: 17-build-pipeline-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/binary.test.ts
autonomous: true

must_haves:
  truths:
    - "Compiled binary includes and serves all custom route handlers"
    - "Binary health route returns { status: 'ok' }"
    - "Binary stats route uses database context correctly"
    - "Routes work identically in binary and development mode"
  artifacts:
    - path: "tests/binary.test.ts"
      provides: "Compiled binary integration tests"
      min_lines: 100
  key_links:
    - from: "tests/binary.test.ts"
      to: "./bunbase"
      via: "Bun.spawn to start binary"
      pattern: "Bun\\.spawn.*bunbase"
    - from: "tests/binary.test.ts"
      to: "/api/health"
      via: "fetch request to running binary"
      pattern: "fetch.*api/health"
---

<objective>
Test that compiled binary includes and serves custom routes correctly

Purpose: Verify that after `bun run build`, the compiled bunbase binary includes all custom route handlers and serves them correctly. This is the final verification that the entire custom routes pipeline works end-to-end.

Output: tests/binary.test.ts with binary compilation and integration tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-build-pipeline-testing/17-RESEARCH.md
@package.json (build scripts)
@routes/health.ts
@routes/stats.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create binary compilation tests</name>
  <files>tests/binary.test.ts</files>
  <action>
Create tests/binary.test.ts with tests for binary compilation:

1. First describe block: "Binary Compilation"

   a. Test "bun run build completes successfully"
      - Use Bun.spawnSync() with ['bun', 'run', 'build']
      - Set timeout to 60000ms (compilation can take time)
      - Verify result.success is true
      - If fails, log stderr for debugging

   b. Test "bunbase binary exists after build"
      - Use Bun.file('./bunbase').exists()
      - Verify it returns true

   c. Test "bunbase binary is executable"
      - Run ./bunbase --help
      - Verify it doesn't crash (exit code 0)

Note: These tests modify the filesystem (create bunbase binary), so they should be in their own describe block that runs first.
  </action>
  <verify>bun test tests/binary.test.ts --filter "Binary Compilation" passes</verify>
  <done>Compilation tests verify bun run build produces working bunbase binary</done>
</task>

<task type="auto">
  <name>Task 2: Add binary integration tests</name>
  <files>tests/binary.test.ts</files>
  <action>
Add a second describe block to tests/binary.test.ts for binary integration:

1. "Binary Integration Tests" describe block

2. Setup:
   - Port: 8099 (unique for binary tests)
   - Store spawned process reference
   - Store AbortController for cleanup

3. In beforeAll:
   - Ensure binary is built first (run build if needed)
   - Spawn binary: Bun.spawn(['./bunbase', 'serve', '--port', '8099', '--db', ':memory:'])
   - Pass AbortController.signal for clean shutdown
   - Capture stdout/stderr for debugging
   - Poll /api/health with 100ms intervals, max 10 seconds timeout
   - Throw if server doesn't start in time

4. In afterAll:
   - Call abortController.abort()
   - await proc.exited to ensure cleanup
   - Use try/finally to ensure cleanup even on test failure

5. Test cases:

   a. "health route returns 200 with status ok"
      - GET http://localhost:8099/api/health
      - Verify status 200
      - Verify body.status === "ok"
      - Verify body has timestamp field

   b. "stats route returns 200 with collections"
      - GET http://localhost:8099/api/stats
      - Verify status 200
      - Verify body.collections is array
      - Verify body.count is number

   c. "stats route reflects actual database state"
      - Since using :memory: database, should start with no collections
      - count should be 0
      - collections should be empty array

   d. "custom routes have correct Content-Type"
      - GET /api/health
      - Verify Content-Type header is application/json

Use PORT 8099 to avoid conflicts (8091 server.test.ts, 8097 routes.test.ts).
  </action>
  <verify>bun test tests/binary.test.ts passes all tests</verify>
  <done>Binary integration tests verify routes work in compiled binary identically to dev mode</done>
</task>

<task type="auto">
  <name>Task 3: Add test script to package.json</name>
  <files>package.json</files>
  <action>
Update package.json to add test script:

Add to "scripts" section:
- "test": "bun test"
- "test:routes": "bun test tests/routes.test.ts"
- "test:binary": "bun test tests/binary.test.ts"

This allows:
- `bun run test` - run all tests
- `bun run test:routes` - run just route tests
- `bun run test:binary` - run just binary tests

Note: Keep existing scripts (dev, build:routes, build:admin, build, typecheck).
  </action>
  <verify>bun run test runs all tests including the new test files</verify>
  <done>Package.json has test scripts for easy test execution</done>
</task>

</tasks>

<verification>
Run full test suite:
```bash
bun run test
```

Expected: All tests pass including binary compilation and integration tests

Also verify:
```bash
./bunbase serve --port 8088 --db :memory: &
curl http://localhost:8088/api/health
# Should return {"status":"ok","timestamp":"..."}
kill %1
```
</verification>

<success_criteria>
- tests/binary.test.ts exists with at least 100 lines
- `bun run build` produces working bunbase binary
- `bun test tests/binary.test.ts` passes all tests
- Binary serves /api/health returning { status: "ok" }
- Binary serves /api/stats using database context
- package.json has test scripts
</success_criteria>

<output>
After completion, create `.planning/phases/17-build-pipeline-testing/17-02-SUMMARY.md`
</output>
