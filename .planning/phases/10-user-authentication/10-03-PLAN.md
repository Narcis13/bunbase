---
phase: 10-user-authentication
plan: 03
type: execute
wave: 2
depends_on: ["10-01", "10-02"]
files_modified:
  - src/auth/user.ts
  - src/auth/user.test.ts
  - src/api/server.ts
autonomous: true

must_haves:
  truths:
    - "User can sign up with email and password"
    - "User can log in with email and password and receives tokens"
    - "User can refresh access token using refresh token"
    - "Invalid credentials return 401, not user existence info"
  artifacts:
    - path: "src/auth/user.ts"
      provides: "User signup, login, refresh operations"
      exports: ["createUser", "loginUser", "refreshTokens", "getUserById", "getUserByEmail"]
    - path: "src/api/server.ts"
      provides: "User auth endpoints"
      contains: ["/api/collections/:name/auth/signup", "/api/collections/:name/auth/login", "/api/collections/:name/auth/refresh"]
  key_links:
    - from: "src/auth/user.ts"
      to: "src/auth/user-jwt.ts"
      via: "token creation"
      pattern: "createUserAccessToken|createUserRefreshToken"
    - from: "src/auth/user.ts"
      to: "src/auth/validation.ts"
      via: "password validation"
      pattern: "validatePassword"
    - from: "src/api/server.ts"
      to: "src/auth/user.ts"
      via: "route handlers"
      pattern: "createUser|loginUser|refreshTokens"
---

<objective>
Implement user signup, login, and token refresh functionality with API endpoints.

Purpose: Core authentication flows that allow users to create accounts, authenticate, and maintain sessions. This is the primary user-facing auth functionality.

Output:
- createUser function for signup
- loginUser function with token generation
- refreshTokens function for session extension
- API endpoints: /api/collections/:name/auth/signup, /login, /refresh
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-user-authentication/10-RESEARCH.md
@.planning/phases/10-user-authentication/10-01-SUMMARY.md
@.planning/phases/10-user-authentication/10-02-SUMMARY.md

# Existing patterns
@src/auth/admin.ts
@src/api/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user auth operations</name>
  <files>
    src/auth/user.ts
    src/auth/user.test.ts
  </files>
  <action>
Create `src/auth/user.ts`:

```typescript
import { getDatabase } from "../core/database";
import { getCollection, isAuthCollection } from "../core/schema";
import { generateId } from "../utils/id";
import { validatePassword } from "./validation";
import {
  createUserAccessToken,
  createUserRefreshToken,
  verifyUserToken,
  checkRefreshTokenValid,
  revokeRefreshToken,
  revokeAllUserRefreshTokens,
} from "./user-jwt";
import type { User, UserWithHash, AuthCollectionOptions } from "../types/auth";

// Pre-computed dummy hash for timing attack prevention
// This is a valid argon2id hash that will always fail verification
const DUMMY_HASH = "$argon2id$v=19$m=65536,t=2,p=1$abcdefghijklmnop$abcdefghijklmnopqrstuvwxyz123456";

export interface SignupResult {
  success: boolean;
  user?: User;
  error?: string;
}

export interface LoginResult {
  success: boolean;
  accessToken?: string;
  refreshToken?: string;
  user?: User;
  error?: string;
}

export interface RefreshResult {
  success: boolean;
  accessToken?: string;
  refreshToken?: string;
  error?: string;
}

/**
 * Get auth collection options (minPasswordLength, requireEmailVerification).
 */
function getAuthOptions(collectionName: string): AuthCollectionOptions {
  const collection = getCollection(collectionName);
  if (!collection || collection.type !== 'auth') {
    throw new Error(`"${collectionName}" is not an auth collection`);
  }
  return collection.options ? JSON.parse(collection.options) : {};
}

/**
 * Get user by ID from an auth collection.
 */
export function getUserById(collectionName: string, id: string): UserWithHash | null {
  if (!isAuthCollection(collectionName)) {
    throw new Error(`"${collectionName}" is not an auth collection`);
  }
  const db = getDatabase();
  const result = db.query<UserWithHash, [string]>(
    `SELECT id, email, password_hash, verified, created_at, updated_at
     FROM "${collectionName}" WHERE id = ?`
  ).get(id);
  return result ?? null;
}

/**
 * Get user by email from an auth collection.
 */
export function getUserByEmail(collectionName: string, email: string): UserWithHash | null {
  if (!isAuthCollection(collectionName)) {
    throw new Error(`"${collectionName}" is not an auth collection`);
  }
  const db = getDatabase();
  const result = db.query<UserWithHash, [string]>(
    `SELECT id, email, password_hash, verified, created_at, updated_at
     FROM "${collectionName}" WHERE email = ?`
  ).get(email);
  return result ?? null;
}

/**
 * Create a new user account.
 */
export async function createUser(
  collectionName: string,
  email: string,
  password: string
): Promise<SignupResult> {
  // Validate collection is auth type
  const collection = getCollection(collectionName);
  if (!collection || collection.type !== 'auth') {
    return { success: false, error: `"${collectionName}" is not an auth collection` };
  }

  // Validate email format
  if (!email || !email.includes('@')) {
    return { success: false, error: 'Invalid email address' };
  }

  // Check if email already exists
  const existing = getUserByEmail(collectionName, email);
  if (existing) {
    return { success: false, error: 'Email already registered' };
  }

  // Validate password
  const options = getAuthOptions(collectionName);
  try {
    validatePassword(password, options.minPasswordLength ?? 8);
  } catch (err) {
    return { success: false, error: (err as Error).message };
  }

  // Hash password
  const password_hash = await Bun.password.hash(password, {
    algorithm: "argon2id",
    memoryCost: 65536,
    timeCost: 2,
  });

  const id = generateId();
  const now = new Date().toISOString();

  // Insert user
  const db = getDatabase();
  try {
    db.run(
      `INSERT INTO "${collectionName}" (id, email, password_hash, verified, created_at, updated_at)
       VALUES (?, ?, ?, 0, ?, ?)`,
      [id, email, password_hash, now, now]
    );
  } catch (error: unknown) {
    if (error instanceof Error && error.message.includes("UNIQUE constraint")) {
      return { success: false, error: 'Email already registered' };
    }
    throw error;
  }

  return {
    success: true,
    user: { id, email, verified: false, created_at: now, updated_at: now },
  };
}

/**
 * Authenticate user and return tokens.
 * Uses constant-time comparison to prevent timing attacks.
 */
export async function loginUser(
  collectionName: string,
  email: string,
  password: string
): Promise<LoginResult> {
  // Validate collection is auth type
  const collection = getCollection(collectionName);
  if (!collection || collection.type !== 'auth') {
    return { success: false, error: `"${collectionName}" is not an auth collection` };
  }

  // Get user (may be null)
  const user = getUserByEmail(collectionName, email);

  // TIMING ATTACK PREVENTION: Always verify against something
  // If user doesn't exist, verify against dummy hash (same time cost)
  const hashToVerify = user?.password_hash ?? DUMMY_HASH;
  const isValid = await Bun.password.verify(password, hashToVerify);

  // Generic error message (don't reveal if email exists)
  if (!user || !isValid) {
    return { success: false, error: 'Invalid credentials' };
  }

  // Check email verification requirement
  const options = getAuthOptions(collectionName);
  if (options.requireEmailVerification && !user.verified) {
    return { success: false, error: 'Email not verified' };
  }

  // Generate tokens
  const accessToken = await createUserAccessToken(user.id, collection.id, collectionName);
  const { token: refreshToken } = await createUserRefreshToken(user.id, collection.id, collectionName);

  // Return user without password_hash
  const { password_hash: _, ...safeUser } = user;

  return {
    success: true,
    accessToken,
    refreshToken,
    user: safeUser,
  };
}

/**
 * Refresh tokens using a valid refresh token.
 * Implements token rotation (old refresh token revoked, new one issued).
 */
export async function refreshTokens(refreshToken: string): Promise<RefreshResult> {
  // Verify the refresh token
  const payload = await verifyUserToken(refreshToken, 'refresh');
  if (!payload) {
    return { success: false, error: 'Invalid refresh token' };
  }

  // Check if token is revoked
  if (!checkRefreshTokenValid(payload.tokenId)) {
    return { success: false, error: 'Refresh token revoked' };
  }

  // Revoke old refresh token (rotation)
  revokeRefreshToken(payload.tokenId);

  // Issue new tokens
  const accessToken = await createUserAccessToken(
    payload.userId,
    payload.collectionId,
    payload.collectionName
  );
  const { token: newRefreshToken } = await createUserRefreshToken(
    payload.userId,
    payload.collectionId,
    payload.collectionName
  );

  return {
    success: true,
    accessToken,
    refreshToken: newRefreshToken,
  };
}

/**
 * Update user password and revoke all refresh tokens.
 */
export async function updateUserPassword(
  collectionName: string,
  userId: string,
  newPassword: string
): Promise<void> {
  if (!isAuthCollection(collectionName)) {
    throw new Error(`"${collectionName}" is not an auth collection`);
  }

  const user = getUserById(collectionName, userId);
  if (!user) {
    throw new Error('User not found');
  }

  const options = getAuthOptions(collectionName);
  validatePassword(newPassword, options.minPasswordLength ?? 8);

  const password_hash = await Bun.password.hash(newPassword, {
    algorithm: "argon2id",
    memoryCost: 65536,
    timeCost: 2,
  });

  const now = new Date().toISOString();
  const db = getDatabase();
  db.run(
    `UPDATE "${collectionName}" SET password_hash = ?, updated_at = ? WHERE id = ?`,
    [password_hash, now, userId]
  );

  // Revoke all refresh tokens (force re-login)
  revokeAllUserRefreshTokens(userId);
}
```

Create `src/auth/user.test.ts` with tests for:
- createUser creates user successfully
- createUser validates email format
- createUser rejects duplicate email
- createUser validates password requirements
- loginUser returns tokens for valid credentials
- loginUser returns generic error for wrong password (not "user not found")
- loginUser returns generic error for non-existent user
- loginUser respects requireEmailVerification setting
- refreshTokens works with valid refresh token
- refreshTokens rejects revoked tokens
- refreshTokens implements rotation (old token revoked)
- updateUserPassword changes password and revokes tokens
  </action>
  <verify>
Run `bun test src/auth/user.test.ts` - all tests pass
  </verify>
  <done>
User auth operations complete with signup, login (timing-safe), token refresh with rotation, and password update.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add user auth API endpoints</name>
  <files>
    src/api/server.ts
  </files>
  <action>
Update `src/api/server.ts` to add user authentication endpoints.

Add imports at top:
```typescript
import { createUser, loginUser, refreshTokens } from "../auth/user";
import { isAuthCollection } from "../core/schema";
```

Add these routes inside the routes object in createServer():

```typescript
// User authentication routes (for auth collections)
"/api/collections/:name/auth/signup": {
  /**
   * POST /api/collections/:name/auth/signup
   * Create a new user account in an auth collection
   */
  POST: async (req) => {
    try {
      const { name } = req.params;

      // Validate it's an auth collection
      if (!isAuthCollection(name)) {
        return errorResponse(`"${name}" is not an auth collection`, 400);
      }

      const { email, password } = await req.json();
      if (!email || !password) {
        return errorResponse("Email and password required", 400);
      }

      const result = await createUser(name, email, password);
      if (!result.success) {
        return errorResponse(result.error!, 400);
      }

      return Response.json({ user: result.user }, { status: 201 });
    } catch (error) {
      const err = error as Error;
      return errorResponse(err.message, 400);
    }
  },
},

"/api/collections/:name/auth/login": {
  /**
   * POST /api/collections/:name/auth/login
   * Authenticate user and return tokens
   */
  POST: async (req) => {
    try {
      const { name } = req.params;

      if (!isAuthCollection(name)) {
        return errorResponse(`"${name}" is not an auth collection`, 400);
      }

      const { email, password } = await req.json();
      if (!email || !password) {
        return errorResponse("Email and password required", 400);
      }

      const result = await loginUser(name, email, password);
      if (!result.success) {
        // Use 401 for auth failures
        return errorResponse(result.error!, 401);
      }

      return Response.json({
        token: result.accessToken,
        refreshToken: result.refreshToken,
        user: result.user,
      });
    } catch (error) {
      const err = error as Error;
      return errorResponse(err.message, 400);
    }
  },
},

"/api/collections/:name/auth/refresh": {
  /**
   * POST /api/collections/:name/auth/refresh
   * Refresh access token using refresh token
   */
  POST: async (req) => {
    try {
      const { name } = req.params;

      if (!isAuthCollection(name)) {
        return errorResponse(`"${name}" is not an auth collection`, 400);
      }

      const { refreshToken } = await req.json();
      if (!refreshToken) {
        return errorResponse("Refresh token required", 400);
      }

      const result = await refreshTokens(refreshToken);
      if (!result.success) {
        return errorResponse(result.error!, 401);
      }

      return Response.json({
        token: result.accessToken,
        refreshToken: result.refreshToken,
      });
    } catch (error) {
      const err = error as Error;
      return errorResponse(err.message, 400);
    }
  },
},
```

Note: These routes are public (no auth required) since they ARE the authentication mechanism.
  </action>
  <verify>
Run `bun test src/api/server.test.ts` to ensure existing tests pass.
Then test manually:
```bash
# Start server in background
JWT_SECRET=test bun run src/api/server.ts &
SERVER_PID=$!
sleep 1

# Create auth collection first (as admin)
# ... (would need admin token)

# Test signup/login (will fail until collection created, but route should respond)
curl -s http://localhost:8090/api/collections/users/auth/signup -X POST \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"test1234"}'

kill $SERVER_PID
```
  </verify>
  <done>
User auth API endpoints added: POST /api/collections/:name/auth/signup, /login, /refresh. All return appropriate status codes and JSON responses.
  </done>
</task>

</tasks>

<verification>
1. `bun test src/auth/user.test.ts` - User auth tests pass
2. `bun test` - All tests pass
3. API endpoints respond correctly:
   - Signup returns 201 with user object
   - Login returns 200 with tokens
   - Invalid login returns 401
   - Refresh works with valid token
</verification>

<success_criteria>
- AUTH-02 satisfied: User can sign up with email/password
- AUTH-03 satisfied: User can log in and receives JWT tokens
- AUTH-04 satisfied: User can refresh tokens
- Timing attack prevention in place
- Token rotation implemented for refresh
</success_criteria>

<output>
After completion, create `.planning/phases/10-user-authentication/10-03-SUMMARY.md`
</output>
