---
phase: 10-user-authentication
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/auth/user-jwt.ts
  - src/auth/user-jwt.test.ts
  - src/core/database.ts
autonomous: true

must_haves:
  truths:
    - "User access tokens can be created with 15-minute expiration"
    - "User refresh tokens can be created with 7-day expiration"
    - "Refresh tokens are stored in database for revocation support"
    - "Refresh tokens can be revoked individually or all for a user"
  artifacts:
    - path: "src/auth/user-jwt.ts"
      provides: "User JWT creation and verification"
      exports: ["createUserAccessToken", "createUserRefreshToken", "verifyUserToken", "revokeRefreshToken", "revokeAllUserRefreshTokens", "checkRefreshTokenValid"]
    - path: "src/core/database.ts"
      provides: "_refresh_tokens table creation"
      contains: "_refresh_tokens"
  key_links:
    - from: "src/auth/user-jwt.ts"
      to: "jose"
      via: "SignJWT, jwtVerify imports"
      pattern: "import.*jose"
    - from: "src/auth/user-jwt.ts"
      to: "src/core/database.ts"
      via: "getDatabase for token storage"
      pattern: "getDatabase"
---

<objective>
Create the user JWT infrastructure with access tokens, refresh tokens, and database-backed token revocation.

Purpose: Implements the two-token authentication pattern (15-min access + 7-day refresh) that enables secure session management. Refresh tokens are stored in the database to support logout and forced session invalidation.

Output:
- User access token creation (15 min expiry)
- User refresh token creation (7 day expiry) with database storage
- Token verification functions
- Token revocation functions (single token and all user tokens)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-user-authentication/10-RESEARCH.md

# Existing JWT pattern to follow
@src/auth/jwt.ts
@src/core/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add _refresh_tokens table to database initialization</name>
  <files>
    src/core/database.ts
  </files>
  <action>
Update `src/core/database.ts` to create the _refresh_tokens table during database initialization.

Add after the existing table creation statements in initDatabase():

```sql
CREATE TABLE IF NOT EXISTS _refresh_tokens (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  collection_id TEXT NOT NULL,
  token_id TEXT UNIQUE NOT NULL,
  created_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  revoked INTEGER DEFAULT 0
);

CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_id ON _refresh_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_token_id ON _refresh_tokens(token_id);
```

The table stores:
- id: Primary key (nanoid)
- user_id: Reference to the user
- collection_id: Which auth collection the user belongs to
- token_id: Unique identifier encoded in the JWT (for lookup)
- created_at: When token was created
- expires_at: When token expires (7 days from creation)
- revoked: 0 = active, 1 = revoked

Note: We don't store the actual token - we store the token_id which is embedded in the JWT. This allows us to verify tokens are not revoked without storing sensitive data.
  </action>
  <verify>
Run a quick test to ensure database initializes without error:
```bash
bun -e "import { initDatabase } from './src/core/database'; initDatabase(':memory:'); console.log('DB init OK');"
```
  </verify>
  <done>
_refresh_tokens table created during database initialization with indexes on user_id and token_id.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create user JWT functions</name>
  <files>
    src/auth/user-jwt.ts
    src/auth/user-jwt.test.ts
  </files>
  <action>
Create `src/auth/user-jwt.ts`:

```typescript
import { SignJWT, jwtVerify } from "jose";
import { nanoid } from "nanoid";
import { getDatabase } from "../core/database";
import type { UserTokenPayload, RefreshTokenPayload } from "../types/auth";

/**
 * Get JWT secret from environment variable.
 * Uses the same secret as admin tokens for simplicity.
 */
function getSecret(): Uint8Array {
  const secret = Bun.env.JWT_SECRET;
  if (!secret) {
    throw new Error("JWT_SECRET environment variable is required");
  }
  return new TextEncoder().encode(secret);
}

/**
 * Create a user access token (15 minute expiry).
 */
export async function createUserAccessToken(
  userId: string,
  collectionId: string,
  collectionName: string
): Promise<string> {
  return await new SignJWT({
    userId,
    collectionId,
    collectionName,
    type: 'access'
  } as UserTokenPayload)
    .setProtectedHeader({ alg: "HS256" })
    .setIssuedAt()
    .setExpirationTime("15m")
    .sign(getSecret());
}

/**
 * Create a user refresh token (7 day expiry).
 * Stores token_id in database for revocation support.
 */
export async function createUserRefreshToken(
  userId: string,
  collectionId: string,
  collectionName: string
): Promise<{ token: string; tokenId: string }> {
  const tokenId = nanoid();
  const now = new Date();
  const expiresAt = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000); // 7 days

  const token = await new SignJWT({
    userId,
    collectionId,
    collectionName,
    tokenId,
    type: 'refresh'
  } as RefreshTokenPayload)
    .setProtectedHeader({ alg: "HS256" })
    .setIssuedAt()
    .setExpirationTime("7d")
    .sign(getSecret());

  // Store in database
  const db = getDatabase();
  const id = nanoid();
  db.run(
    `INSERT INTO _refresh_tokens (id, user_id, collection_id, token_id, created_at, expires_at, revoked)
     VALUES (?, ?, ?, ?, ?, ?, 0)`,
    [id, userId, collectionId, tokenId, now.toISOString(), expiresAt.toISOString()]
  );

  return { token, tokenId };
}

/**
 * Verify a user token (access or refresh).
 * Returns payload or null if invalid/expired.
 */
export async function verifyUserToken<T extends 'access' | 'refresh'>(
  token: string,
  expectedType: T
): Promise<(T extends 'access' ? UserTokenPayload : RefreshTokenPayload) | null> {
  try {
    const { payload } = await jwtVerify(token, getSecret(), {
      algorithms: ["HS256"],
    });

    // Verify required fields exist
    if (!payload.userId || typeof payload.userId !== "string") return null;
    if (!payload.collectionId || typeof payload.collectionId !== "string") return null;
    if (!payload.type || payload.type !== expectedType) return null;

    // For refresh tokens, verify tokenId exists
    if (expectedType === 'refresh') {
      if (!payload.tokenId || typeof payload.tokenId !== "string") return null;
    }

    return payload as any;
  } catch {
    return null;
  }
}

/**
 * Check if a refresh token is still valid (not revoked, not expired).
 */
export function checkRefreshTokenValid(tokenId: string): boolean {
  const db = getDatabase();
  const result = db.query<{ revoked: number; expires_at: string }, [string]>(
    `SELECT revoked, expires_at FROM _refresh_tokens WHERE token_id = ?`
  ).get(tokenId);

  if (!result) return false;
  if (result.revoked === 1) return false;
  if (new Date(result.expires_at) < new Date()) return false;

  return true;
}

/**
 * Revoke a specific refresh token.
 */
export function revokeRefreshToken(tokenId: string): void {
  const db = getDatabase();
  db.run(
    `UPDATE _refresh_tokens SET revoked = 1 WHERE token_id = ?`,
    [tokenId]
  );
}

/**
 * Revoke all refresh tokens for a user (force logout from all devices).
 */
export function revokeAllUserRefreshTokens(userId: string): void {
  const db = getDatabase();
  db.run(
    `UPDATE _refresh_tokens SET revoked = 1 WHERE user_id = ?`,
    [userId]
  );
}

/**
 * Clean up expired refresh tokens (can be called periodically).
 */
export function cleanupExpiredRefreshTokens(): number {
  const db = getDatabase();
  const result = db.run(
    `DELETE FROM _refresh_tokens WHERE expires_at < ?`,
    [new Date().toISOString()]
  );
  return result.changes;
}
```

Create `src/auth/user-jwt.test.ts` with tests for:
- createUserAccessToken creates valid JWT with 15m expiry
- createUserRefreshToken creates valid JWT and stores in database
- verifyUserToken validates access tokens correctly
- verifyUserToken validates refresh tokens correctly
- verifyUserToken rejects wrong token type
- verifyUserToken rejects expired tokens
- checkRefreshTokenValid returns true for valid tokens
- checkRefreshTokenValid returns false for revoked tokens
- revokeRefreshToken marks token as revoked
- revokeAllUserRefreshTokens revokes all user tokens
  </action>
  <verify>
Run `bun test src/auth/user-jwt.test.ts` - all tests pass
  </verify>
  <done>
User JWT infrastructure complete with access tokens (15m), refresh tokens (7d with DB storage), verification, and revocation functions.
  </done>
</task>

</tasks>

<verification>
1. `bun test src/auth/user-jwt.test.ts` - All JWT tests pass
2. `bun test` - All existing tests still pass
3. Database creates _refresh_tokens table correctly
</verification>

<success_criteria>
- Access tokens created with 15-minute expiration
- Refresh tokens created with 7-day expiration and stored in DB
- Token verification works for both token types
- Token revocation (single and all-user) works correctly
- No breaking changes to existing admin JWT functionality
</success_criteria>

<output>
After completion, create `.planning/phases/10-user-authentication/10-02-SUMMARY.md`
</output>
