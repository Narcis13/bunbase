---
phase: 10-user-authentication
plan: 04
type: execute
wave: 2
depends_on: ["10-01", "10-02"]
files_modified:
  - src/auth/tokens.ts
  - src/auth/tokens.test.ts
  - src/core/database.ts
  - src/api/server.ts
autonomous: true

must_haves:
  truths:
    - "User can request email verification"
    - "Verification email is sent with secure token"
    - "User can confirm verification with valid token"
    - "Verification tokens are single-use and expire after 1 hour"
  artifacts:
    - path: "src/auth/tokens.ts"
      provides: "Secure token generation, storage, and verification"
      exports: ["createVerificationToken", "verifyToken", "TokenType"]
    - path: "src/core/database.ts"
      provides: "_verification_tokens table"
      contains: "_verification_tokens"
    - path: "src/api/server.ts"
      provides: "Verification endpoints"
      contains: ["/auth/request-verification", "/auth/confirm-verification"]
    - path: "src/auth/middleware.ts"
      provides: "extractBearerToken helper (pre-existing from admin auth)"
      exports: ["extractBearerToken"]
      note: "Already exists - created during admin auth setup"
  key_links:
    - from: "src/auth/tokens.ts"
      to: "src/email/send.ts"
      via: "sendEmail for verification"
      pattern: "sendEmail"
    - from: "src/auth/tokens.ts"
      to: "Bun.CryptoHasher"
      via: "token hashing"
      pattern: "CryptoHasher"
    - from: "src/api/server.ts"
      to: "src/auth/middleware.ts"
      via: "extractBearerToken import"
      pattern: "import.*extractBearerToken.*from.*middleware"
---

<objective>
Implement email verification flow with secure one-time tokens.

Purpose: Allows users to verify ownership of their email address. Required for applications that need verified email before granting access. Tokens are hashed before storage (security best practice).

Output:
- Secure token generation and hashing
- _verification_tokens table for token storage
- Email verification request endpoint (sends email)
- Email verification confirm endpoint (marks user verified)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-user-authentication/10-RESEARCH.md

# Email service from Phase 9
@src/email/send.ts

# Existing patterns - extractBearerToken already exists here
@src/auth/middleware.ts
@src/core/database.ts
@src/auth/user.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add _verification_tokens table</name>
  <files>
    src/core/database.ts
  </files>
  <action>
Update `src/core/database.ts` to create the _verification_tokens table during database initialization.

Add after the _refresh_tokens table creation:

```sql
CREATE TABLE IF NOT EXISTS _verification_tokens (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  collection_name TEXT NOT NULL,
  token_hash TEXT UNIQUE NOT NULL,
  type TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  used INTEGER DEFAULT 0,
  created_at TEXT NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_verification_tokens_user_id ON _verification_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_verification_tokens_hash ON _verification_tokens(token_hash);
```

The table stores:
- id: Primary key
- user_id: Reference to the user
- collection_name: Auth collection the user belongs to
- token_hash: SHA-256 hash of the token (NEVER store plain tokens)
- type: 'email_verification' or 'password_reset'
- expires_at: 1 hour from creation
- used: 0 = unused, 1 = used (single-use enforcement)
- created_at: When token was created
  </action>
  <verify>
```bash
bun -e "import { initDatabase } from './src/core/database'; initDatabase(':memory:'); console.log('DB init OK');"
```
  </verify>
  <done>
_verification_tokens table created with indexes on user_id and token_hash.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create token management functions</name>
  <files>
    src/auth/tokens.ts
    src/auth/tokens.test.ts
  </files>
  <action>
Create `src/auth/tokens.ts`:

```typescript
import { nanoid } from "nanoid";
import { getDatabase } from "../core/database";
import { sendEmail } from "../email/send";
import { getUserById, getUserByEmail } from "./user";
import { getCollection } from "../core/schema";

export type TokenType = 'email_verification' | 'password_reset';

/**
 * Hash a token using SHA-256 (tokens are never stored in plain text).
 */
async function hashToken(token: string): Promise<string> {
  const hasher = new Bun.CryptoHasher("sha256");
  hasher.update(token);
  return hasher.digest("hex");
}

/**
 * Generate a secure random token (64 characters).
 */
function generateSecureToken(): string {
  return nanoid(64);
}

/**
 * Create a verification token and store its hash in the database.
 * Returns the plain token (to send to user) and the record ID.
 */
export async function createVerificationToken(
  userId: string,
  collectionName: string,
  type: TokenType
): Promise<{ token: string; id: string }> {
  const token = generateSecureToken();
  const tokenHash = await hashToken(token);
  const id = nanoid();
  const now = new Date();
  const expiresAt = new Date(now.getTime() + 60 * 60 * 1000); // 1 hour

  const db = getDatabase();

  // Invalidate any existing unused tokens of this type for this user
  db.run(
    `UPDATE _verification_tokens SET used = 1
     WHERE user_id = ? AND collection_name = ? AND type = ? AND used = 0`,
    [userId, collectionName, type]
  );

  // Create new token
  db.run(
    `INSERT INTO _verification_tokens
     (id, user_id, collection_name, token_hash, type, expires_at, used, created_at)
     VALUES (?, ?, ?, ?, ?, ?, 0, ?)`,
    [id, userId, collectionName, tokenHash, type, expiresAt.toISOString(), now.toISOString()]
  );

  return { token, id };
}

/**
 * Verify a token and return the associated user info if valid.
 * Returns null if token is invalid, expired, or already used.
 */
export async function verifyToken(
  token: string,
  expectedType: TokenType
): Promise<{ userId: string; collectionName: string } | null> {
  const tokenHash = await hashToken(token);
  const db = getDatabase();

  const record = db.query<{
    id: string;
    user_id: string;
    collection_name: string;
    type: string;
    expires_at: string;
    used: number;
  }, [string]>(
    `SELECT id, user_id, collection_name, type, expires_at, used
     FROM _verification_tokens WHERE token_hash = ?`
  ).get(tokenHash);

  if (!record) return null;
  if (record.used === 1) return null;
  if (record.type !== expectedType) return null;
  if (new Date(record.expires_at) < new Date()) return null;

  return {
    userId: record.user_id,
    collectionName: record.collection_name,
  };
}

/**
 * Mark a token as used (single-use enforcement).
 */
export async function markTokenUsed(token: string): Promise<void> {
  const tokenHash = await hashToken(token);
  const db = getDatabase();
  db.run(
    `UPDATE _verification_tokens SET used = 1 WHERE token_hash = ?`,
    [tokenHash]
  );
}

/**
 * Request email verification for a user.
 * Sends verification email with token link.
 */
export async function requestEmailVerification(
  collectionName: string,
  userId: string,
  baseUrl: string
): Promise<{ success: boolean; error?: string }> {
  const user = getUserById(collectionName, userId);
  if (!user) {
    return { success: false, error: 'User not found' };
  }

  if (user.verified) {
    return { success: false, error: 'Email already verified' };
  }

  const { token } = await createVerificationToken(userId, collectionName, 'email_verification');
  const verificationLink = `${baseUrl}/api/collections/${collectionName}/auth/confirm-verification?token=${token}`;

  const result = await sendEmail({
    to: user.email,
    subject: 'Verify your email address',
    text: `Please verify your email by clicking the link below:\n\n{{link}}\n\nThis link expires in 1 hour.`,
    html: `<p>Please verify your email by clicking the link below:</p><p><a href="{{link}}">Verify Email</a></p><p>This link expires in 1 hour.</p>`,
    placeholders: { link: verificationLink },
  });

  if (!result.success) {
    return { success: false, error: result.error };
  }

  return { success: true };
}

/**
 * Confirm email verification with token.
 */
export async function confirmEmailVerification(
  token: string
): Promise<{ success: boolean; error?: string }> {
  const tokenInfo = await verifyToken(token, 'email_verification');
  if (!tokenInfo) {
    return { success: false, error: 'Invalid or expired token' };
  }

  // Mark user as verified
  const db = getDatabase();
  const now = new Date().toISOString();
  db.run(
    `UPDATE "${tokenInfo.collectionName}" SET verified = 1, updated_at = ? WHERE id = ?`,
    [now, tokenInfo.userId]
  );

  // Mark token as used
  await markTokenUsed(token);

  return { success: true };
}

/**
 * Clean up expired verification tokens.
 */
export function cleanupExpiredVerificationTokens(): number {
  const db = getDatabase();
  const result = db.run(
    `DELETE FROM _verification_tokens WHERE expires_at < ?`,
    [new Date().toISOString()]
  );
  return result.changes;
}
```

Create `src/auth/tokens.test.ts` with tests for:
- createVerificationToken generates 64-char token
- createVerificationToken stores hashed token (not plain)
- createVerificationToken invalidates previous tokens for same user/type
- verifyToken returns user info for valid token
- verifyToken returns null for invalid token
- verifyToken returns null for expired token
- verifyToken returns null for used token
- verifyToken returns null for wrong type
- markTokenUsed marks token as used
- requestEmailVerification sends email (mock sendEmail)
- confirmEmailVerification marks user verified and token used
  </action>
  <verify>
Run `bun test src/auth/tokens.test.ts` - all tests pass
  </verify>
  <done>
Secure token management complete with SHA-256 hashing, single-use enforcement, 1-hour expiration, and email verification flow.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add email verification API endpoints</name>
  <files>
    src/api/server.ts
  </files>
  <action>
Update `src/api/server.ts` to add email verification endpoints.

Add imports at top (extractBearerToken already exists in src/auth/middleware.ts from admin auth setup):
```typescript
import { requestEmailVerification, confirmEmailVerification } from "../auth/tokens";
import { extractBearerToken } from "../auth/middleware";  // Pre-existing export
import { verifyUserToken } from "../auth/user-jwt";
```

Note: `extractBearerToken` was created during admin auth setup (Phase 8) and is already exported from `src/auth/middleware.ts`. This plan imports it; it does not need to create it.

Add these routes inside the routes object:

```typescript
"/api/collections/:name/auth/request-verification": {
  /**
   * POST /api/collections/:name/auth/request-verification
   * Request email verification (requires user auth)
   */
  POST: async (req) => {
    try {
      const { name } = req.params;

      if (!isAuthCollection(name)) {
        return errorResponse(`"${name}" is not an auth collection`, 400);
      }

      // Get user from token using pre-existing extractBearerToken
      const token = extractBearerToken(req);
      if (!token) {
        return errorResponse("Unauthorized", 401);
      }

      const payload = await verifyUserToken(token, 'access');
      if (!payload || payload.collectionName !== name) {
        return errorResponse("Unauthorized", 401);
      }

      // Determine base URL from request
      const url = new URL(req.url);
      const baseUrl = `${url.protocol}//${url.host}`;

      const result = await requestEmailVerification(name, payload.userId, baseUrl);
      if (!result.success) {
        return errorResponse(result.error!, 400);
      }

      return Response.json({ message: "Verification email sent" });
    } catch (error) {
      const err = error as Error;
      return errorResponse(err.message, 400);
    }
  },
},

"/api/collections/:name/auth/confirm-verification": {
  /**
   * POST /api/collections/:name/auth/confirm-verification
   * Confirm email verification with token
   * Also supports GET for direct link clicking
   */
  POST: async (req) => {
    try {
      const { name } = req.params;

      if (!isAuthCollection(name)) {
        return errorResponse(`"${name}" is not an auth collection`, 400);
      }

      const { token } = await req.json();
      if (!token) {
        return errorResponse("Token required", 400);
      }

      const result = await confirmEmailVerification(token);
      if (!result.success) {
        return errorResponse(result.error!, 400);
      }

      return Response.json({ message: "Email verified successfully" });
    } catch (error) {
      const err = error as Error;
      return errorResponse(err.message, 400);
    }
  },

  GET: async (req) => {
    try {
      const { name } = req.params;

      if (!isAuthCollection(name)) {
        return errorResponse(`"${name}" is not an auth collection`, 400);
      }

      const url = new URL(req.url);
      const token = url.searchParams.get('token');
      if (!token) {
        return errorResponse("Token required", 400);
      }

      const result = await confirmEmailVerification(token);
      if (!result.success) {
        // Return HTML error for GET requests (user clicked link)
        return new Response(
          `<html><body><h1>Verification Failed</h1><p>${result.error}</p></body></html>`,
          { status: 400, headers: { "Content-Type": "text/html" } }
        );
      }

      // Return HTML success for GET requests
      return new Response(
        `<html><body><h1>Email Verified!</h1><p>Your email has been verified successfully. You can close this page.</p></body></html>`,
        { headers: { "Content-Type": "text/html" } }
      );
    } catch (error) {
      const err = error as Error;
      return new Response(
        `<html><body><h1>Error</h1><p>${err.message}</p></body></html>`,
        { status: 400, headers: { "Content-Type": "text/html" } }
      );
    }
  },
},
```
  </action>
  <verify>
Run `bun test` to ensure all tests pass.
  </verify>
  <done>
Email verification endpoints added: POST request-verification (requires auth, sends email), POST/GET confirm-verification (validates token, marks user verified).
  </done>
</task>

</tasks>

<verification>
1. `bun test src/auth/tokens.test.ts` - Token tests pass
2. `bun test` - All tests pass
3. Request-verification requires auth and sends email
4. Confirm-verification works via POST (JSON) and GET (link click)
5. Tokens are single-use and expire after 1 hour
</verification>

<success_criteria>
- AUTH-05 satisfied: User can request email verification
- AUTH-06 satisfied: User can confirm email verification with token
- Tokens hashed before storage (security)
- Single-use token enforcement
- 1-hour expiration
</success_criteria>

<output>
After completion, create `.planning/phases/10-user-authentication/10-04-SUMMARY.md`
</output>
