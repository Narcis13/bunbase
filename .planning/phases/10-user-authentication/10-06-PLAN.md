---
phase: 10-user-authentication
plan: 06
type: execute
wave: 3
depends_on: ["10-03"]
files_modified:
  - src/auth/middleware.ts
  - src/auth/middleware.test.ts
  - src/auth/rules.ts
  - src/auth/rules.test.ts
  - src/api/server.ts
  - src/core/records.ts
autonomous: true

must_haves:
  truths:
    - "Protected routes reject requests without valid user token"
    - "Collection rules control who can list/view/create/update/delete records"
    - "Rule expressions support @request.auth context"
    - "Admin users bypass all collection rules"
  artifacts:
    - path: "src/auth/middleware.ts"
      provides: "User auth middleware"
      exports: ["requireUser", "optionalUser"]
    - path: "src/auth/rules.ts"
      provides: "Collection auth rules evaluation"
      exports: ["evaluateRule", "RuleContext"]
    - path: "src/core/records.ts"
      provides: "Auth-aware record operations"
      contains: "evaluateRule"
  key_links:
    - from: "src/auth/middleware.ts"
      to: "src/auth/user-jwt.ts"
      via: "verifyUserToken"
      pattern: "verifyUserToken"
    - from: "src/auth/rules.ts"
      to: "src/types/collection.ts"
      via: "CollectionRules type"
      pattern: "CollectionRules"
    - from: "src/core/records.ts"
      to: "src/auth/rules.ts"
      via: "rule evaluation"
      pattern: "evaluateRule"
---

<objective>
Implement user auth middleware and collection-level authorization rules.

Purpose: Protects API endpoints with user authentication and enforces fine-grained access control at the collection level. Rules use PocketBase-style filter expressions with @request.auth context.

Output:
- requireUser middleware (returns 401 if not authenticated)
- optionalUser middleware (attaches user if present, continues if not)
- Rule evaluation engine for collection auth rules
- Auth-aware record operations that enforce rules
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-user-authentication/10-RESEARCH.md
@.planning/phases/10-user-authentication/10-03-SUMMARY.md

# Existing middleware pattern
@src/auth/middleware.ts
@src/core/records.ts
@src/types/collection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add user auth middleware</name>
  <files>
    src/auth/middleware.ts
    src/auth/middleware.test.ts
  </files>
  <action>
Update `src/auth/middleware.ts` to add user authentication middleware.

Add imports:
```typescript
import { verifyUserToken } from "./user-jwt";
import { getUserById } from "./user";
import type { User } from "../types/auth";
```

Add these functions:

```typescript
/**
 * User with collection context for auth rules.
 */
export interface AuthenticatedUser extends User {
  collectionId: string;
  collectionName: string;
}

/**
 * Require valid user JWT for request.
 * Returns authenticated user or 401 Response.
 */
export async function requireUser(req: Request): Promise<AuthenticatedUser | Response> {
  const token = extractBearerToken(req);
  if (!token) {
    return Response.json({ error: "Unauthorized" }, { status: 401 });
  }

  const payload = await verifyUserToken(token, 'access');
  if (!payload) {
    return Response.json({ error: "Unauthorized" }, { status: 401 });
  }

  const user = getUserById(payload.collectionName, payload.userId);
  if (!user) {
    return Response.json({ error: "Unauthorized" }, { status: 401 });
  }

  // Return user without password_hash, with collection context
  const { password_hash: _, ...safeUser } = user;
  return {
    ...safeUser,
    collectionId: payload.collectionId,
    collectionName: payload.collectionName,
  };
}

/**
 * Optional user auth - attaches user if valid token present, null otherwise.
 * Never returns error Response, always continues.
 */
export async function optionalUser(req: Request): Promise<AuthenticatedUser | null> {
  const token = extractBearerToken(req);
  if (!token) return null;

  const payload = await verifyUserToken(token, 'access');
  if (!payload) return null;

  const user = getUserById(payload.collectionName, payload.userId);
  if (!user) return null;

  const { password_hash: _, ...safeUser } = user;
  return {
    ...safeUser,
    collectionId: payload.collectionId,
    collectionName: payload.collectionName,
  };
}
```

Update `src/auth/middleware.test.ts` to add tests for:
- requireUser returns user for valid token
- requireUser returns 401 for missing token
- requireUser returns 401 for invalid token
- requireUser returns 401 for expired token
- optionalUser returns user for valid token
- optionalUser returns null for missing token (not error)
- optionalUser returns null for invalid token (not error)
  </action>
  <verify>
Run `bun test src/auth/middleware.test.ts` - all tests pass
  </verify>
  <done>
User auth middleware added: requireUser (401 on failure), optionalUser (null on failure). Both return user with collection context.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create rule evaluation engine</name>
  <files>
    src/auth/rules.ts
    src/auth/rules.test.ts
  </files>
  <action>
Create `src/auth/rules.ts`:

```typescript
import type { CollectionRules } from "../types/collection";
import type { AuthenticatedUser } from "./middleware";

/**
 * Context available to rule expressions.
 */
export interface RuleContext {
  /** Is this an admin request? */
  isAdmin: boolean;
  /** Authenticated user (null if not authenticated) */
  auth: AuthenticatedUser | null;
  /** The record being accessed (for view/update/delete) */
  record?: Record<string, unknown>;
  /** The request body (for create/update) */
  body?: Record<string, unknown>;
}

/**
 * Evaluate a collection rule against the context.
 *
 * @param rule - The rule to evaluate (null = admin only, '' = public, string = expression)
 * @param context - The evaluation context
 * @returns true if access is allowed, false otherwise
 */
export function evaluateRule(
  rule: string | null,
  context: RuleContext
): boolean {
  // Admin always has access
  if (context.isAdmin) {
    return true;
  }

  // null = locked (admin only)
  if (rule === null) {
    return false;
  }

  // Empty string = public access
  if (rule === '') {
    return true;
  }

  // Parse and evaluate expression
  return evaluateExpression(rule, context);
}

/**
 * Evaluate a rule expression.
 * Supports:
 * - @request.auth.id (user ID)
 * - @request.auth.email
 * - @request.auth.verified
 * - @request.auth.collectionId
 * - @request.auth.collectionName
 * - Field references (e.g., id, user_id, owner)
 * - Operators: =, !=, >, <, >=, <=
 * - Logical: &&, ||
 * - Quotes for string literals
 */
function evaluateExpression(expression: string, context: RuleContext): boolean {
  // Handle logical operators (split by && or ||)
  if (expression.includes('&&')) {
    const parts = expression.split('&&').map(p => p.trim());
    return parts.every(part => evaluateExpression(part, context));
  }

  if (expression.includes('||')) {
    const parts = expression.split('||').map(p => p.trim());
    return parts.some(part => evaluateExpression(part, context));
  }

  // Parse comparison (left operator right)
  const match = expression.match(/^(.+?)\s*(!=|>=|<=|=|>|<)\s*(.+)$/);
  if (!match) {
    // Invalid expression - fail closed (deny access)
    console.warn(`Invalid rule expression: ${expression}`);
    return false;
  }

  const [, leftRaw, operator, rightRaw] = match;
  const left = resolveValue(leftRaw.trim(), context);
  const right = resolveValue(rightRaw.trim(), context);

  return compare(left, right, operator);
}

/**
 * Resolve a value reference to an actual value.
 */
function resolveValue(value: string, context: RuleContext): unknown {
  // String literal (quoted)
  if ((value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))) {
    return value.slice(1, -1);
  }

  // Number literal
  if (/^\d+(\.\d+)?$/.test(value)) {
    return parseFloat(value);
  }

  // Boolean literal
  if (value === 'true') return true;
  if (value === 'false') return false;

  // @request.auth references
  if (value.startsWith('@request.auth.')) {
    const field = value.slice('@request.auth.'.length);
    if (!context.auth) {
      // Not authenticated - return empty string for comparisons
      return '';
    }

    switch (field) {
      case 'id':
        return context.auth.id;
      case 'email':
        return context.auth.email;
      case 'verified':
        return context.auth.verified;
      case 'collectionId':
        return context.auth.collectionId;
      case 'collectionName':
        return context.auth.collectionName;
      default:
        return '';
    }
  }

  // @request.body references
  if (value.startsWith('@request.body.')) {
    const field = value.slice('@request.body.'.length);
    return context.body?.[field] ?? '';
  }

  // Record field reference (e.g., id, user_id, owner)
  if (context.record && value in context.record) {
    return context.record[value];
  }

  // Unknown reference - return as-is (might be a field name for later resolution)
  return value;
}

/**
 * Compare two values using the given operator.
 */
function compare(left: unknown, right: unknown, operator: string): boolean {
  // Normalize for comparison
  const l = normalizeForComparison(left);
  const r = normalizeForComparison(right);

  switch (operator) {
    case '=':
      return l === r;
    case '!=':
      return l !== r;
    case '>':
      return (l as number) > (r as number);
    case '<':
      return (l as number) < (r as number);
    case '>=':
      return (l as number) >= (r as number);
    case '<=':
      return (l as number) <= (r as number);
    default:
      return false;
  }
}

/**
 * Normalize values for comparison (handle booleans, numbers, strings).
 */
function normalizeForComparison(value: unknown): string | number | boolean {
  if (value === null || value === undefined) return '';
  if (typeof value === 'boolean') return value;
  if (typeof value === 'number') return value;
  return String(value);
}

/**
 * Get the appropriate rule for an operation.
 */
export function getRuleForOperation(
  rules: CollectionRules | null,
  operation: 'list' | 'view' | 'create' | 'update' | 'delete'
): string | null {
  if (!rules) {
    // No rules = admin only (all null)
    return null;
  }

  switch (operation) {
    case 'list':
      return rules.listRule;
    case 'view':
      return rules.viewRule;
    case 'create':
      return rules.createRule;
    case 'update':
      return rules.updateRule;
    case 'delete':
      return rules.deleteRule;
  }
}
```

Create `src/auth/rules.test.ts` with tests for:
- evaluateRule returns true for admin regardless of rule
- evaluateRule returns false for null rule (non-admin)
- evaluateRule returns true for empty string rule (public)
- Expression @request.auth.id != "" matches authenticated user
- Expression @request.auth.id = id matches owner
- Expression @request.auth.verified = true matches verified user
- Logical && requires all conditions
- Logical || requires any condition
- Invalid expression fails closed (returns false)
- String literals work with quotes
- Number comparisons work
  </action>
  <verify>
Run `bun test src/auth/rules.test.ts` - all tests pass
  </verify>
  <done>
Rule evaluation engine complete with support for @request.auth context, field references, comparison operators, and logical operators.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate auth rules into record operations</name>
  <files>
    src/core/records.ts
    src/api/server.ts
  </files>
  <action>
Update `src/core/records.ts` to enforce collection auth rules.

Add imports:
```typescript
import { evaluateRule, getRuleForOperation, RuleContext } from "../auth/rules";
import type { AuthenticatedUser } from "../auth/middleware";
```

Define the auth context type used by record functions:
```typescript
/**
 * Auth context for record operations.
 * When undefined, operations allow access (for CLI/internal use).
 */
export interface RecordAuthContext {
  isAdmin: boolean;
  user: AuthenticatedUser | null;
}
```

Add helper function:
```typescript
/**
 * Check if operation is allowed based on collection rules.
 * @throws Error if operation is not allowed
 */
function checkRuleAccess(
  collectionName: string,
  operation: 'list' | 'view' | 'create' | 'update' | 'delete',
  context: RuleContext,
  record?: Record<string, unknown>
): void {
  const collection = getCollection(collectionName);
  if (!collection) {
    throw new Error(`Collection "${collectionName}" not found`);
  }

  const rules = collection.rules ? JSON.parse(collection.rules as unknown as string) : null;
  const rule = getRuleForOperation(rules, operation);

  const evalContext: RuleContext = {
    ...context,
    record,
  };

  if (!evaluateRule(rule, evalContext)) {
    throw new Error('Access denied');
  }
}
```

Update the existing record functions to accept optional auth context. Here are the complete updated signatures:

**listRecordsWithQuery:**
```typescript
export function listRecordsWithQuery(
  collectionName: string,
  options: QueryOptions,
  authContext?: RecordAuthContext
): PaginatedResponse<Record<string, unknown>> {
  const db = getDatabase();

  // Verify collection exists
  const collection = getCollection(collectionName);
  if (!collection) {
    throw new Error(`Collection "${collectionName}" not found`);
  }

  // Check auth rules if context provided (undefined = allow, for CLI/internal)
  if (authContext !== undefined) {
    const ruleContext: RuleContext = {
      isAdmin: authContext.isAdmin,
      auth: authContext.user,
    };
    checkRuleAccess(collectionName, 'list', ruleContext);
  }

  // ... rest of existing implementation unchanged
}
```

**getRecord:**
```typescript
export function getRecord(
  collectionName: string,
  id: string,
  authContext?: RecordAuthContext
): Record<string, unknown> | null {
  const db = getDatabase();

  // Verify collection exists
  const collection = getCollection(collectionName);
  if (!collection) {
    throw new Error(`Collection "${collectionName}" not found`);
  }

  const fields = getFields(collectionName);

  const stmt = db.prepare(`SELECT * FROM "${collectionName}" WHERE id = $id`);
  const result = stmt.get({ id }) as Record<string, unknown> | null;

  if (!result) {
    return null;
  }

  // Check auth rules if context provided (undefined = allow, for CLI/internal)
  if (authContext !== undefined) {
    const ruleContext: RuleContext = {
      isAdmin: authContext.isAdmin,
      auth: authContext.user,
      record: result,
    };
    checkRuleAccess(collectionName, 'view', ruleContext, result);
  }

  // Parse JSON fields back to objects
  return parseJsonFields(fields, result);
}
```

**createRecordWithHooks:**
```typescript
export async function createRecordWithHooks(
  collectionName: string,
  data: Record<string, unknown>,
  hooks: HookManager,
  request?: Request,
  authContext?: RecordAuthContext
): Promise<Record<string, unknown>> {
  // Check auth rules if context provided (undefined = allow, for CLI/internal)
  if (authContext !== undefined) {
    const ruleContext: RuleContext = {
      isAdmin: authContext.isAdmin,
      auth: authContext.user,
      body: data,
    };
    checkRuleAccess(collectionName, 'create', ruleContext);
  }

  // ... rest of existing implementation unchanged
}
```

**updateRecordWithHooks:**
```typescript
export async function updateRecordWithHooks(
  collectionName: string,
  id: string,
  data: Record<string, unknown>,
  hooks: HookManager,
  request?: Request,
  authContext?: RecordAuthContext
): Promise<Record<string, unknown>> {
  // Fetch existing record first
  const existing = getRecord(collectionName, id);  // No auth check here - we check below with record context
  if (!existing) {
    throw new Error(`Record "${id}" not found in collection "${collectionName}"`);
  }

  // Check auth rules if context provided (undefined = allow, for CLI/internal)
  if (authContext !== undefined) {
    const ruleContext: RuleContext = {
      isAdmin: authContext.isAdmin,
      auth: authContext.user,
      record: existing,
      body: data,
    };
    checkRuleAccess(collectionName, 'update', ruleContext, existing);
  }

  // ... rest of existing implementation unchanged
}
```

**deleteRecordWithHooks:**
```typescript
export async function deleteRecordWithHooks(
  collectionName: string,
  id: string,
  hooks: HookManager,
  request?: Request,
  authContext?: RecordAuthContext
): Promise<void> {
  // Fetch existing record first
  const existing = getRecord(collectionName, id);  // No auth check here - we check below with record context
  if (!existing) {
    throw new Error(`Record "${id}" not found in collection "${collectionName}"`);
  }

  // Check auth rules if context provided (undefined = allow, for CLI/internal)
  if (authContext !== undefined) {
    const ruleContext: RuleContext = {
      isAdmin: authContext.isAdmin,
      auth: authContext.user,
      record: existing,
    };
    checkRuleAccess(collectionName, 'delete', ruleContext, existing);
  }

  // ... rest of existing implementation unchanged
}
```

IMPORTANT: When `authContext` is `undefined`, operations allow access (backward compatible for CLI/internal use). When `authContext` is provided:
- `{ isAdmin: true, user: null }` - Admin access, bypasses all rules
- `{ isAdmin: false, user: null }` - Unauthenticated public access
- `{ isAdmin: false, user: AuthenticatedUser }` - Authenticated user access

Update `src/api/server.ts` to pass auth context to record operations:

Add import:
```typescript
import { requireAdmin, optionalUser } from "../auth/middleware";
```

For public record routes (`/api/collections/:name/records`):
```typescript
// In GET handler for list
const user = await optionalUser(req);
const authContext = {
  isAdmin: false,  // Public API is never admin
  user,
};
const result = listRecordsWithQuery(name, options, authContext);

// In GET handler for single record
const user = await optionalUser(req);
const authContext = { isAdmin: false, user };
const record = getRecord(name, id, authContext);

// In POST handler for create
const user = await optionalUser(req);
const authContext = { isAdmin: false, user };
const record = await createRecordWithHooks(name, data, hooks, req, authContext);

// In PATCH handler for update
const user = await optionalUser(req);
const authContext = { isAdmin: false, user };
const record = await updateRecordWithHooks(name, id, data, hooks, req, authContext);

// In DELETE handler
const user = await optionalUser(req);
const authContext = { isAdmin: false, user };
await deleteRecordWithHooks(name, id, hooks, req, authContext);
```

For admin routes (`/_/api/...`):
- Already requires admin, so pass `{ isAdmin: true, user: null }`
  </action>
  <verify>
Run `bun test` to ensure all existing tests still pass.
  </verify>
  <done>
Auth rules integrated into record operations. Public API enforces collection rules, admin API bypasses rules.
  </done>
</task>

</tasks>

<verification>
1. `bun test src/auth/middleware.test.ts` - Middleware tests pass
2. `bun test src/auth/rules.test.ts` - Rules tests pass
3. `bun test` - All tests pass
4. Public API respects collection rules
5. Admin API bypasses rules
</verification>

<success_criteria>
- AUTH-10 satisfied: Auth middleware verifies user JWT
- AUTH-11 satisfied: Collection rules control record access
- Rule expressions support @request.auth.id, .email, .verified, etc.
- Logical operators (&&, ||) work correctly
- Admin users bypass all collection rules
- Backward compatible (no context = allow access)
</success_criteria>

<output>
After completion, create `.planning/phases/10-user-authentication/10-06-SUMMARY.md`
</output>
