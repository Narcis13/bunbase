---
phase: 15-route-loading
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - scripts/build-routes.ts
  - src/routes-generated.ts
  - package.json
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "bun run build:routes scans routes/ directory and generates src/routes-generated.ts"
    - "Generated file contains static imports for each route file"
    - "Generated file exports customRoutes array with path, method, handler"
    - "Generated file exports buildCustomRoutes function for server integration"
    - "Build script warns on lowercase method exports"
    - "Build script handles missing routes/ directory gracefully (empty manifest)"
  artifacts:
    - path: "scripts/build-routes.ts"
      provides: "Route manifest generation script"
      min_lines: 100
    - path: "src/routes-generated.ts"
      provides: "Generated route manifest (gitignored)"
      exports: ["customRoutes", "buildCustomRoutes", "routeManifest"]
  key_links:
    - from: "scripts/build-routes.ts"
      to: "src/routes/discovery.ts"
      via: "import { filePathToRoutePath, generateImportName, parseRouteExports }"
      pattern: "import.*from.*routes/discovery"
    - from: "src/routes-generated.ts"
      to: "src/api/context.ts"
      via: "import { createRouteContext }"
      pattern: "import.*createRouteContext.*from.*api/context"
    - from: "src/routes-generated.ts"
      to: "src/api/errors.ts"
      via: "import { handleApiError }"
      pattern: "import.*handleApiError.*from.*api/errors"
---

<objective>
Create the build-routes.ts script that generates src/routes-generated.ts with static imports and route mappings for all custom routes.

Purpose: This is the build-time manifest generator that makes custom routes work in compiled binaries. It bridges Phase 15 (discovery) to Phase 16 (server integration).

Output: Working `bun run build:routes` command that generates importable route manifest.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-route-loading/15-RESEARCH.md
@.planning/phases/15-route-loading/15-01-SUMMARY.md
@src/api/context.ts
@src/api/errors.ts
@scripts/build-admin.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create build-routes.ts script</name>
  <files>scripts/build-routes.ts</files>
  <action>
Create `scripts/build-routes.ts` that:

1. Uses Bun.Glob to scan `routes/` directory for `**/*.{ts,tsx}` files
2. Skips test files (*.test.ts, *.spec.ts)
3. For each route file:
   - Call filePathToRoutePath() to get API route path
   - Call generateImportName() to get safe import variable name
   - Call parseRouteExports() to get methods and warnings
   - Print warnings to console
4. Generate src/routes-generated.ts with:
   - Header comment "THIS FILE IS GENERATED - DO NOT EDIT"
   - Static imports: `import * as route_health from '../routes/health';`
   - Import of createRouteContext and handleApiError from src/api
   - CustomRoute interface definition
   - customRoutes array: `{ path: '/api/health', method: 'GET', handler: route_health.GET }`
   - wrapHandler function that creates context and catches errors
   - buildCustomRoutes function that returns Bun.serve routes object
   - routeManifest export for debugging

5. Handle edge cases:
   - No routes/ directory: Generate empty manifest with empty arrays
   - No valid routes found: Generate empty manifest, log warning
   - Route file with no HTTP method exports: Skip file, log warning

Follow the pattern from build-admin.ts for project root resolution and console output.

Key imports needed:
```typescript
import { resolve, relative, dirname } from 'path';
import { filePathToRoutePath, generateImportName, parseRouteExports, VALID_METHODS } from '../src/routes/discovery';
```
  </action>
  <verify>
```bash
# Create a test route file first
mkdir -p routes
cat > routes/health.ts << 'EOF'
import type { RouteContext } from '../src/api/context';

export const GET = (req: Request, ctx: RouteContext) => {
  return Response.json({ status: 'ok' });
};
EOF

# Run the build script
bun scripts/build-routes.ts

# Verify output exists and has correct structure
cat src/routes-generated.ts | head -30
```
  </verify>
  <done>
- build-routes.ts scans routes/ and generates src/routes-generated.ts
- Generated file has static imports, customRoutes array, and buildCustomRoutes function
- Console output shows discovered routes: "/api/health [GET]"
  </done>
</task>

<task type="auto">
  <name>Task 2: Update package.json and .gitignore</name>
  <files>package.json, .gitignore</files>
  <action>
1. Add `build:routes` script to package.json:
```json
"build:routes": "bun scripts/build-routes.ts"
```

2. Update `build` script to include route generation:
```json
"build": "bun run build:routes && bun run build:admin && bun build --compile --minify src/cli.ts --outfile bunbase"
```

3. Update `dev` script to generate routes before watching:
```json
"dev": "bun run build:routes && bun run build:admin && bun run --watch src/cli.ts serve"
```

4. Add `src/routes-generated.ts` to .gitignore (generated file should not be committed):
```
# Generated files
src/routes-generated.ts
```

Note: The routes-generated.ts file is gitignored because it's generated at build time and should be regenerated on each build to pick up route changes.
  </action>
  <verify>
```bash
# Verify package.json has new scripts
grep "build:routes" package.json
grep -A1 '"build":' package.json

# Verify .gitignore has the entry
grep "routes-generated" .gitignore

# Test the build:routes script runs
bun run build:routes

# Verify the generated file exists
ls -la src/routes-generated.ts
```
  </verify>
  <done>
- package.json has build:routes, updated build and dev scripts
- .gitignore excludes src/routes-generated.ts
- `bun run build:routes` successfully generates the manifest
  </done>
</task>

<task type="auto">
  <name>Task 3: Test complete workflow with example routes</name>
  <files>routes/health.ts, routes/stats.ts</files>
  <action>
Create example route files to verify the complete workflow:

1. Create `routes/health.ts` - simple health check:
```typescript
import type { RouteContext } from '../src/api/context';

/**
 * GET /api/health
 * Simple health check endpoint
 */
export const GET = (req: Request, ctx: RouteContext) => {
  return Response.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
  });
};
```

2. Create `routes/stats.ts` - database access example:
```typescript
import type { RouteContext } from '../src/api/context';

/**
 * GET /api/stats
 * Return collection statistics
 */
export const GET = (req: Request, ctx: RouteContext) => {
  const stats = ctx.db.query(`
    SELECT name FROM _collections
  `).all() as { name: string }[];

  return Response.json({
    collections: stats.map(s => s.name),
    count: stats.length,
  });
};
```

3. Run the complete workflow and verify:
```bash
bun run build:routes
cat src/routes-generated.ts
```

4. Verify the generated file:
- Has imports for both route files
- customRoutes array has 2 entries
- buildCustomRoutes function exists
- routeManifest shows both routes

Note: These example routes will be used in Phase 17 for testing. They demonstrate the pattern for users to follow when creating their own custom routes.
  </action>
  <verify>
```bash
# Run build:routes
bun run build:routes

# Check generated file has both routes
grep "route_health" src/routes-generated.ts
grep "route_stats" src/routes-generated.ts
grep "'/api/health'" src/routes-generated.ts
grep "'/api/stats'" src/routes-generated.ts

# Verify routeManifest export
grep "routeManifest" src/routes-generated.ts

# TypeScript should compile without errors
bun run typecheck
```
  </verify>
  <done>
- routes/health.ts and routes/stats.ts created as examples
- bun run build:routes generates manifest with both routes
- Generated file compiles without TypeScript errors
- routeManifest shows: /api/health [GET], /api/stats [GET]
  </done>
</task>

</tasks>

<verification>
```bash
# Full workflow test
rm -f src/routes-generated.ts
bun run build:routes
cat src/routes-generated.ts

# Verify TypeScript compilation
bun run typecheck

# Test edge case: no routes directory
rm -rf routes
bun run build:routes
cat src/routes-generated.ts  # Should be empty manifest

# Restore routes
mkdir routes
echo 'export const GET = () => Response.json({ ok: true });' > routes/health.ts
bun run build:routes
```
</verification>

<success_criteria>
- `bun run build:routes` generates src/routes-generated.ts
- Generated file has correct static imports for all route files
- Generated file exports customRoutes, buildCustomRoutes, routeManifest
- Build script handles missing routes/ directory (empty manifest)
- Build script warns on lowercase method exports
- TypeScript compilation passes (`bun run typecheck`)
- package.json build script includes route generation step
</success_criteria>

<output>
After completion, create `.planning/phases/15-route-loading/15-02-SUMMARY.md`
</output>
