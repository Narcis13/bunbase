---
phase: 01-core-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/core/validation.ts
  - src/core/records.ts
autonomous: true

must_haves:
  truths:
    - "Field values are validated against their declared type before insert/update"
    - "Required fields reject null/undefined values"
    - "Invalid type values are rejected with clear error messages"
    - "Records receive auto-generated id, created_at, updated_at on creation"
    - "updated_at is refreshed on every update"
    - "Relation fields validate that referenced record exists"
  artifacts:
    - path: "src/core/validation.ts"
      provides: "Dynamic Zod schema builder for field validation"
      exports: ["buildValidator", "validateRecord"]
    - path: "src/core/records.ts"
      provides: "Record CRUD with validation and system fields"
      exports: ["createRecord", "getRecord", "updateRecord", "deleteRecord", "listRecords"]
  key_links:
    - from: "src/core/validation.ts"
      to: "zod"
      via: "Dynamic schema building"
      pattern: 'import.*z.*from.*"zod"'
    - from: "src/core/records.ts"
      to: "src/core/validation.ts"
      via: "Record validation before DB operations"
      pattern: "validateRecord"
    - from: "src/core/records.ts"
      to: "src/core/schema.ts"
      via: "Getting field definitions for validation"
      pattern: "getFields"
---

<objective>
Build the validation layer and record operations that enforce type constraints and manage system fields.

Purpose: This completes the schema system by ensuring data integrity. Without validation, invalid data could be stored, breaking the type guarantees that make schema-driven development valuable.

Output: A validation module that builds Zod schemas dynamically from field definitions, and a records module that performs CRUD with validation and automatic system field management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-core-foundation/01-RESEARCH.md
@.planning/phases/01-core-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dynamic Zod validation builder</name>
  <files>src/core/validation.ts</files>
  <action>
    Create `src/core/validation.ts`:

    1. Import z from "zod", Field type from types/collection

    2. Export `buildValidator(fields: Field[]): z.ZodObject<any>`
       Build a Zod object schema dynamically from field definitions:

       ```typescript
       function buildValidator(fields: Field[]): z.ZodObject<any> {
         const shape: Record<string, z.ZodTypeAny> = {};

         for (const field of fields) {
           let schema: z.ZodTypeAny;

           switch (field.type) {
             case "text":
               schema = z.string();
               break;
             case "number":
               schema = z.number();
               break;
             case "boolean":
               schema = z.boolean();
               break;
             case "datetime":
               // Accept ISO 8601 strings
               schema = z.string().datetime({ offset: true }).or(z.string().datetime());
               break;
             case "json":
               // Any valid JSON value
               schema = z.unknown();
               break;
             case "relation":
               // ID string of related record
               schema = z.string().min(1, "Relation ID cannot be empty");
               break;
             default:
               schema = z.unknown();
           }

           if (!field.required) {
             schema = schema.optional().nullable();
           }

           shape[field.name] = schema;
         }

         return z.object(shape);
       }
       ```

    3. Export `validateRecord(fields: Field[], data: unknown): { success: true; data: Record<string, unknown> } | { success: false; errors: z.ZodError }`
       - Build validator from fields
       - Call safeParse on data
       - Return success with parsed data, or failure with errors

    4. Export `formatValidationErrors(errors: z.ZodError): string[]`
       - Map ZodError issues to human-readable strings
       - Format: "{field}: {message}"

    Important: The validator does NOT include system fields (id, created_at, updated_at) - those are handled by the records module, not user input.
  </action>
  <verify>
    Create test:
    ```typescript
    import { buildValidator, validateRecord, formatValidationErrors } from "./src/core/validation";
    import type { Field } from "./src/types/collection";

    const fields: Field[] = [
      { id: "1", collection_id: "c1", name: "title", type: "text", required: true, options: null, created_at: "" },
      { id: "2", collection_id: "c1", name: "count", type: "number", required: false, options: null, created_at: "" },
      { id: "3", collection_id: "c1", name: "active", type: "boolean", required: true, options: null, created_at: "" }
    ];

    // Valid data
    const result1 = validateRecord(fields, { title: "Hello", active: true });
    console.log("Valid:", result1);

    // Missing required
    const result2 = validateRecord(fields, { count: 5 });
    console.log("Missing required:", result2.success ? "unexpected" : formatValidationErrors(result2.errors));

    // Wrong type
    const result3 = validateRecord(fields, { title: 123, active: true });
    console.log("Wrong type:", result3.success ? "unexpected" : formatValidationErrors(result3.errors));
    ```
    Run `bun test-validation.ts` and verify errors are caught.
  </verify>
  <done>
    validation.ts builds Zod schemas from field definitions
    Required fields reject missing values
    Type mismatches are caught with clear errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create records module with CRUD operations</name>
  <files>src/core/records.ts</files>
  <action>
    Create `src/core/records.ts`:

    1. Imports: getDatabase from database, generateId from utils/id, createSystemFields from types/record, getFields/getCollection from schema, validateRecord from validation

    2. Export `createRecord(collectionName: string, data: Record<string, unknown>): Record<string, unknown>`
       - Get collection (throw if not found)
       - Get fields for collection
       - Validate data against fields (throw if invalid with formatted errors)
       - For relation fields: verify referenced record exists (query target collection)
       - Generate system fields using createSystemFields()
       - Merge system fields with validated data
       - Build INSERT SQL dynamically from field names
       - Execute insert
       - Return the complete record with system fields

    3. Export `getRecord(collectionName: string, id: string): Record<string, unknown> | null`
       - Verify collection exists
       - SELECT * FROM {collection} WHERE id = $id
       - Return null if not found
       - Parse JSON fields back to objects (they're stored as strings)

    4. Export `listRecords(collectionName: string): Record<string, unknown>[]`
       - Verify collection exists
       - SELECT * FROM {collection}
       - Parse JSON fields
       - Return array

    5. Export `updateRecord(collectionName: string, id: string, data: Record<string, unknown>): Record<string, unknown>`
       - Get existing record (throw if not found)
       - Get fields
       - Validate the update data (only validate provided fields, not entire record)
       - For relation fields in update: verify referenced record exists
       - Set updated_at to current ISO timestamp
       - Build UPDATE SQL dynamically for provided fields + updated_at
       - Execute update
       - Return updated record (re-fetch to get latest state)

    6. Export `deleteRecord(collectionName: string, id: string): void`
       - Verify record exists (throw if not found)
       - DELETE FROM {collection} WHERE id = $id

    7. Helper function `validateRelations(fields: Field[], data: Record<string, unknown>): void`
       - For each relation field in data:
         - Get target collection from field.options.collection
         - Query target collection for the ID
         - Throw if not found: "Related record {id} not found in {collection}"

    JSON fields: stringify on insert/update, parse on read. Use `typeof value === 'object' ? JSON.stringify(value) : value` for insert.
  </action>
  <verify>
    Create integration test (requires Plan 02 to be complete for full test):
    ```typescript
    import { initDatabase, closeDatabase } from "./src/core/database";
    import { createCollection, deleteCollection } from "./src/core/schema";
    import { createRecord, getRecord, updateRecord, deleteRecord, listRecords } from "./src/core/records";

    initDatabase("test-records.db");

    // Setup
    createCollection("posts", [
      { name: "title", type: "text", required: true, options: null },
      { name: "views", type: "number", required: false, options: null }
    ]);

    // Create
    const post = createRecord("posts", { title: "Hello World", views: 0 });
    console.log("Created:", post);
    console.log("Has system fields:", !!post.id && !!post.created_at && !!post.updated_at);

    // Read
    const fetched = getRecord("posts", post.id as string);
    console.log("Fetched:", fetched);

    // Update
    const updated = updateRecord("posts", post.id as string, { views: 10 });
    console.log("Updated:", updated);
    console.log("updated_at changed:", updated.updated_at !== post.updated_at);

    // List
    const all = listRecords("posts");
    console.log("List count:", all.length);

    // Test validation - should throw
    try {
      createRecord("posts", { views: 5 }); // missing required 'title'
      console.log("ERROR: Should have thrown");
    } catch (e) {
      console.log("Correctly rejected missing required field");
    }

    // Cleanup
    deleteRecord("posts", post.id as string);
    deleteCollection("posts");
    closeDatabase();
    ```
  </verify>
  <done>
    records.ts provides CRUD operations with validation
    System fields are auto-generated on create
    updated_at is refreshed on update
    Required fields and type constraints are enforced
    Relation fields verify referenced records exist
  </done>
</task>

<task type="auto">
  <name>Task 3: Add relation validation with cross-collection check</name>
  <files>src/core/records.ts, src/core/validation.ts</files>
  <action>
    Enhance the relation field handling:

    1. In `src/core/records.ts`, add/update `validateRelations`:
       ```typescript
       function validateRelations(fields: Field[], data: Record<string, unknown>): void {
         const db = getDatabase();

         for (const field of fields) {
           if (field.type !== "relation") continue;

           const value = data[field.name];
           if (value === null || value === undefined) continue;

           const targetCollection = field.options?.collection as string;
           if (!targetCollection) {
             throw new Error(`Relation field "${field.name}" missing target collection in options`);
           }

           // Check if target collection exists
           const collection = getCollection(targetCollection);
           if (!collection) {
             throw new Error(`Relation field "${field.name}" references non-existent collection "${targetCollection}"`);
           }

           // Check if referenced record exists
           const stmt = db.prepare(`SELECT id FROM "${targetCollection}" WHERE id = $id`);
           const exists = stmt.get({ id: value });
           if (!exists) {
             throw new Error(`Related record "${value}" not found in collection "${targetCollection}"`);
           }
         }
       }
       ```

    2. Call validateRelations in createRecord and updateRecord AFTER basic validation passes

    3. Add test case for relation validation:
       ```typescript
       // Create two collections with relation
       createCollection("users", [
         { name: "name", type: "text", required: true, options: null }
       ]);
       createCollection("posts", [
         { name: "title", type: "text", required: true, options: null },
         { name: "author_id", type: "relation", required: true, options: { collection: "users" } }
       ]);

       // Create user
       const user = createRecord("users", { name: "Alice" });

       // Create post with valid relation
       const post = createRecord("posts", { title: "My Post", author_id: user.id });
       console.log("Created post with relation:", post);

       // Try invalid relation - should throw
       try {
         createRecord("posts", { title: "Bad Post", author_id: "nonexistent-id" });
         console.log("ERROR: Should have thrown");
       } catch (e) {
         console.log("Correctly rejected invalid relation:", e.message);
       }
       ```
  </action>
  <verify>
    Run the full integration test including relation validation.
    Verify that:
    1. Valid relations work
    2. Invalid relation IDs are rejected
    3. Relations to non-existent collections are rejected
    Clean up test files and database.
  </verify>
  <done>
    SCHM-11: Relation fields reference records in other collections correctly
    SCHM-12: Required field constraint works for all types including relations
    SCHM-13: Field values validated against declared type
  </done>
</task>

</tasks>

<verification>
1. All field types validate correctly (text=string, number=number, boolean=boolean, datetime=ISO string, json=any, relation=string ID)
2. Required fields reject null/undefined with clear error messages
3. Type mismatches rejected with field name and expected type in error
4. Records get id, created_at, updated_at automatically
5. updated_at changes on every update
6. Relation fields verify target record exists before allowing insert/update
7. JSON fields are stored as strings and parsed back to objects on read
</verification>

<success_criteria>
- SCHM-05: Auto-generated id, created_at, updated_at on every record - DONE
- SCHM-12: Required field constraint enforced - DONE
- SCHM-13: Field type validation working - DONE
- SCHM-11: Relation fields verify referenced records exist - DONE
- All Phase 1 success criteria from roadmap are met:
  1. Developer can create a collection with fields via API - Plans 01+02
  2. Developer can update a collection schema - Plan 02
  3. Records automatically receive system fields - Plan 03
  4. Field values rejected when violating constraints - Plan 03
  5. Relation fields reference correctly - Plan 03
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-foundation/01-03-SUMMARY.md`
</output>
