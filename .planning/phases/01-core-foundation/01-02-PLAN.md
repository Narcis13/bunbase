---
phase: 01-core-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/core/schema.ts
  - src/core/migrations.ts
autonomous: true

must_haves:
  truths:
    - "Developer can create a collection and see it in _collections table"
    - "Developer can add fields to a collection and see them in _fields table"
    - "Developer can update a collection schema without losing existing data"
    - "Developer can delete a collection and its fields are cascade-deleted"
    - "Creating a collection creates a corresponding SQLite table"
  artifacts:
    - path: "src/core/schema.ts"
      provides: "Schema manager for collection and field CRUD"
      exports: ["createCollection", "getCollection", "updateCollection", "deleteCollection", "addField", "getFields", "updateField", "removeField"]
    - path: "src/core/migrations.ts"
      provides: "Shadow table migration for schema changes"
      exports: ["migrateTable", "createTableSQL", "addColumnSQL"]
  key_links:
    - from: "src/core/schema.ts"
      to: "src/core/database.ts"
      via: "getDatabase call"
      pattern: "getDatabase\\(\\)"
    - from: "src/core/schema.ts"
      to: "src/core/migrations.ts"
      via: "table creation and modification"
      pattern: "import.*from.*migrations"
    - from: "src/core/migrations.ts"
      to: "src/types/collection.ts"
      via: "FIELD_TYPE_MAP for column types"
      pattern: "FIELD_TYPE_MAP"
---

<objective>
Build the schema manager that handles collection and field CRUD operations, including dynamic SQLite table creation and migration.

Purpose: This is the core of BunBase - the ability to define collections at runtime and have them persisted as SQLite tables. Without this, there's no schema-driven backend.

Output: A SchemaManager module that can create, read, update, and delete collections and their fields, with corresponding SQLite table operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-core-foundation/01-RESEARCH.md
@.planning/phases/01-core-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migrations module for table operations</name>
  <files>src/core/migrations.ts</files>
  <action>
    Create `src/core/migrations.ts`:

    1. Import Database from "bun:sqlite", FIELD_TYPE_MAP from types/collection

    2. Export `createTableSQL(tableName: string, fields: Field[]): string`
       - Generate CREATE TABLE SQL with:
         - id TEXT PRIMARY KEY
         - created_at TEXT DEFAULT (datetime('now'))
         - updated_at TEXT DEFAULT (datetime('now'))
         - For each field: column name, SQLite type from FIELD_TYPE_MAP, NOT NULL if required
         - For relation fields: add REFERENCES to target table (get from field.options.collection)
       - Return the SQL string

    3. Export `addColumnSQL(tableName: string, field: Field): string`
       - Generate ALTER TABLE ADD COLUMN SQL
       - Include DEFAULT value appropriate for type (empty string for text, 0 for number/boolean, null for optional)
       - Return the SQL string

    4. Export `migrateTable(db: Database, tableName: string, newFields: Field[], oldFields: Field[]): void`
       - Implement the 12-step shadow table migration pattern from research:
         a. Disable foreign keys
         b. Get existing indexes/triggers
         c. Create new table with temp name
         d. Copy data (SELECT columns that exist in both old and new)
         e. Drop old table
         f. Rename new table
         g. Recreate indexes
         h. Recreate triggers
         i. Verify FK integrity
         j. Re-enable foreign keys
       - Wrap in transaction for atomicity
       - Only use this when columns are removed or types change (detect by comparing old vs new)

    5. Export `dropTableSQL(tableName: string): string`
       - Return DROP TABLE IF EXISTS SQL

    Important: Use parameterized queries where possible, but table/column names must be interpolated (SQLite limitation). Validate names contain only alphanumeric + underscore to prevent SQL injection.
  </action>
  <verify>
    Create a test:
    ```typescript
    import { createTableSQL, addColumnSQL } from "./src/core/migrations";
    import type { Field } from "./src/types/collection";

    const fields: Field[] = [
      { id: "f1", collection_id: "c1", name: "title", type: "text", required: true, options: null, created_at: "" },
      { id: "f2", collection_id: "c1", name: "count", type: "number", required: false, options: null, created_at: "" }
    ];

    console.log(createTableSQL("posts", fields));
    ```
    Run and verify SQL looks correct with system fields + user fields.
  </verify>
  <done>
    migrations.ts exports createTableSQL, addColumnSQL, migrateTable, dropTableSQL
    SQL generation includes system fields and proper type mapping
  </done>
</task>

<task type="auto">
  <name>Task 2: Create schema manager for collection CRUD</name>
  <files>src/core/schema.ts</files>
  <action>
    Create `src/core/schema.ts`:

    1. Import: getDatabase from database, generateId from utils/id, types from types/collection, migrations module

    2. Collection CRUD:

    `createCollection(name: string, fields: Omit<Field, 'id' | 'collection_id' | 'created_at'>[]): Collection`
       - Validate name (alphanumeric + underscore, not starting with underscore or number)
       - Check name doesn't already exist (throw if duplicate)
       - Generate collection ID
       - Insert into _collections
       - For each field: generate field ID, insert into _fields
       - Create the actual SQLite table using createTableSQL
       - Return the created collection

    `getCollection(name: string): Collection | null`
       - Query _collections by name
       - Return null if not found

    `getAllCollections(): Collection[]`
       - Query all from _collections
       - Return array

    `updateCollection(name: string, newName: string): Collection`
       - Validate newName
       - Check newName doesn't conflict with existing
       - Update _collections
       - Rename SQLite table: ALTER TABLE {name} RENAME TO {newName}
       - Return updated collection

    `deleteCollection(name: string): void`
       - Delete from _collections (CASCADE will delete _fields)
       - Drop the SQLite table

    3. Field CRUD:

    `getFields(collectionName: string): Field[]`
       - Join _fields with _collections on collection_id
       - Return fields for that collection

    `addField(collectionName: string, field: Omit<Field, 'id' | 'collection_id' | 'created_at'>): Field`
       - Get collection ID
       - Validate field name
       - Check field name doesn't exist in collection
       - Insert into _fields
       - ALTER TABLE to add column (use addColumnSQL)
       - Return created field

    `updateField(collectionName: string, fieldName: string, updates: Partial<Pick<Field, 'name' | 'type' | 'required' | 'options'>>): Field`
       - Get existing field
       - If only name changed: ALTER TABLE RENAME COLUMN
       - If type or required changed: use migrateTable (shadow table pattern)
       - Update _fields record
       - Return updated field

    `removeField(collectionName: string, fieldName: string): void`
       - Get all fields for collection
       - Remove the target field from list
       - Use migrateTable to recreate without that column
       - Delete from _fields

    Wrap all multi-statement operations in transactions using db.transaction().
  </action>
  <verify>
    Create integration test:
    ```typescript
    import { initDatabase, closeDatabase } from "./src/core/database";
    import { createCollection, getCollection, getFields, addField, deleteCollection } from "./src/core/schema";

    initDatabase("test-schema.db");

    // Create collection
    const posts = createCollection("posts", [
      { name: "title", type: "text", required: true, options: null },
      { name: "body", type: "text", required: false, options: null }
    ]);
    console.log("Created:", posts);

    // Get fields
    const fields = getFields("posts");
    console.log("Fields:", fields);

    // Add field
    const viewsField = addField("posts", { name: "views", type: "number", required: false, options: null });
    console.log("Added field:", viewsField);

    // Verify table exists
    import { getDatabase } from "./src/core/database";
    const tables = getDatabase().query("SELECT sql FROM sqlite_master WHERE name = 'posts'").get();
    console.log("Table SQL:", tables);

    // Cleanup
    deleteCollection("posts");
    closeDatabase();
    ```
    Run `bun test-schema.ts` - should complete without errors.
    Clean up: `rm test-schema.db test-schema.ts`
  </verify>
  <done>
    Schema manager can create collections with fields, add/update/remove fields, and delete collections
    All operations maintain consistency between _collections/_fields metadata and actual SQLite tables
  </done>
</task>

</tasks>

<verification>
1. Creating a collection creates both metadata entries and a real SQLite table
2. The SQLite table has system fields (id, created_at, updated_at) plus user-defined fields
3. Adding a field to existing collection adds the column to the table
4. Removing a field recreates table without that column (shadow table migration)
5. Deleting a collection removes metadata AND drops the table
6. Foreign key constraints in _fields work (deleting collection cascades to fields)
</verification>

<success_criteria>
- SCHM-01: createCollection creates collection with fields - DONE
- SCHM-02: getCollection and getFields return schema info - DONE
- SCHM-03: updateField and addField modify schema - DONE
- SCHM-04: deleteCollection removes collection and all data - DONE
- SCHM-05: System fields (id, created_at, updated_at) auto-added to tables - DONE
- SCHM-06 through SCHM-10: All field types supported in createTableSQL - DONE
- SCHM-11: Relation field type creates foreign key reference - DONE
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-foundation/01-02-SUMMARY.md`
</output>
