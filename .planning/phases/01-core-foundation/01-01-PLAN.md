---
phase: 01-core-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - src/core/database.ts
  - src/types/collection.ts
  - src/types/record.ts
  - src/utils/id.ts
autonomous: true

must_haves:
  truths:
    - "Database connection can be established with proper PRAGMAs"
    - "Metadata tables (_collections, _fields) exist after initialization"
    - "Type definitions cover all field types and system fields"
    - "ID generation produces unique 21-character URL-safe strings"
  artifacts:
    - path: "package.json"
      provides: "Project dependencies"
      contains: "drizzle-orm"
    - path: "src/core/database.ts"
      provides: "Database initialization and connection"
      exports: ["initDatabase", "getDatabase"]
    - path: "src/types/collection.ts"
      provides: "Collection and Field type definitions"
      exports: ["Collection", "Field", "FieldType"]
    - path: "src/types/record.ts"
      provides: "Record type with system fields"
      exports: ["SystemFields", "Record"]
    - path: "src/utils/id.ts"
      provides: "ID generation utility"
      exports: ["generateId"]
  key_links:
    - from: "src/core/database.ts"
      to: "bun:sqlite"
      via: "Database import"
      pattern: 'import.*Database.*from.*"bun:sqlite"'
    - from: "src/utils/id.ts"
      to: "nanoid"
      via: "ID generation"
      pattern: 'import.*nanoid'
---

<objective>
Set up the BunBase project with dependencies, database initialization, and core type definitions.

Purpose: This is the foundation that all other Phase 1 work depends on. Without proper database setup and type definitions, schema management and validation cannot be built.

Output: A working Bun project with SQLite database that initializes with metadata tables, plus TypeScript types for collections, fields, and records.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Bun project with dependencies</name>
  <files>package.json, tsconfig.json, .gitignore</files>
  <action>
    1. Initialize Bun project if package.json doesn't exist: `bun init -y`
    2. Install production dependencies: `bun add drizzle-orm@^0.45.1 zod@^3.24.0 nanoid@^5.0.9`
    3. Install dev dependencies: `bun add -D drizzle-kit@^0.30.0 @types/bun`
    4. Update tsconfig.json to use strict mode, target ESNext, module NodeNext
    5. Add to .gitignore: `node_modules/`, `*.db`, `*.db-wal`, `*.db-shm`, `.env`

    The package.json scripts section should include:
    - "dev": "bun run --watch src/index.ts"
    - "build": "bun build --compile src/index.ts --outfile bunbase"
    - "typecheck": "bun run --bun tsc --noEmit"
  </action>
  <verify>
    Run `bun run typecheck` - should complete without errors (may have "no input files" which is fine)
    Run `cat package.json | grep drizzle-orm` - should show the dependency
  </verify>
  <done>
    package.json has all dependencies, tsconfig.json has strict mode, .gitignore excludes db files
  </done>
</task>

<task type="auto">
  <name>Task 2: Create core type definitions</name>
  <files>src/types/collection.ts, src/types/record.ts, src/utils/id.ts</files>
  <action>
    Create `src/types/collection.ts`:
    - Define FieldType as literal union: "text" | "number" | "boolean" | "datetime" | "json" | "relation"
    - Define FieldOptions interface for type-specific options (e.g., relation target collection)
    - Define Field interface: id, collection_id, name, type (FieldType), required (boolean), options (FieldOptions | null), created_at
    - Define Collection interface: id, name, created_at, updated_at
    - Export FIELD_TYPE_MAP constant mapping FieldType to SQLite types:
      - text -> "TEXT"
      - number -> "REAL"
      - boolean -> "INTEGER" (0/1)
      - datetime -> "TEXT" (ISO 8601)
      - json -> "TEXT" (stringified)
      - relation -> "TEXT" (foreign ID)

    Create `src/types/record.ts`:
    - Define SystemFields interface: id (string), created_at (string), updated_at (string)
    - Define Record<T> type as SystemFields & T (generic for user fields)
    - Export a createSystemFields function that returns { id: generateId(), created_at: now, updated_at: now }

    Create `src/utils/id.ts`:
    - Import nanoid
    - Export generateId function that returns nanoid() (default 21 chars)

    Do NOT use classes. Use plain TypeScript interfaces and functions.
  </action>
  <verify>
    Run `bun run typecheck` - should pass with no errors
    Run `bun -e "import { FieldType, FIELD_TYPE_MAP } from './src/types/collection'; console.log(FIELD_TYPE_MAP)"` - should print the mapping object
  </verify>
  <done>
    All type files exist with proper exports, no TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create database initialization module</name>
  <files>src/core/database.ts</files>
  <action>
    Create `src/core/database.ts`:

    1. Import Database from "bun:sqlite"

    2. Create module-level variable: `let db: Database | null = null`

    3. Define INIT_METADATA_SQL constant with:
       ```sql
       CREATE TABLE IF NOT EXISTS _collections (
         id TEXT PRIMARY KEY,
         name TEXT UNIQUE NOT NULL,
         created_at TEXT DEFAULT (datetime('now')),
         updated_at TEXT DEFAULT (datetime('now'))
       );

       CREATE TABLE IF NOT EXISTS _fields (
         id TEXT PRIMARY KEY,
         collection_id TEXT NOT NULL REFERENCES _collections(id) ON DELETE CASCADE,
         name TEXT NOT NULL,
         type TEXT NOT NULL CHECK(type IN ('text', 'number', 'boolean', 'datetime', 'json', 'relation')),
         required INTEGER DEFAULT 0,
         options TEXT,
         created_at TEXT DEFAULT (datetime('now')),
         UNIQUE(collection_id, name)
       );
       ```

    4. Export `initDatabase(path: string): Database` function:
       - Create database with `new Database(path, { strict: true, create: true })`
       - Run PRAGMAs:
         - `PRAGMA journal_mode = WAL`
         - `PRAGMA synchronous = NORMAL`
         - `PRAGMA foreign_keys = ON`
         - `PRAGMA cache_size = -64000`
       - Execute INIT_METADATA_SQL
       - Store in module variable
       - Return db

    5. Export `getDatabase(): Database` function:
       - Throw if db is null ("Database not initialized. Call initDatabase first.")
       - Return db

    6. Export `closeDatabase(): void` function:
       - Call db.close() if db exists
       - Set db to null

    Use strict: true to catch missing parameters early (as per research).
  </action>
  <verify>
    Create a test script `test-db.ts`:
    ```typescript
    import { initDatabase, getDatabase, closeDatabase } from "./src/core/database";
    const db = initDatabase("test.db");
    console.log("Tables:", db.query("SELECT name FROM sqlite_master WHERE type='table'").all());
    closeDatabase();
    ```
    Run `bun test-db.ts` - should print tables including _collections and _fields
    Clean up: `rm test.db test-db.ts`
  </verify>
  <done>
    Database initializes with WAL mode and foreign keys enabled, metadata tables created, getDatabase throws if not initialized
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes with no errors
2. Database initializes correctly with metadata tables
3. All exports are accessible: Collection, Field, FieldType, SystemFields, generateId, initDatabase, getDatabase
4. PRAGMA settings are correct (check with `PRAGMA journal_mode` returns "wal")
</verification>

<success_criteria>
- package.json has drizzle-orm, zod, nanoid dependencies
- tsconfig.json has strict mode enabled
- src/types/collection.ts exports Collection, Field, FieldType, FIELD_TYPE_MAP
- src/types/record.ts exports SystemFields, Record type, createSystemFields function
- src/utils/id.ts exports generateId function
- src/core/database.ts exports initDatabase, getDatabase, closeDatabase
- Database creates _collections and _fields tables on init
- Foreign keys are enforced (PRAGMA foreign_keys = ON)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-foundation/01-01-SUMMARY.md`
</output>
