---
phase: 03-query-capabilities
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/types/query.ts
  - src/core/query.ts
  - src/core/query.test.ts
autonomous: true

must_haves:
  truths:
    - "Query builder validates field names against schema whitelist"
    - "Filter conditions generate parameterized WHERE clauses"
    - "Sort options generate ORDER BY with ASC/DESC"
    - "Pagination generates correct LIMIT/OFFSET for 1-indexed pages"
  artifacts:
    - path: "src/types/query.ts"
      provides: "QueryOptions, FilterCondition, SortOption, PaginatedResponse types"
      exports: ["QueryOptions", "FilterCondition", "SortOption", "PaginatedResponse"]
    - path: "src/core/query.ts"
      provides: "Query building functions with validation"
      exports: ["parseQueryOptions", "buildWhereClause", "buildOrderByClause", "buildPaginationClause", "buildListQuery"]
    - path: "src/core/query.test.ts"
      provides: "Test coverage for query builder"
      min_lines: 100
  key_links:
    - from: "src/core/query.ts"
      to: "src/types/query.ts"
      via: "type imports"
      pattern: "import.*from.*types/query"
    - from: "src/core/query.ts"
      to: "src/core/schema.ts"
      via: "getFields for validation"
      pattern: "getFields"
---

<objective>
Implement query builder module with filtering, sorting, and pagination using TDD approach.

Purpose: Create the SQL query construction layer that transforms URL query parameters into safe, parameterized SQL. This is the algorithmic core of Phase 3 - all filtering, sorting, and pagination logic lives here.

Output: Type definitions for query options, query builder functions that generate parameterized SQL, and comprehensive test coverage proving correctness.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-query-capabilities/03-RESEARCH.md
@src/types/collection.ts
@src/core/schema.ts
@src/core/records.ts
</context>

<feature>
  <name>Query Builder with TDD</name>
  <files>src/types/query.ts, src/core/query.ts, src/core/query.test.ts</files>
  <behavior>
    Query builder transforms structured query options into parameterized SQL.

    **Types (src/types/query.ts):**
    - FilterCondition: { field, operator, value } where operator is =, !=, >, <, >=, <=, ~, !~
    - SortOption: { field, direction } where direction is "asc" or "desc"
    - QueryOptions: { filter?, sort?, page?, perPage?, expand? }
    - PaginatedResponse<T>: { page, perPage, totalItems, totalPages, items }

    **Functions (src/core/query.ts):**

    1. parseQueryOptions(url: URL): QueryOptions
       - page=2 -> page: 2
       - perPage=10 -> perPage: 10 (default 30, max 500, min 1)
       - sort=-created_at,title -> sort: [{field: "created_at", direction: "desc"}, {field: "title", direction: "asc"}]
       - expand=author,category -> expand: ["author", "category"]
       - Filter params parsed from query string (field=value, field[op]=value)

    2. validateFieldName(fieldName: string, fields: Field[]): boolean
       - Returns true for system fields: id, created_at, updated_at
       - Returns true for fields in schema
       - Returns false otherwise

    3. buildWhereClause(conditions: FilterCondition[], fields: Field[]): { sql: string, params: Record<string, unknown> }
       - Empty conditions -> { sql: "", params: {} }
       - [{field: "status", operator: "=", value: "active"}] -> { sql: 'WHERE "status" = $filter_0', params: { filter_0: "active" } }
       - Operator ~ uses LIKE with % wildcards and ESCAPE
       - Throws if field not in whitelist

    4. buildOrderByClause(sort: SortOption[], fields: Field[]): string
       - Empty sort -> ""
       - [{field: "created_at", direction: "desc"}] -> 'ORDER BY "created_at" DESC'
       - Multiple: [{field: "created_at", direction: "desc"}, {field: "title", direction: "asc"}] -> 'ORDER BY "created_at" DESC, "title" ASC'
       - Throws if field not in whitelist

    5. buildPaginationClause(page: number, perPage: number): { sql: string, offset: number }
       - page=1, perPage=30 -> { sql: "LIMIT 30 OFFSET 0", offset: 0 }
       - page=3, perPage=10 -> { sql: "LIMIT 10 OFFSET 20", offset: 20 }

    6. buildListQuery(collectionName: string, options: QueryOptions, fields: Field[]): { sql: string, countSql: string, params: Record<string, unknown> }
       - Combines WHERE, ORDER BY, LIMIT/OFFSET
       - Returns both SELECT and COUNT queries
       - Validates all field names before building SQL
  </behavior>
  <implementation>
    RED phase: Write failing tests for each function covering:
    - Happy path cases
    - Edge cases (empty input, boundary values)
    - Error cases (invalid field names)
    - SQL injection prevention (field names validated, values parameterized)

    GREEN phase: Implement minimal code to pass tests:
    - Types in src/types/query.ts
    - Functions in src/core/query.ts using patterns from 03-RESEARCH.md
    - Use bun:sqlite $paramName syntax for parameterized values
    - Quote column names with double quotes for SQLite

    REFACTOR (if needed): Clean up implementation.
  </implementation>
</feature>

<verification>
All tests pass: `bun test src/core/query.test.ts`

Key test coverage:
- parseQueryOptions extracts all query params correctly
- buildWhereClause generates valid SQL for all operators
- buildWhereClause throws on invalid field names
- buildOrderByClause handles multiple sort fields
- buildPaginationClause calculates correct offset
- buildListQuery assembles complete queries
- LIKE operator escapes special characters (%, _)
</verification>

<success_criteria>
1. All 15+ test cases pass
2. No SQL injection possible (field names validated, values parameterized)
3. Types exported and usable from other modules
4. Query builder functions work with empty, single, and multiple conditions
5. Pagination uses 1-indexed pages with correct offset calculation
</success_criteria>

<output>
After completion, create `.planning/phases/03-query-capabilities/03-01-SUMMARY.md`
</output>
