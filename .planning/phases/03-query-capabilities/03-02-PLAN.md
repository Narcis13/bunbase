---
phase: 03-query-capabilities
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/core/expand.ts
  - src/core/records.ts
  - src/api/server.ts
  - src/api/server.test.ts
autonomous: true

must_haves:
  truths:
    - "Developer can filter records with ?field=value query parameters"
    - "Developer can sort records with ?sort=-field,field2 parameter"
    - "Developer can paginate with ?page=N&perPage=M parameters"
    - "Developer can expand relations with ?expand=fieldName parameter"
    - "Response includes totalItems, totalPages, page, perPage for pagination"
  artifacts:
    - path: "src/core/expand.ts"
      provides: "Relation expansion logic"
      exports: ["expandRelations"]
    - path: "src/core/records.ts"
      provides: "Extended listRecordsWithQuery function"
      exports: ["listRecordsWithQuery"]
    - path: "src/api/server.ts"
      provides: "Updated GET handler with query support"
      contains: "parseQueryOptions"
  key_links:
    - from: "src/api/server.ts"
      to: "src/core/query.ts"
      via: "parseQueryOptions import"
      pattern: "import.*parseQueryOptions.*from.*query"
    - from: "src/api/server.ts"
      to: "src/core/records.ts"
      via: "listRecordsWithQuery call"
      pattern: "listRecordsWithQuery"
    - from: "src/core/records.ts"
      to: "src/core/expand.ts"
      via: "expandRelations call"
      pattern: "expandRelations"
    - from: "src/core/records.ts"
      to: "src/core/query.ts"
      via: "query building imports"
      pattern: "import.*from.*query"
---

<objective>
Integrate query builder with records module and HTTP server, add relation expansion.

Purpose: Wire up the query builder (from Plan 01) to the existing REST API, enabling full query capabilities on the list endpoint. Add relation expansion for fetching related records inline.

Output: Working GET /api/collections/:name/records endpoint with filter, sort, pagination, and expand support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-query-capabilities/03-RESEARCH.md
@.planning/phases/03-query-capabilities/03-01-SUMMARY.md
@src/types/query.ts
@src/core/query.ts
@src/core/records.ts
@src/api/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create relation expansion module</name>
  <files>src/core/expand.ts</files>
  <action>
    Create src/core/expand.ts with expandRelations function:

    ```typescript
    import { getRecord } from "./records";
    import type { Field } from "../types/collection";

    /**
     * Expand relation fields by fetching related records.
     * Only expands fields that are type "relation" and in expandFields list.
     * Adds "expand" object to each record with resolved relations.
     *
     * @param records - Array of records to expand
     * @param expandFields - Field names to expand (from ?expand= param)
     * @param fields - Schema field definitions
     * @returns Records with expand object containing related records
     */
    export function expandRelations(
      records: Record<string, unknown>[],
      expandFields: string[],
      fields: Field[]
    ): Record<string, unknown>[] {
      // Filter to only relation fields that match expand request
      const relationFields = fields.filter(
        f => f.type === "relation" && expandFields.includes(f.name)
      );

      if (relationFields.length === 0) return records;

      return records.map(record => {
        const expanded: Record<string, unknown> = { ...record };
        const expand: Record<string, unknown> = {};

        for (const field of relationFields) {
          const relatedId = record[field.name] as string | null;
          if (!relatedId) continue;

          const targetCollection = (field.options?.collection || field.options?.target) as string;
          if (!targetCollection) continue;

          try {
            const relatedRecord = getRecord(targetCollection, relatedId);
            if (relatedRecord) {
              expand[field.name] = relatedRecord;
            }
          } catch {
            // If related collection doesn't exist or other error, skip silently
          }
        }

        if (Object.keys(expand).length > 0) {
          expanded.expand = expand;
        }

        return expanded;
      });
    }
    ```

    Key behaviors:
    - Only expand fields that are type "relation" AND in the expand list
    - Handle null/undefined relation values gracefully (skip)
    - Handle missing target collection gracefully (skip, don't crash)
    - Handle missing related record gracefully (skip, don't crash)
    - Add "expand" object only if there are expanded relations
  </action>
  <verify>TypeScript compiles: `bun build --dry-run src/core/expand.ts`</verify>
  <done>expandRelations function exists and handles edge cases</done>
</task>

<task type="auto">
  <name>Task 2: Add listRecordsWithQuery to records module</name>
  <files>src/core/records.ts</files>
  <action>
    Modify src/core/records.ts to add listRecordsWithQuery function:

    1. Add imports at top:
    ```typescript
    import { buildListQuery } from "./query";
    import { expandRelations } from "./expand";
    import type { QueryOptions, PaginatedResponse } from "../types/query";
    ```

    2. Export the existing parseJsonFields function (currently internal):
    ```typescript
    export function parseJsonFields(...)  // Change from function to export function
    ```

    3. Add new function after listRecords:
    ```typescript
    /**
     * List records with query options (filter, sort, pagination, expand).
     *
     * @param collectionName - Name of the collection
     * @param options - Query options from URL parameters
     * @returns Paginated response with items and metadata
     */
    export function listRecordsWithQuery(
      collectionName: string,
      options: QueryOptions
    ): PaginatedResponse<Record<string, unknown>> {
      const db = getDatabase();

      // Verify collection exists
      const collection = getCollection(collectionName);
      if (!collection) {
        throw new Error(`Collection "${collectionName}" not found`);
      }

      const fields = getFields(collectionName);
      const { sql, countSql, params } = buildListQuery(collectionName, options, fields);

      // Get total count (for pagination metadata)
      const countResult = db.prepare(countSql).get(params) as { count: number } | null;
      const totalItems = countResult?.count ?? 0;

      // Get paginated items
      let items = db.prepare(sql).all(params) as Record<string, unknown>[];

      // Parse JSON and boolean fields
      items = items.map(record => parseJsonFields(fields, record));

      // Expand relations if requested
      if (options.expand && options.expand.length > 0) {
        items = expandRelations(items, options.expand, fields);
      }

      const page = options.page || 1;
      const perPage = options.perPage || 30;

      return {
        page,
        perPage,
        totalItems,
        totalPages: Math.ceil(totalItems / perPage) || 1,
        items,
      };
    }
    ```

    Note: Keep the original listRecords function unchanged for backward compatibility. The new function is additive.
  </action>
  <verify>TypeScript compiles: `bun build --dry-run src/core/records.ts`</verify>
  <done>listRecordsWithQuery function exists and returns paginated response</done>
</task>

<task type="auto">
  <name>Task 3: Update server to use query capabilities and add tests</name>
  <files>src/api/server.ts, src/api/server.test.ts</files>
  <action>
    **Update src/api/server.ts:**

    1. Add import:
    ```typescript
    import { parseQueryOptions } from "../core/query";
    import { listRecordsWithQuery } from "../core/records";
    // Remove listRecords from existing import if not used elsewhere
    ```

    2. Update the GET handler for list endpoint:
    ```typescript
    "/api/collections/:name/records": {
      GET: (req) => {
        try {
          const { name } = req.params;
          const url = new URL(req.url);
          const options = parseQueryOptions(url);
          const result = listRecordsWithQuery(name, options);
          return Response.json(result);
        } catch (error) {
          const err = error as Error;
          // Add 400 for invalid field errors
          if (err.message.includes("Invalid filter field") || err.message.includes("Invalid sort field")) {
            return errorResponse(err.message, 400);
          }
          return errorResponse(err.message, mapErrorToStatus(err));
        }
      },
      // ... POST handler unchanged
    }
    ```

    **Add tests to src/api/server.test.ts:**

    Add test cases for query capabilities (after existing tests):

    ```typescript
    // Query capabilities tests
    describe("GET /api/collections/:name/records - Query Capabilities", () => {
      test("pagination returns correct page and perPage", async () => {
        // Create 5 records, request page 2 with perPage 2
        // Expect items.length <= 2, page: 2, totalItems: 5
      });

      test("sort by field ascending", async () => {
        // Create records with different values, sort=fieldName
        // Verify order is ascending
      });

      test("sort by field descending with minus prefix", async () => {
        // sort=-fieldName
        // Verify order is descending
      });

      test("filter with equals operator", async () => {
        // ?status=active filters to only matching records
      });

      test("filter with not equals operator", async () => {
        // ?status[ne]=active OR implement != parsing
      });

      test("filter with like operator", async () => {
        // ?title[like]=hello returns records where title contains "hello"
      });

      test("expand relation field", async () => {
        // Create author collection, create post with author relation
        // GET with ?expand=author should include expand.author object
      });

      test("invalid filter field returns 400", async () => {
        // ?nonexistent=value should return 400 error
      });

      test("invalid sort field returns 400", async () => {
        // ?sort=nonexistent should return 400 error
      });

      test("response includes pagination metadata", async () => {
        // Verify response has: page, perPage, totalItems, totalPages, items
      });
    });
    ```

    Implementation notes:
    - Use existing test setup patterns from the file
    - Create test collections and records as needed
    - Clean up after tests
  </action>
  <verify>
    All tests pass: `bun test src/api/server.test.ts`

    Manual verification:
    1. Start server: `bun run src/api/server.ts` (or test via test file)
    2. Create test collection and records
    3. Test query params work as expected
  </verify>
  <done>
    GET endpoint supports filter, sort, pagination, expand parameters.
    Response format is { page, perPage, totalItems, totalPages, items }.
    Invalid field names return 400 errors.
    Tests cover all query capabilities.
  </done>
</task>

</tasks>

<verification>
**All tests pass:**
```bash
bun test
```

**Requirements coverage:**
- API-06: Filter with =, !=, >, <, ~ operators works
- API-07: sort parameter with - prefix for descending works
- API-08: page and perPage parameters work, response includes pagination metadata
- API-09: expand parameter fetches related records

**Manual verification (optional):**
```bash
# Start server
bun run src/api/server.ts &

# Create a collection
curl -X POST http://localhost:8090/api/admin/collections -d '{"name":"posts","fields":[{"name":"title","type":"text"},{"name":"status","type":"text"}]}'

# Create records
curl -X POST http://localhost:8090/api/collections/posts/records -d '{"title":"First","status":"draft"}'
curl -X POST http://localhost:8090/api/collections/posts/records -d '{"title":"Second","status":"published"}'

# Test query
curl "http://localhost:8090/api/collections/posts/records?status=published&sort=-title&page=1&perPage=10"
```
</verification>

<success_criteria>
1. All existing tests continue to pass (no regression)
2. New query capability tests pass
3. GET /api/collections/:name/records accepts filter, sort, page, perPage, expand params
4. Response format includes pagination metadata (page, perPage, totalItems, totalPages)
5. Invalid field names in filter/sort return 400 Bad Request
6. Relation expansion returns related record data in expand object
</success_criteria>

<output>
After completion, create `.planning/phases/03-query-capabilities/03-02-SUMMARY.md`
</output>
