# Phase 16: Server Integration - Research

**Researched:** 2026-01-30
**Domain:** Bun.serve routes integration, context injection, error handling middleware, CLI startup, hot reload
**Confidence:** HIGH

## Summary

Phase 16 integrates custom routes (generated in Phase 15) into the BunBase server. The primary challenge is merging custom routes with existing system routes while ensuring all handlers receive proper context and error handling. Research confirms Bun.serve's routes object supports direct object spread for merging, and handlers automatically receive `req.params` for dynamic segments.

The codebase is already 95% ready: Phase 15 generated `src/routes-generated.ts` with a `buildCustomRoutes(deps)` function that returns a Bun.serve-compatible routes object. Phase 14 provided `createRouteContext()` and `handleApiError()` which are already imported and used in the generated file. The remaining work is:

1. Modify `createServer()` to accept and merge custom routes
2. Update `startServer()` to call `buildCustomRoutes()` with proper dependencies
3. Update CLI to invoke route loading at startup
4. Configure development mode for hot reload support
5. Ensure custom routes work in compiled binary (static imports are already in place)

**Primary recommendation:** Add a single `customRoutes` parameter to `createServer()` and use object spread to merge with system routes. Custom routes go AFTER system routes in the spread to allow overrides where needed, but BEFORE admin routes to prevent conflicts with `/_/*` patterns.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Bun.serve | 1.2+ | HTTP server with routes | Native Bun API, built-in routing |
| BunBase routes-generated | N/A | Custom route manifest | Generated by Phase 15, provides buildCustomRoutes() |
| BunBase api/context | N/A | RouteContext factory | Phase 14 implementation |
| BunBase api/errors | N/A | Error handling | Phase 14 implementation |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Bun.env | built-in | Environment detection | Check BUNBASE_DEV, NODE_ENV for dev mode |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Object spread for route merging | Deep merge utility | Spread is simpler and sufficient for shallow route objects |
| Passing deps through createServer | Closure over global hooks/realtime | Explicit deps are testable and clear |
| Route prefix collision check | Trust developer | Could add build-time warning but overhead not worth it for v0.3 |

**Installation:**
```bash
# No new packages needed - all functionality from existing code
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── api/
│   ├── server.ts          # Modified: accepts customRoutes param
│   ├── context.ts         # Phase 14: createRouteContext
│   └── errors.ts          # Phase 14: handleApiError
├── routes/
│   └── discovery.ts       # Phase 15: route utilities
├── routes-generated.ts    # Phase 15: generated manifest
└── cli.ts                 # Modified: loads routes at startup
```

### Pattern 1: Route Object Merging
**What:** Combine system routes with custom routes using object spread
**When to use:** In createServer() to build final routes object
**Example:**
```typescript
// Source: Bun.serve documentation + existing server.ts pattern
function createServer(
  port: number = 8090,
  hooks?: HookManager,
  realtime?: RealtimeManager,
  customRoutes?: Record<string, unknown>  // New parameter
) {
  const hookManager = hooks ?? new HookManager();
  const realtimeManager = realtime ?? new RealtimeManager();

  // Build routes object with spread
  const routes = {
    // System routes first (CRUD, auth, files)
    "/api/collections/:name/records": { ... },
    "/api/collections/:name/records/:id": { ... },
    // ... other system routes

    // Custom routes in middle (can override system routes)
    ...(customRoutes ?? {}),

    // Admin routes last (/_/* catches all admin paths)
    "/_/api/auth/login": { ... },
    "/_/api/collections": { ... },
    "/_/": () => new Response(adminHtml, { headers: { "Content-Type": "text/html" } }),
    "/_/*": () => new Response(adminHtml, { headers: { "Content-Type": "text/html" } }),
  };

  return Bun.serve({
    port,
    routes,
    fetch(req) {
      return errorResponse("Not found", 404);
    },
  });
}
```

### Pattern 2: Startup Route Loading
**What:** Load custom routes in CLI before starting server
**When to use:** In cli.ts main() function and startServer()
**Example:**
```typescript
// Source: BunBase cli.ts + Phase 15 routes-generated pattern
import { buildCustomRoutes, routeManifest } from './routes-generated';

async function main(): Promise<void> {
  // ... existing CLI parsing ...

  // Build custom routes with dependencies
  const customRoutes = buildCustomRoutes({ hooks: hookManager, realtime: realtimeManager });

  // Log discovered routes in development
  if (Bun.env.NODE_ENV === 'development' || Bun.env.BUNBASE_DEV === 'true') {
    console.log(`Loaded ${routeManifest.routes.length} custom route(s):`);
    for (const route of routeManifest.routes) {
      console.log(`  ${route.path} [${route.methods.join(', ')}]`);
    }
  }

  // Pass to server
  await startServer(port, dbPath, hookManager, smtpConfig, realtimeManager, customRoutes);
}
```

### Pattern 3: Development Mode Configuration
**What:** Enable HMR and console logging for development
**When to use:** When BUNBASE_DEV=true or NODE_ENV=development
**Example:**
```typescript
// Source: Bun.serve documentation for development mode
const isDev = Bun.env.NODE_ENV === 'development' || Bun.env.BUNBASE_DEV === 'true';

return Bun.serve({
  port,
  routes,
  development: isDev ? {
    hmr: true,      // Enable hot module replacement
    console: true,  // Stream browser console to terminal
  } : false,
  fetch(req) {
    return errorResponse("Not found", 404);
  },
});
```

### Pattern 4: Context Injection Already Handled
**What:** Route handlers receive Request and RouteContext
**When to use:** Already implemented in Phase 15's wrapHandler()
**Example:**
```typescript
// Source: src/routes-generated.ts (already implemented in Phase 15)
function wrapHandler(
  handler: RouteHandler,
  deps: ContextDependencies
): (req: Request) => Promise<Response> {
  return async (req: Request) => {
    try {
      // Extract params from request (Bun.serve adds them)
      const params = (req as Request & { params?: Record<string, string> }).params ?? {};
      const ctx = createRouteContext(req, params, deps);
      return await handler(req, ctx);
    } catch (error) {
      return handleApiError(error);
    }
  };
}
```

### Anti-Patterns to Avoid
- **Custom routes overwriting admin routes:** Place admin routes AFTER custom routes in spread order
- **Missing deps at startup:** Always create HookManager/RealtimeManager before buildCustomRoutes()
- **Registering hooks after buildCustomRoutes:** Hooks must be registered before routes are built (hooks passed by reference, so this works)
- **Skipping development mode:** Always check BUNBASE_DEV for proper DX during development
- **Dynamic import for routes:** Never `await import()` routes at runtime - use static imports from routes-generated

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Route merging | Custom merge logic | Object spread | Bun routes are flat, spread works perfectly |
| Error handling wrapper | Custom try/catch in each route | wrapHandler() from routes-generated | Already handles all edge cases |
| Context creation | Manual object construction | createRouteContext() from context.ts | Provides all API surfaces (records, auth, files) |
| Hot reload | Custom file watcher | Bun's development.hmr option | Built into Bun.serve, works with --hot flag |
| Param extraction | Manual URL parsing | req.params from Bun.serve | Automatic, type-safe |

**Key insight:** Phase 14 and 15 already built all the complex pieces. Phase 16 is primarily wiring - connecting buildCustomRoutes() to createServer() and startServer().

## Common Pitfalls

### Pitfall 1: Route Order Matters
**What goes wrong:** Admin `/_/*` wildcard catches custom routes that start with `/_/`
**Why it happens:** Spread order determines precedence for overlapping patterns
**How to avoid:** Custom routes before admin catch-all, system CRUD routes before custom
**Warning signs:** Custom routes return admin HTML instead of expected response

### Pitfall 2: Missing Context Dependencies
**What goes wrong:** buildCustomRoutes() called without hooks/realtime, handlers fail
**Why it happens:** Forgetting to create managers before building routes
**How to avoid:** Always create HookManager and RealtimeManager before buildCustomRoutes()
**Warning signs:** Runtime error about hooks being undefined, realtime events not working

### Pitfall 3: Development Mode Not Detected
**What goes wrong:** Hot reload doesn't work during development
**Why it happens:** Checking only NODE_ENV, missing BUNBASE_DEV check
**How to avoid:** Check both `NODE_ENV === 'development'` AND `BUNBASE_DEV === 'true'`
**Warning signs:** Changes require full restart, no HMR messages in console

### Pitfall 4: Binary Build Missing Routes
**What goes wrong:** Compiled binary has no custom routes
**Why it happens:** build:routes not run before bun build --compile
**How to avoid:** Package.json build script already correct: `bun run build:routes && ... && bun build --compile`
**Warning signs:** Works in dev, 404 in compiled binary

### Pitfall 5: Custom Routes vs System Routes Conflict
**What goes wrong:** Custom /api/collections/:name route conflicts with system route
**Why it happens:** Same path registered twice
**How to avoid:** Document that /api/collections/* is reserved; custom routes use different paths
**Warning signs:** Unexpected behavior on CRUD operations

### Pitfall 6: Forgetting to Pass customRoutes to createServer
**What goes wrong:** Routes loaded but not used
**Why it happens:** Updated startServer() but forgot to pass to createServer()
**How to avoid:** Follow parameter chain: cli.ts -> startServer() -> createServer()
**Warning signs:** Console shows routes loaded, but requests return 404

## Code Examples

Verified patterns from official Bun docs and existing BunBase codebase:

### Server Integration (createServer modification)
```typescript
// Source: Existing src/api/server.ts + Bun.serve routes documentation
export function createServer(
  port: number = 8090,
  hooks?: HookManager,
  realtime?: RealtimeManager,
  customRoutes?: Record<string, Record<string, (req: Request) => Promise<Response>>>
) {
  const hookManager = hooks ?? new HookManager();
  const realtimeManager = realtime ?? new RealtimeManager();
  const isDev = Bun.env.NODE_ENV === 'development' || Bun.env.BUNBASE_DEV === 'true';

  return Bun.serve({
    port,
    development: isDev ? { hmr: true, console: true } : false,
    routes: {
      // System CRUD routes
      "/api/collections/:name/records": {
        GET: async (req) => { /* existing implementation */ },
        POST: async (req) => { /* existing implementation */ },
      },
      "/api/collections/:name/records/:id": {
        GET: async (req) => { /* existing implementation */ },
        PATCH: async (req) => { /* existing implementation */ },
        DELETE: async (req) => { /* existing implementation */ },
      },
      // ... other system routes (files, realtime, auth)

      // Custom routes (merged in middle)
      ...(customRoutes ?? {}),

      // Admin routes (must be last due to /_/* wildcard)
      "/_/api/auth/login": { POST: async (req) => { /* existing */ } },
      "/_/api/auth/me": { GET: async (req) => { /* existing */ } },
      "/_/api/collections": { /* existing */ },
      "/_/api/collections/:name": { /* existing */ },
      "/_/api/collections/:name/fields": { /* existing */ },
      "/_/api/collections/:name/fields/:fieldName": { /* existing */ },
      "/_/assets/main.js": () => new Response(adminJs, { headers: { "Content-Type": "application/javascript" } }),
      "/_/assets/globals.css": () => new Response(adminCss, { headers: { "Content-Type": "text/css" } }),
      "/_/": () => new Response(adminHtml, { headers: { "Content-Type": "text/html" } }),
      "/_/*": () => new Response(adminHtml, { headers: { "Content-Type": "text/html" } }),
    },
    fetch(req) {
      return errorResponse("Not found", 404);
    },
  });
}
```

### startServer Update
```typescript
// Source: Existing src/api/server.ts
export async function startServer(
  port: number = 8090,
  dbPath: string = "bunbase.db",
  hooks?: HookManager,
  smtpConfig?: SmtpConfig | null,
  realtime?: RealtimeManager,
  customRoutes?: Record<string, Record<string, (req: Request) => Promise<Response>>>
) {
  initDatabase(dbPath);

  const hookManager = hooks ?? new HookManager();
  const realtimeManager = realtime ?? new RealtimeManager();

  // Register built-in hooks
  registerFileCleanupHook(hookManager);
  registerRealtimeHooks(hookManager, realtimeManager);
  realtimeManager.startInactivityCleanup(60000);

  // Email service
  if (smtpConfig) {
    initEmailService(smtpConfig);
    console.log(`Email service configured (${smtpConfig.host}:${smtpConfig.port})`);
  }

  // Admin account
  const existingAdmin = getAdminByEmail("admin@bunbase.local");
  if (!existingAdmin) {
    // ... existing admin creation logic
  }

  const server = createServer(port, hookManager, realtimeManager, customRoutes);
  console.log(`BunBase running at http://localhost:${port}`);
  return server;
}
```

### CLI Update
```typescript
// Source: Existing src/cli.ts + Phase 15 routes-generated
import { buildCustomRoutes, routeManifest } from './routes-generated';

async function main(): Promise<void> {
  const { values } = parseArgs({ /* existing config */ });

  if (values.help) {
    showHelp();
  }

  const port = validatePort(values.port!);
  const dbPath = values.db!;
  const smtpConfig = loadSmtpConfig({ /* existing */ });

  // Create managers for route building
  const hookManager = new HookManager();
  const realtimeManager = new RealtimeManager();

  // Build custom routes with context dependencies
  const customRoutes = buildCustomRoutes({
    hooks: hookManager,
    realtime: realtimeManager,
  });

  // Log routes in development mode
  const isDev = Bun.env.NODE_ENV === 'development' || Bun.env.BUNBASE_DEV === 'true';
  if (isDev && routeManifest.routes.length > 0) {
    console.log(`Custom routes (${routeManifest.routes.length}):`);
    for (const route of routeManifest.routes) {
      console.log(`  ${route.methods.join(',')} ${route.path}`);
    }
  }

  // Start server with custom routes
  await startServer(port, dbPath, hookManager, smtpConfig, realtimeManager, customRoutes);
}
```

### Hot Reload Test
```typescript
// Source: Bun documentation + manual testing pattern
// To verify hot reload works:
// 1. Start server with: BUNBASE_DEV=true bun --hot src/cli.ts
// 2. Modify a file in routes/
// 3. Verify console shows HMR update
// 4. Request to the modified route returns new response
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Express middleware chain | Bun.serve routes object | Bun 1.0+ (2023) | Simpler, faster |
| Manual route registration | File-based routing with manifest | Common in modern frameworks | Better DX |
| Separate dev server | development: { hmr: true } | Bun 1.2.3 (2025) | Single server for dev/prod |
| Custom hot reload | Built-in HMR in Bun.serve | Bun 1.2+ (2025) | Zero config |

**Deprecated/outdated:**
- Express/Hono-style middleware: Bun.serve routes are simpler, don't need middleware chains
- Vite for development: Bun.serve with development mode handles HMR natively
- webpack/esbuild for bundling: `bun build --compile` handles everything

## Open Questions

Things that couldn't be fully resolved:

1. **Route reload without server restart**
   - What we know: Bun.serve supports `server.reload()` to update routes at runtime
   - What's unclear: Whether file changes in routes/ can trigger automatic reload without --hot flag
   - Recommendation: Document that --hot flag is required for development; `bun run dev` already uses --watch

2. **Custom route conflict detection**
   - What we know: Object spread silently overwrites on collision
   - What's unclear: Whether to add build-time warning for /api/collections/* paths
   - Recommendation: Defer to Phase 17; document reserved paths in user documentation

3. **Error handling for non-custom routes**
   - What we know: Custom routes get handleApiError wrapper; system routes use old errorResponse()
   - What's unclear: Whether to migrate all system routes to handleApiError()
   - Recommendation: Out of scope for Phase 16; would be breaking change in error format

## Sources

### Primary (HIGH confidence)
- [Bun.serve Routes Documentation](https://bun.com/docs/api/http) - Route structure, parameters, spread behavior
- [Bun Hot Reloading](https://bun.com/docs/bundler/hot-reloading) - development.hmr option
- [Bun Single Binary](https://bun.com/docs/bundler/executables) - Static imports for binary embedding
- bun-types/serve.d.ts - TypeScript definitions for Bun.serve
- BunBase src/api/server.ts - Existing server implementation
- BunBase src/api/context.ts - RouteContext and createRouteContext (Phase 14)
- BunBase src/api/errors.ts - handleApiError (Phase 14)
- BunBase src/routes-generated.ts - buildCustomRoutes function (Phase 15)
- BunBase scripts/build-routes.ts - Manifest generation (Phase 15)

### Secondary (MEDIUM confidence)
- Bun GitHub discussions on route merging patterns
- Bun release notes for v1.2.3 (routes introduction)

### Tertiary (LOW confidence)
- None - all findings verified with official sources and existing codebase

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Uses existing BunBase code + Bun built-ins
- Architecture: HIGH - Simple parameter passing and object spread
- Pitfalls: HIGH - Based on Bun docs and Phase 15 learnings

**Research date:** 2026-01-30
**Valid until:** 90 days (stable Bun.serve API, existing code patterns)
