---
phase: 06-admin-ui-records
plan: 04
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - src/admin/components/records/RecordsTable.tsx
  - src/admin/components/records/RecordsView.tsx
  - src/admin/hooks/useRecords.ts
  - src/admin/hooks/useCollectionFields.ts
  - src/api/server.ts
  - src/admin/App.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can browse records in a collection"
    - "Table shows all fields as columns"
    - "Pagination controls navigate between pages"
    - "Table has actions column with dropdown menu"
  artifacts:
    - path: "src/admin/components/records/RecordsTable.tsx"
      provides: "Data table with TanStack Table for records"
      min_lines: 100
    - path: "src/admin/components/records/RecordsView.tsx"
      provides: "Records view with table and controls"
      min_lines: 50
    - path: "src/admin/hooks/useRecords.ts"
      provides: "Hook to fetch paginated records"
      exports: ["useRecords"]
    - path: "src/admin/hooks/useCollectionFields.ts"
      provides: "Hook to fetch collection fields"
      exports: ["useCollectionFields"]
  key_links:
    - from: "src/admin/components/records/RecordsTable.tsx"
      to: "@tanstack/react-table"
      via: "useReactTable hook"
      pattern: "useReactTable"
    - from: "src/admin/components/records/RecordsView.tsx"
      to: "src/admin/hooks/useRecords.ts"
      via: "hook call"
      pattern: "useRecords"
---

<objective>
Create the records browser with paginated data table

Purpose: Enable admins to browse collection records with pagination (UI-02)
Output: Records table with dynamic columns based on collection fields
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-admin-ui-records/06-CONTEXT.md
@.planning/phases/06-admin-ui-records/06-RESEARCH.md
@src/admin/App.tsx
@src/admin/hooks/useCollections.ts
@src/api/server.ts
@src/types/collection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API endpoint and hooks for records and fields</name>
  <files>
    - src/api/server.ts
    - src/admin/hooks/useRecords.ts
    - src/admin/hooks/useCollectionFields.ts
  </files>
  <action>
**Update src/api/server.ts** - Add fields endpoint:

Add a route to get fields for a collection (admin-protected):

```typescript
"/_/api/collections/:name/fields": {
  GET: async (req) => {
    const adminOrError = await requireAdmin(req);
    if (adminOrError instanceof Response) return adminOrError;

    const { name } = req.params;
    try {
      const fields = getFields(name);
      return Response.json(fields);
    } catch (error) {
      const err = error as Error;
      return errorResponse(err.message, mapErrorToStatus(err));
    }
  },
}
```

**Create src/admin/hooks/useCollectionFields.ts**:

```typescript
import { useState, useEffect } from "react";
import { fetchWithAuth } from "@/lib/api";

export interface Field {
  id: string;
  collection_id: string;
  name: string;
  type: "text" | "number" | "boolean" | "datetime" | "json" | "relation";
  required: boolean;
  options: { target?: string } | null;
  created_at: string;
}

export function useCollectionFields(collectionName: string) {
  const [fields, setFields] = useState<Field[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchFields = async () => {
      setLoading(true);
      try {
        const response = await fetchWithAuth(`/_/api/collections/${collectionName}/fields`);
        const data = await response.json();
        setFields(data);
        setError(null);
      } catch (e) {
        setError((e as Error).message);
      } finally {
        setLoading(false);
      }
    };

    fetchFields();
  }, [collectionName]);

  return { fields, loading, error };
}
```

**Create src/admin/hooks/useRecords.ts**:

```typescript
import { useState, useEffect, useCallback } from "react";
import { fetchWithAuth } from "@/lib/api";

interface RecordsResponse {
  items: Record<string, unknown>[];
  totalItems: number;
}

interface UseRecordsOptions {
  page?: number;
  perPage?: number;
}

export function useRecords(
  collectionName: string,
  options: UseRecordsOptions = {}
) {
  const { page = 1, perPage = 30 } = options;

  const [records, setRecords] = useState<Record<string, unknown>[]>([]);
  const [totalItems, setTotalItems] = useState(0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchRecords = useCallback(async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams({
        page: String(page),
        perPage: String(perPage),
      });
      const response = await fetchWithAuth(
        `/api/collections/${collectionName}/records?${params}`
      );
      const data: RecordsResponse = await response.json();
      setRecords(data.items);
      setTotalItems(data.totalItems);
      setError(null);
    } catch (e) {
      setError((e as Error).message);
      setRecords([]);
      setTotalItems(0);
    } finally {
      setLoading(false);
    }
  }, [collectionName, page, perPage]);

  useEffect(() => {
    fetchRecords();
  }, [fetchRecords]);

  return { records, totalItems, loading, error, refetch: fetchRecords };
}
```
  </action>
  <verify>
    - `grep "/_/api/collections/:name/fields" src/api/server.ts` shows the route
    - `ls src/admin/hooks/` shows useRecords.ts, useCollectionFields.ts
    - `bun run typecheck` passes
  </verify>
  <done>
    Fields API endpoint and data fetching hooks created
  </done>
</task>

<task type="auto">
  <name>Task 2: Create records table with TanStack Table</name>
  <files>
    - src/admin/components/records/RecordsTable.tsx
  </files>
  <action>
**Create src/admin/components/records/RecordsTable.tsx**:

Use TanStack Table with dynamic columns based on collection fields:

```typescript
import { useMemo } from "react";
import {
  useReactTable,
  getCoreRowModel,
  flexRender,
  ColumnDef,
} from "@tanstack/react-table";
import { MoreHorizontal, Pencil, Trash2 } from "lucide-react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Skeleton } from "@/components/ui/skeleton";
import type { Field } from "@/hooks/useCollectionFields";

interface RecordsTableProps {
  records: Record<string, unknown>[];
  fields: Field[];
  loading: boolean;
  onEdit: (record: Record<string, unknown>) => void;
  onDelete: (record: Record<string, unknown>) => void;
  onRowClick: (record: Record<string, unknown>) => void;
}

export function RecordsTable({
  records,
  fields,
  loading,
  onEdit,
  onDelete,
  onRowClick,
}: RecordsTableProps) {
  // Build columns from fields + system fields + actions
  const columns = useMemo<ColumnDef<Record<string, unknown>>[]>(() => {
    const cols: ColumnDef<Record<string, unknown>>[] = [
      // ID column (always first)
      {
        accessorKey: "id",
        header: "ID",
        cell: ({ row }) => (
          <span className="font-mono text-xs">
            {String(row.getValue("id")).slice(0, 8)}...
          </span>
        ),
      },
      // Dynamic field columns
      ...fields.map((field) => ({
        accessorKey: field.name,
        header: field.name,
        cell: ({ row }) => {
          const value = row.getValue(field.name);
          return formatCellValue(value, field.type);
        },
      })),
      // Created at
      {
        accessorKey: "created_at",
        header: "Created",
        cell: ({ row }) => {
          const date = new Date(row.getValue("created_at") as string);
          return date.toLocaleDateString();
        },
      },
      // Actions column
      {
        id: "actions",
        header: "",
        cell: ({ row }) => (
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                variant="ghost"
                size="sm"
                className="h-8 w-8 p-0"
                onClick={(e) => e.stopPropagation()}
              >
                <MoreHorizontal className="h-4 w-4" />
                <span className="sr-only">Open menu</span>
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem onClick={() => onEdit(row.original)}>
                <Pencil className="mr-2 h-4 w-4" />
                Edit
              </DropdownMenuItem>
              <DropdownMenuItem
                onClick={() => onDelete(row.original)}
                className="text-destructive focus:text-destructive"
              >
                <Trash2 className="mr-2 h-4 w-4" />
                Delete
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        ),
      },
    ];
    return cols;
  }, [fields, onEdit, onDelete]);

  const table = useReactTable({
    data: records,
    columns,
    getCoreRowModel: getCoreRowModel(),
  });

  if (loading) {
    return (
      <div className="space-y-2">
        {[1, 2, 3, 4, 5].map((i) => (
          <Skeleton key={i} className="h-12 w-full" />
        ))}
      </div>
    );
  }

  if (records.length === 0) {
    return (
      <div className="text-center py-12 border rounded-lg bg-muted/50">
        <p className="text-muted-foreground">No records found</p>
      </div>
    );
  }

  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          {table.getHeaderGroups().map((headerGroup) => (
            <TableRow key={headerGroup.id}>
              {headerGroup.headers.map((header) => (
                <TableHead key={header.id}>
                  {header.isPlaceholder
                    ? null
                    : flexRender(
                        header.column.columnDef.header,
                        header.getContext()
                      )}
                </TableHead>
              ))}
            </TableRow>
          ))}
        </TableHeader>
        <TableBody>
          {table.getRowModel().rows.map((row) => (
            <TableRow
              key={row.id}
              className="cursor-pointer"
              onClick={() => onRowClick(row.original)}
            >
              {row.getVisibleCells().map((cell) => (
                <TableCell key={cell.id}>
                  {flexRender(cell.column.columnDef.cell, cell.getContext())}
                </TableCell>
              ))}
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}

// Helper to format cell values based on field type
function formatCellValue(value: unknown, type: string): React.ReactNode {
  if (value === null || value === undefined) {
    return <span className="text-muted-foreground">-</span>;
  }

  switch (type) {
    case "boolean":
      return value ? "Yes" : "No";
    case "datetime":
      return new Date(value as string).toLocaleString();
    case "json":
      return (
        <span className="font-mono text-xs max-w-[200px] truncate block">
          {JSON.stringify(value)}
        </span>
      );
    case "relation":
      return (
        <span className="font-mono text-xs">
          {String(value).slice(0, 8)}...
        </span>
      );
    default:
      return String(value);
  }
}
```
  </action>
  <verify>
    - `cat src/admin/components/records/RecordsTable.tsx` shows TanStack Table implementation
    - `grep "useReactTable" src/admin/components/records/RecordsTable.tsx` confirms library usage
    - `bun run typecheck` passes
  </verify>
  <done>
    RecordsTable component created with dynamic columns and row actions
  </done>
</task>

<task type="auto">
  <name>Task 3: Create RecordsView and integrate into App</name>
  <files>
    - src/admin/components/records/RecordsView.tsx
    - src/admin/App.tsx
  </files>
  <action>
**Create src/admin/components/records/RecordsView.tsx**:

```typescript
import { useState } from "react";
import { Plus, ChevronLeft, ChevronRight } from "lucide-react";
import { RecordsTable } from "./RecordsTable";
import { useRecords } from "@/hooks/useRecords";
import { useCollectionFields } from "@/hooks/useCollectionFields";
import { Button } from "@/components/ui/button";

interface RecordsViewProps {
  collection: string;
  onCreateRecord: () => void;
  onEditRecord: (record: Record<string, unknown>) => void;
  onDeleteRecord: (record: Record<string, unknown>) => void;
}

export function RecordsView({
  collection,
  onCreateRecord,
  onEditRecord,
  onDeleteRecord,
}: RecordsViewProps) {
  const [page, setPage] = useState(1);
  const perPage = 30;

  const { records, totalItems, loading, error, refetch } = useRecords(collection, {
    page,
    perPage,
  });
  const { fields, loading: fieldsLoading } = useCollectionFields(collection);

  const totalPages = Math.ceil(totalItems / perPage);

  if (error) {
    return (
      <div className="text-center py-12">
        <p className="text-destructive">Error: {error}</p>
        <Button onClick={refetch} variant="outline" className="mt-4">
          Retry
        </Button>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Header with create button */}
      <div className="flex items-center justify-between">
        <div className="text-sm text-muted-foreground">
          {loading ? (
            "Loading..."
          ) : (
            <>
              {totalItems} record{totalItems !== 1 ? "s" : ""}
            </>
          )}
        </div>
        <Button onClick={onCreateRecord}>
          <Plus className="mr-2 h-4 w-4" />
          New Record
        </Button>
      </div>

      {/* Records table */}
      <RecordsTable
        records={records}
        fields={fields}
        loading={loading || fieldsLoading}
        onEdit={onEditRecord}
        onDelete={onDeleteRecord}
        onRowClick={onEditRecord}
      />

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex items-center justify-between">
          <div className="text-sm text-muted-foreground">
            Page {page} of {totalPages}
          </div>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setPage((p) => Math.max(1, p - 1))}
              disabled={page <= 1 || loading}
            >
              <ChevronLeft className="h-4 w-4" />
              Previous
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
              disabled={page >= totalPages || loading}
            >
              Next
              <ChevronRight className="h-4 w-4" />
            </Button>
          </div>
        </div>
      )}
    </div>
  );
}
```

**Update src/admin/App.tsx**:

1. Remove CollectionPlaceholder import and file
2. Add imports:
   ```typescript
   import { RecordsView } from "@/components/records/RecordsView";
   import { toast } from "sonner";
   ```

3. Add state for record operations (placeholders for now):
   ```typescript
   const handleCreateRecord = () => {
     toast.info("Create record form coming in next plan");
   };

   const handleEditRecord = (record: Record<string, unknown>) => {
     toast.info(`Edit record ${record.id} - coming in next plan`);
   };

   const handleDeleteRecord = (record: Record<string, unknown>) => {
     toast.info(`Delete record ${record.id} - coming in next plan`);
   };
   ```

4. Replace CollectionPlaceholder with:
   ```tsx
   {view.type === "collection" && (
     <RecordsView
       collection={view.collection}
       onCreateRecord={handleCreateRecord}
       onEditRecord={handleEditRecord}
       onDeleteRecord={handleDeleteRecord}
     />
   )}
   ```

Delete the placeholder file:
- `rm src/admin/components/views/CollectionPlaceholder.tsx`
  </action>
  <verify>
    - `cat src/admin/components/records/RecordsView.tsx` shows pagination controls
    - `grep "RecordsView" src/admin/App.tsx` shows import and usage
    - `bun run typecheck` passes
    - Start server and test:
      - Navigate to a collection
      - Table shows records with all columns
      - Pagination works (if > 30 records)
      - Row actions menu appears
  </verify>
  <done>
    RecordsView with table and pagination integrated into App (UI-02)
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck` - No TypeScript errors
2. Start server: `JWT_SECRET=test bun run src/api/server.ts`
3. Create test data:
   ```bash
   # Create collection with fields
   # Add some test records
   ```
4. Browser at http://localhost:8090/_/:
   - Login and navigate to a collection
   - Records table displays with columns for each field
   - ID shown truncated with monospace font
   - Created date formatted
   - Pagination controls at bottom
   - "New Record" button visible
   - Row actions dropdown has Edit/Delete options
   - Click row triggers edit (shows toast for now)
   - Empty collection shows "No records found"
</verification>

<success_criteria>
- Records table displays collection records (UI-02)
- Dynamic columns based on collection fields
- System fields (id, created_at) displayed
- Pagination controls navigate between pages
- Row actions dropdown with Edit/Delete
- Click row opens edit (placeholder for now)
- Loading skeleton during fetch
- Error state handled
- Empty state handled
</success_criteria>

<output>
After completion, create `.planning/phases/06-admin-ui-records/06-04-SUMMARY.md`
</output>
