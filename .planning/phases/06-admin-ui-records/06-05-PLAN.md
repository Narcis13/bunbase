---
phase: 06-admin-ui-records
plan: 05
type: execute
wave: 4
depends_on: ["06-04"]
files_modified:
  - src/admin/components/records/RecordForm.tsx
  - src/admin/components/records/RecordSheet.tsx
  - src/admin/components/records/DeleteConfirmation.tsx
  - src/admin/components/records/DynamicField.tsx
  - src/admin/components/records/RecordsView.tsx
  - src/admin/App.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can create a new record via form"
    - "Admin can edit an existing record via form"
    - "Admin can delete a record with confirmation dialog"
    - "Form inputs are generated based on field types"
  artifacts:
    - path: "src/admin/components/records/RecordForm.tsx"
      provides: "Form component with react-hook-form"
      min_lines: 80
    - path: "src/admin/components/records/RecordSheet.tsx"
      provides: "Slide-over panel containing form"
      min_lines: 40
    - path: "src/admin/components/records/DeleteConfirmation.tsx"
      provides: "Alert dialog for delete confirmation"
      min_lines: 30
    - path: "src/admin/components/records/DynamicField.tsx"
      provides: "Field renderer based on type"
      min_lines: 60
  key_links:
    - from: "src/admin/components/records/RecordForm.tsx"
      to: "react-hook-form"
      via: "useForm hook"
      pattern: "useForm"
    - from: "src/admin/components/records/RecordSheet.tsx"
      to: "src/admin/components/ui/sheet.tsx"
      via: "Sheet component"
      pattern: "import.*Sheet"
    - from: "src/admin/components/records/DeleteConfirmation.tsx"
      to: "src/admin/components/ui/alert-dialog.tsx"
      via: "AlertDialog component"
      pattern: "import.*AlertDialog"
---

<objective>
Create record forms for create, edit, and delete operations with auto-generated inputs

Purpose: Enable full CRUD on records through the admin UI (UI-03, UI-04, UI-05, UI-09)
Output: Slide-over forms with dynamic fields and delete confirmation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-admin-ui-records/06-CONTEXT.md
@.planning/phases/06-admin-ui-records/06-RESEARCH.md
@src/admin/components/records/RecordsView.tsx
@src/admin/hooks/useCollectionFields.ts
@src/core/validation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DynamicField component for form inputs</name>
  <files>
    - src/admin/components/records/DynamicField.tsx
  </files>
  <action>
**Create src/admin/components/records/DynamicField.tsx**:

Render form fields based on field type as described in RESEARCH.md:

```typescript
import { Controller, Control, FieldErrors } from "react-hook-form";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Textarea } from "@/components/ui/textarea";
import type { Field } from "@/hooks/useCollectionFields";

interface DynamicFieldProps {
  field: Field;
  control: Control<Record<string, unknown>>;
  errors: FieldErrors<Record<string, unknown>>;
}

export function DynamicField({ field, control, errors }: DynamicFieldProps) {
  const error = errors[field.name];

  return (
    <div className="space-y-2">
      <Label htmlFor={field.name} className="flex items-center gap-1">
        {field.name}
        {field.required && <span className="text-destructive">*</span>}
      </Label>

      <Controller
        name={field.name}
        control={control}
        rules={{
          required: field.required ? `${field.name} is required` : false,
        }}
        render={({ field: formField }) => {
          switch (field.type) {
            case "text":
              return (
                <Input
                  id={field.name}
                  {...formField}
                  value={formField.value as string ?? ""}
                  placeholder={`Enter ${field.name}`}
                />
              );

            case "number":
              return (
                <Input
                  id={field.name}
                  type="number"
                  step="any"
                  {...formField}
                  value={formField.value as number ?? ""}
                  onChange={(e) => {
                    const val = e.target.value;
                    formField.onChange(val === "" ? null : Number(val));
                  }}
                  placeholder={`Enter ${field.name}`}
                />
              );

            case "boolean":
              return (
                <div className="flex items-center gap-2">
                  <Switch
                    id={field.name}
                    checked={!!formField.value}
                    onCheckedChange={formField.onChange}
                  />
                  <span className="text-sm text-muted-foreground">
                    {formField.value ? "Yes" : "No"}
                  </span>
                </div>
              );

            case "datetime":
              return (
                <Input
                  id={field.name}
                  type="datetime-local"
                  {...formField}
                  value={formatDateForInput(formField.value as string)}
                  onChange={(e) => {
                    const val = e.target.value;
                    formField.onChange(val ? new Date(val).toISOString() : null);
                  }}
                />
              );

            case "json":
              return (
                <Textarea
                  id={field.name}
                  {...formField}
                  value={
                    typeof formField.value === "string"
                      ? formField.value
                      : JSON.stringify(formField.value, null, 2) ?? ""
                  }
                  onChange={(e) => {
                    try {
                      const parsed = JSON.parse(e.target.value);
                      formField.onChange(parsed);
                    } catch {
                      // Keep as string if invalid JSON
                      formField.onChange(e.target.value);
                    }
                  }}
                  placeholder="Enter JSON"
                  className="font-mono text-sm min-h-[100px]"
                />
              );

            case "relation":
              return (
                <Input
                  id={field.name}
                  {...formField}
                  value={formField.value as string ?? ""}
                  placeholder={`Enter ${field.options?.target || "record"} ID`}
                  className="font-mono"
                />
              );

            default:
              return (
                <Input
                  id={field.name}
                  {...formField}
                  value={formField.value as string ?? ""}
                />
              );
          }
        }}
      />

      {error && (
        <p className="text-sm text-destructive">{error.message as string}</p>
      )}

      {field.type === "relation" && field.options?.target && (
        <p className="text-xs text-muted-foreground">
          References: {field.options.target}
        </p>
      )}
    </div>
  );
}

// Helper to format ISO date for datetime-local input
function formatDateForInput(isoString: string | null | undefined): string {
  if (!isoString) return "";
  try {
    const date = new Date(isoString);
    // Format: YYYY-MM-DDTHH:mm
    return date.toISOString().slice(0, 16);
  } catch {
    return "";
  }
}
```
  </action>
  <verify>
    - `cat src/admin/components/records/DynamicField.tsx` shows field type switch
    - All 6 field types handled (text, number, boolean, datetime, json, relation)
    - `bun run typecheck` passes
  </verify>
  <done>
    DynamicField component created with inputs for all field types (UI-09)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RecordForm and RecordSheet components</name>
  <files>
    - src/admin/components/records/RecordForm.tsx
    - src/admin/components/records/RecordSheet.tsx
    - src/admin/components/records/DeleteConfirmation.tsx
  </files>
  <action>
**Create src/admin/components/records/RecordForm.tsx**:

```typescript
import { useForm } from "react-hook-form";
import { useEffect } from "react";
import { Button } from "@/components/ui/button";
import { DynamicField } from "./DynamicField";
import type { Field } from "@/hooks/useCollectionFields";

interface RecordFormProps {
  fields: Field[];
  record?: Record<string, unknown> | null;
  onSubmit: (data: Record<string, unknown>) => Promise<void>;
  onCancel: () => void;
  loading?: boolean;
}

export function RecordForm({
  fields,
  record,
  onSubmit,
  onCancel,
  loading,
}: RecordFormProps) {
  const isEditing = !!record;

  const {
    control,
    handleSubmit,
    reset,
    formState: { errors, isSubmitting },
  } = useForm<Record<string, unknown>>({
    defaultValues: record || {},
  });

  // Reset form when record changes (important for edit mode)
  useEffect(() => {
    reset(record || {});
  }, [record, reset]);

  const handleFormSubmit = async (data: Record<string, unknown>) => {
    // Only include non-null values for create
    // For edit, include all values to allow clearing
    const cleanedData = Object.fromEntries(
      Object.entries(data).filter(([_, v]) => v !== undefined)
    );
    await onSubmit(cleanedData);
  };

  return (
    <form onSubmit={handleSubmit(handleFormSubmit)} className="space-y-6">
      <div className="space-y-4">
        {fields.map((field) => (
          <DynamicField
            key={field.id}
            field={field}
            control={control}
            errors={errors}
          />
        ))}
      </div>

      {fields.length === 0 && (
        <p className="text-sm text-muted-foreground py-4">
          This collection has no fields defined.
        </p>
      )}

      <div className="flex justify-end gap-2 pt-4 border-t">
        <Button
          type="button"
          variant="outline"
          onClick={onCancel}
          disabled={isSubmitting || loading}
        >
          Cancel
        </Button>
        <Button type="submit" disabled={isSubmitting || loading}>
          {isSubmitting || loading
            ? "Saving..."
            : isEditing
            ? "Update Record"
            : "Create Record"}
        </Button>
      </div>
    </form>
  );
}
```

**Create src/admin/components/records/RecordSheet.tsx**:

```typescript
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { RecordForm } from "./RecordForm";
import { Skeleton } from "@/components/ui/skeleton";
import type { Field } from "@/hooks/useCollectionFields";

interface RecordSheetProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  collection: string;
  fields: Field[];
  fieldsLoading: boolean;
  record?: Record<string, unknown> | null;
  onSubmit: (data: Record<string, unknown>) => Promise<void>;
  loading?: boolean;
}

export function RecordSheet({
  open,
  onOpenChange,
  collection,
  fields,
  fieldsLoading,
  record,
  onSubmit,
  loading,
}: RecordSheetProps) {
  const isEditing = !!record;

  const handleSubmit = async (data: Record<string, unknown>) => {
    await onSubmit(data);
    onOpenChange(false);
  };

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent className="w-[400px] sm:w-[540px] overflow-y-auto">
        <SheetHeader>
          <SheetTitle>
            {isEditing ? "Edit Record" : "Create Record"}
          </SheetTitle>
          <SheetDescription>
            {isEditing
              ? `Editing record in ${collection}`
              : `Add a new record to ${collection}`}
          </SheetDescription>
        </SheetHeader>

        <div className="mt-6">
          {fieldsLoading ? (
            <div className="space-y-4">
              {[1, 2, 3].map((i) => (
                <div key={i} className="space-y-2">
                  <Skeleton className="h-4 w-24" />
                  <Skeleton className="h-10 w-full" />
                </div>
              ))}
            </div>
          ) : (
            <RecordForm
              fields={fields}
              record={record}
              onSubmit={handleSubmit}
              onCancel={() => onOpenChange(false)}
              loading={loading}
            />
          )}
        </div>
      </SheetContent>
    </Sheet>
  );
}
```

**Create src/admin/components/records/DeleteConfirmation.tsx**:

```typescript
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

interface DeleteConfirmationProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onConfirm: () => void;
  recordId: string;
  loading?: boolean;
}

export function DeleteConfirmation({
  open,
  onOpenChange,
  onConfirm,
  recordId,
  loading,
}: DeleteConfirmationProps) {
  return (
    <AlertDialog open={open} onOpenChange={onOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Delete Record?</AlertDialogTitle>
          <AlertDialogDescription>
            This action cannot be undone. This will permanently delete the
            record with ID{" "}
            <code className="font-mono text-sm bg-muted px-1 rounded">
              {recordId}
            </code>
            .
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel disabled={loading}>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={onConfirm}
            disabled={loading}
            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
          >
            {loading ? "Deleting..." : "Delete"}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
```
  </action>
  <verify>
    - `ls src/admin/components/records/` shows RecordForm.tsx, RecordSheet.tsx, DeleteConfirmation.tsx
    - `grep "Sheet" src/admin/components/records/RecordSheet.tsx` confirms Sheet usage
    - `grep "AlertDialog" src/admin/components/records/DeleteConfirmation.tsx` confirms AlertDialog usage
    - `bun run typecheck` passes
  </verify>
  <done>
    RecordForm, RecordSheet, and DeleteConfirmation components created
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate forms into RecordsView and App</name>
  <files>
    - src/admin/components/records/RecordsView.tsx
    - src/admin/App.tsx
  </files>
  <action>
**Update src/admin/components/records/RecordsView.tsx**:

Add sheet and dialog state, wire up the CRUD operations:

```typescript
import { useState } from "react";
import { Plus, ChevronLeft, ChevronRight } from "lucide-react";
import { toast } from "sonner";
import { RecordsTable } from "./RecordsTable";
import { RecordSheet } from "./RecordSheet";
import { DeleteConfirmation } from "./DeleteConfirmation";
import { useRecords } from "@/hooks/useRecords";
import { useCollectionFields } from "@/hooks/useCollectionFields";
import { fetchWithAuth } from "@/lib/api";
import { Button } from "@/components/ui/button";

interface RecordsViewProps {
  collection: string;
}

export function RecordsView({ collection }: RecordsViewProps) {
  const [page, setPage] = useState(1);
  const perPage = 30;

  const { records, totalItems, loading, error, refetch } = useRecords(collection, {
    page,
    perPage,
  });
  const { fields, loading: fieldsLoading } = useCollectionFields(collection);

  // Sheet state
  const [sheetOpen, setSheetOpen] = useState(false);
  const [editingRecord, setEditingRecord] = useState<Record<string, unknown> | null>(null);
  const [saving, setSaving] = useState(false);

  // Delete dialog state
  const [deleteOpen, setDeleteOpen] = useState(false);
  const [deletingRecord, setDeletingRecord] = useState<Record<string, unknown> | null>(null);
  const [deleting, setDeleting] = useState(false);

  const totalPages = Math.ceil(totalItems / perPage);

  // Handle create
  const handleCreate = () => {
    setEditingRecord(null);
    setSheetOpen(true);
  };

  // Handle edit
  const handleEdit = (record: Record<string, unknown>) => {
    setEditingRecord(record);
    setSheetOpen(true);
  };

  // Handle delete click
  const handleDeleteClick = (record: Record<string, unknown>) => {
    setDeletingRecord(record);
    setDeleteOpen(true);
  };

  // Submit create/edit
  const handleSubmit = async (data: Record<string, unknown>) => {
    setSaving(true);
    try {
      if (editingRecord) {
        // Update existing record
        await fetchWithAuth(`/api/collections/${collection}/records/${editingRecord.id}`, {
          method: "PATCH",
          body: JSON.stringify(data),
        });
        toast.success("Record updated successfully");
      } else {
        // Create new record
        await fetchWithAuth(`/api/collections/${collection}/records`, {
          method: "POST",
          body: JSON.stringify(data),
        });
        toast.success("Record created successfully");
      }
      setSheetOpen(false);
      refetch();
    } catch (e) {
      toast.error((e as Error).message);
    } finally {
      setSaving(false);
    }
  };

  // Confirm delete
  const handleDeleteConfirm = async () => {
    if (!deletingRecord) return;

    setDeleting(true);
    try {
      await fetchWithAuth(`/api/collections/${collection}/records/${deletingRecord.id}`, {
        method: "DELETE",
      });
      toast.success("Record deleted successfully");
      setDeleteOpen(false);
      setDeletingRecord(null);
      refetch();
    } catch (e) {
      toast.error((e as Error).message);
    } finally {
      setDeleting(false);
    }
  };

  if (error) {
    return (
      <div className="text-center py-12">
        <p className="text-destructive">Error: {error}</p>
        <Button onClick={refetch} variant="outline" className="mt-4">
          Retry
        </Button>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Header with create button */}
      <div className="flex items-center justify-between">
        <div className="text-sm text-muted-foreground">
          {loading ? (
            "Loading..."
          ) : (
            <>
              {totalItems} record{totalItems !== 1 ? "s" : ""}
            </>
          )}
        </div>
        <Button onClick={handleCreate}>
          <Plus className="mr-2 h-4 w-4" />
          New Record
        </Button>
      </div>

      {/* Records table */}
      <RecordsTable
        records={records}
        fields={fields}
        loading={loading || fieldsLoading}
        onEdit={handleEdit}
        onDelete={handleDeleteClick}
        onRowClick={handleEdit}
      />

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex items-center justify-between">
          <div className="text-sm text-muted-foreground">
            Page {page} of {totalPages}
          </div>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setPage((p) => Math.max(1, p - 1))}
              disabled={page <= 1 || loading}
            >
              <ChevronLeft className="h-4 w-4" />
              Previous
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
              disabled={page >= totalPages || loading}
            >
              Next
              <ChevronRight className="h-4 w-4" />
            </Button>
          </div>
        </div>
      )}

      {/* Record form sheet */}
      <RecordSheet
        open={sheetOpen}
        onOpenChange={setSheetOpen}
        collection={collection}
        fields={fields}
        fieldsLoading={fieldsLoading}
        record={editingRecord}
        onSubmit={handleSubmit}
        loading={saving}
      />

      {/* Delete confirmation */}
      <DeleteConfirmation
        open={deleteOpen}
        onOpenChange={setDeleteOpen}
        onConfirm={handleDeleteConfirm}
        recordId={deletingRecord?.id as string ?? ""}
        loading={deleting}
      />
    </div>
  );
}
```

**Update src/admin/App.tsx**:

Simplify the props passed to RecordsView since it now handles everything internally:

1. Remove the handler functions (handleCreateRecord, handleEditRecord, handleDeleteRecord)
2. Simplify RecordsView usage:
   ```tsx
   {view.type === "collection" && (
     <RecordsView collection={view.collection} />
   )}
   ```
3. Remove the toast import if no longer needed at App level
  </action>
  <verify>
    - `grep "RecordSheet" src/admin/components/records/RecordsView.tsx` shows sheet integration
    - `grep "DeleteConfirmation" src/admin/components/records/RecordsView.tsx` shows dialog integration
    - `bun run typecheck` passes
    - Start server and test full CRUD flow:
      - Click "New Record" -> Sheet opens with form
      - Fill form and submit -> Record created, toast shown
      - Click record row -> Sheet opens with data populated
      - Edit and submit -> Record updated
      - Click delete in row menu -> Confirmation dialog appears
      - Confirm delete -> Record deleted, toast shown
  </verify>
  <done>
    Full CRUD forms integrated into RecordsView (UI-03, UI-04, UI-05)
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck` - No TypeScript errors
2. Start server: `JWT_SECRET=test bun run src/api/server.ts`
3. Create a test collection with various field types
4. Browser CRUD testing:
   - **Create (UI-03):**
     - Click "New Record" button
     - Form slides in from right
     - All field types render correct inputs
     - Submit creates record, shows success toast
   - **Edit (UI-04):**
     - Click table row or Edit in menu
     - Form populates with existing values
     - Changes persist on submit
   - **Delete (UI-05):**
     - Click Delete in row menu
     - Confirmation dialog appears
     - Confirm deletes record
   - **Field Types (UI-09):**
     - text: Standard text input
     - number: Numeric input with step=any
     - boolean: Toggle switch
     - datetime: Date/time picker
     - json: Textarea with JSON
     - relation: Text input for ID
</verification>

<success_criteria>
- Create record via slide-over form (UI-03)
- Edit record via slide-over form (UI-04)
- Delete record with confirmation dialog (UI-05)
- Form inputs generated based on field types (UI-09)
- Success/error toasts for all operations
- Form validation for required fields
- Loading states during save/delete
- Sheet closes on success
- Table refreshes after CRUD operations
</success_criteria>

<output>
After completion, create `.planning/phases/06-admin-ui-records/06-05-SUMMARY.md`
</output>
