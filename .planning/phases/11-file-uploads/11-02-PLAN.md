---
phase: 11-file-uploads
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/files.ts
  - src/storage/files.test.ts
autonomous: true

must_haves:
  truths:
    - "Files can be saved to {data_dir}/storage/{collection}/{record}/"
    - "Files can be deleted individually or by record"
    - "Storage directory is created automatically if missing"
  artifacts:
    - path: "src/storage/files.ts"
      provides: "File storage operations"
      exports: ["getStorageDir", "getRecordStoragePath", "ensureRecordStorageDir", "saveFile", "deleteFile", "deleteRecordFiles", "listRecordFiles"]
    - path: "src/storage/files.test.ts"
      provides: "Storage operation tests"
      min_lines: 50
  key_links:
    - from: "src/storage/files.ts"
      to: "Bun.write"
      via: "file saving"
      pattern: "Bun\\.write"
    - from: "src/storage/files.ts"
      to: "node:fs/promises"
      via: "directory operations"
      pattern: "from \"node:fs/promises\""
---

<objective>
Implement file storage operations for saving, reading, and deleting files.

Purpose: FILE-03 requires local filesystem storage in `{data_dir}/storage/{collection}/{record}/`. This plan creates the storage module that handles all file I/O operations using Bun's native APIs.

Output: Storage module with functions for saving files, deleting files, listing files, and managing storage directories.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-file-uploads/11-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement file storage operations</name>
  <files>src/storage/files.ts</files>
  <action>
Create the file storage module with Bun native APIs.

**src/storage/files.ts:**
```typescript
import { mkdir, rm, readdir } from "node:fs/promises";
import path from "path";
import { sanitizeFilename } from "./sanitize";

/** Default storage directory relative to cwd */
const DEFAULT_STORAGE_DIR = "./data/storage";

/**
 * Get the base storage directory.
 * Can be overridden via BUNBASE_STORAGE_DIR environment variable.
 */
export function getStorageDir(): string {
  return process.env.BUNBASE_STORAGE_DIR ?? DEFAULT_STORAGE_DIR;
}

/**
 * Get path to a record's file storage directory.
 * Structure: {storageDir}/{collectionName}/{recordId}/
 */
export function getRecordStoragePath(
  collectionName: string,
  recordId: string
): string {
  return path.join(getStorageDir(), collectionName, recordId);
}

/**
 * Get path to a specific file.
 */
export function getFilePath(
  collectionName: string,
  recordId: string,
  filename: string
): string {
  return path.join(getRecordStoragePath(collectionName, recordId), filename);
}

/**
 * Ensure the storage directory exists for a record.
 * Creates parent directories recursively if needed.
 *
 * @returns The created directory path
 */
export async function ensureRecordStorageDir(
  collectionName: string,
  recordId: string
): Promise<string> {
  const dir = getRecordStoragePath(collectionName, recordId);
  await mkdir(dir, { recursive: true });
  return dir;
}

/**
 * Save a file to storage and return the stored filename.
 * The filename is sanitized and given a unique suffix.
 *
 * @param collectionName - Collection the record belongs to
 * @param recordId - ID of the record
 * @param file - File object from FormData
 * @returns The sanitized filename used for storage
 */
export async function saveFile(
  collectionName: string,
  recordId: string,
  file: File
): Promise<string> {
  const dir = await ensureRecordStorageDir(collectionName, recordId);
  const filename = sanitizeFilename(file.name);
  const filePath = path.join(dir, filename);

  // Bun.write handles File/Blob directly with zero-copy optimization
  await Bun.write(filePath, file);

  return filename;
}

/**
 * Delete a specific file from storage.
 * Does not throw if file doesn't exist (idempotent).
 */
export async function deleteFile(
  collectionName: string,
  recordId: string,
  filename: string
): Promise<void> {
  const filePath = getFilePath(collectionName, recordId, filename);
  await rm(filePath, { force: true });
}

/**
 * Delete all files for a record (removes the entire record directory).
 * Does not throw if directory doesn't exist (idempotent).
 */
export async function deleteRecordFiles(
  collectionName: string,
  recordId: string
): Promise<void> {
  const dir = getRecordStoragePath(collectionName, recordId);
  await rm(dir, { recursive: true, force: true });
}

/**
 * List all files stored for a record.
 * Returns empty array if directory doesn't exist.
 */
export async function listRecordFiles(
  collectionName: string,
  recordId: string
): Promise<string[]> {
  const dir = getRecordStoragePath(collectionName, recordId);
  try {
    return await readdir(dir);
  } catch {
    // Directory doesn't exist - return empty array
    return [];
  }
}

/**
 * Check if a file exists in storage.
 */
export async function fileExists(
  collectionName: string,
  recordId: string,
  filename: string
): Promise<boolean> {
  const filePath = getFilePath(collectionName, recordId, filename);
  const file = Bun.file(filePath);
  return file.exists();
}
```
  </action>
  <verify>Run `bun build src/storage/files.ts` - no TypeScript errors</verify>
  <done>All storage functions exported: getStorageDir, getRecordStoragePath, getFilePath, ensureRecordStorageDir, saveFile, deleteFile, deleteRecordFiles, listRecordFiles, fileExists</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for file storage operations</name>
  <files>src/storage/files.test.ts</files>
  <action>
Create comprehensive tests for file storage.

**src/storage/files.test.ts:**
```typescript
import { test, expect, describe, beforeEach, afterEach } from "bun:test";
import { rm, mkdir, readdir } from "node:fs/promises";
import path from "path";
import {
  getStorageDir,
  getRecordStoragePath,
  getFilePath,
  ensureRecordStorageDir,
  saveFile,
  deleteFile,
  deleteRecordFiles,
  listRecordFiles,
  fileExists,
} from "./files";

// Use a test-specific storage directory
const TEST_STORAGE_DIR = "./test-storage";

describe("file storage", () => {
  beforeEach(async () => {
    // Set test storage directory
    process.env.BUNBASE_STORAGE_DIR = TEST_STORAGE_DIR;
    // Clean up before each test
    await rm(TEST_STORAGE_DIR, { recursive: true, force: true });
  });

  afterEach(async () => {
    // Clean up after each test
    await rm(TEST_STORAGE_DIR, { recursive: true, force: true });
    delete process.env.BUNBASE_STORAGE_DIR;
  });

  describe("getStorageDir", () => {
    test("returns env var when set", () => {
      process.env.BUNBASE_STORAGE_DIR = "/custom/path";
      expect(getStorageDir()).toBe("/custom/path");
      process.env.BUNBASE_STORAGE_DIR = TEST_STORAGE_DIR;
    });

    test("returns default when env var not set", () => {
      delete process.env.BUNBASE_STORAGE_DIR;
      expect(getStorageDir()).toBe("./data/storage");
      process.env.BUNBASE_STORAGE_DIR = TEST_STORAGE_DIR;
    });
  });

  describe("getRecordStoragePath", () => {
    test("builds correct path structure", () => {
      const result = getRecordStoragePath("posts", "abc123");
      expect(result).toBe(path.join(TEST_STORAGE_DIR, "posts", "abc123"));
    });
  });

  describe("getFilePath", () => {
    test("builds correct file path", () => {
      const result = getFilePath("posts", "abc123", "image.jpg");
      expect(result).toBe(path.join(TEST_STORAGE_DIR, "posts", "abc123", "image.jpg"));
    });
  });

  describe("ensureRecordStorageDir", () => {
    test("creates directory structure", async () => {
      const dir = await ensureRecordStorageDir("posts", "rec123");
      expect(dir).toBe(path.join(TEST_STORAGE_DIR, "posts", "rec123"));

      // Verify directory exists
      const entries = await readdir(path.join(TEST_STORAGE_DIR, "posts"));
      expect(entries).toContain("rec123");
    });

    test("is idempotent (calling twice doesn't error)", async () => {
      await ensureRecordStorageDir("posts", "rec123");
      await ensureRecordStorageDir("posts", "rec123"); // Should not throw
    });
  });

  describe("saveFile", () => {
    test("saves file and returns sanitized filename", async () => {
      const file = new File(["test content"], "My Photo.jpg", { type: "image/jpeg" });
      const filename = await saveFile("posts", "rec123", file);

      // Filename should be sanitized with random suffix
      expect(filename).toMatch(/^My_Photo_[a-zA-Z0-9_-]{10}\.jpg$/);

      // File should exist on disk
      const exists = await fileExists("posts", "rec123", filename);
      expect(exists).toBe(true);

      // File content should match
      const filePath = getFilePath("posts", "rec123", filename);
      const content = await Bun.file(filePath).text();
      expect(content).toBe("test content");
    });

    test("saves binary files correctly", async () => {
      const bytes = new Uint8Array([0x89, 0x50, 0x4E, 0x47]); // PNG magic bytes
      const file = new File([bytes], "image.png", { type: "image/png" });
      const filename = await saveFile("posts", "rec123", file);

      const filePath = getFilePath("posts", "rec123", filename);
      const savedBytes = new Uint8Array(await Bun.file(filePath).arrayBuffer());
      expect(savedBytes).toEqual(bytes);
    });
  });

  describe("deleteFile", () => {
    test("deletes existing file", async () => {
      const file = new File(["content"], "test.txt");
      const filename = await saveFile("posts", "rec123", file);

      expect(await fileExists("posts", "rec123", filename)).toBe(true);

      await deleteFile("posts", "rec123", filename);

      expect(await fileExists("posts", "rec123", filename)).toBe(false);
    });

    test("is idempotent (doesn't error on missing file)", async () => {
      await deleteFile("posts", "rec123", "nonexistent.txt"); // Should not throw
    });
  });

  describe("deleteRecordFiles", () => {
    test("deletes entire record directory", async () => {
      // Save multiple files
      const file1 = new File(["content1"], "file1.txt");
      const file2 = new File(["content2"], "file2.txt");
      await saveFile("posts", "rec123", file1);
      await saveFile("posts", "rec123", file2);

      // Verify files exist
      const filesBefore = await listRecordFiles("posts", "rec123");
      expect(filesBefore.length).toBe(2);

      // Delete all
      await deleteRecordFiles("posts", "rec123");

      // Verify directory is gone
      const filesAfter = await listRecordFiles("posts", "rec123");
      expect(filesAfter.length).toBe(0);
    });

    test("is idempotent (doesn't error on missing directory)", async () => {
      await deleteRecordFiles("posts", "nonexistent"); // Should not throw
    });
  });

  describe("listRecordFiles", () => {
    test("lists all files in record directory", async () => {
      const file1 = new File(["content1"], "a.txt");
      const file2 = new File(["content2"], "b.txt");
      const name1 = await saveFile("posts", "rec123", file1);
      const name2 = await saveFile("posts", "rec123", file2);

      const files = await listRecordFiles("posts", "rec123");
      expect(files).toContain(name1);
      expect(files).toContain(name2);
      expect(files.length).toBe(2);
    });

    test("returns empty array for non-existent directory", async () => {
      const files = await listRecordFiles("posts", "nonexistent");
      expect(files).toEqual([]);
    });
  });

  describe("fileExists", () => {
    test("returns true for existing file", async () => {
      const file = new File(["content"], "test.txt");
      const filename = await saveFile("posts", "rec123", file);

      expect(await fileExists("posts", "rec123", filename)).toBe(true);
    });

    test("returns false for non-existent file", async () => {
      expect(await fileExists("posts", "rec123", "nope.txt")).toBe(false);
    });
  });
});
```
  </action>
  <verify>Run `bun test src/storage/files.test.ts` - all tests pass</verify>
  <done>All storage tests pass: save, delete, list, exists operations work correctly</done>
</task>

</tasks>

<verification>
1. `bun build src/storage/files.ts` - no errors
2. `bun test src/storage/files.test.ts` - all tests pass
3. Manually test: files are created in ./test-storage/collection/record/filename.ext
</verification>

<success_criteria>
- saveFile creates directory structure and writes file
- saveFile uses sanitizeFilename for security
- deleteFile removes individual files idempotently
- deleteRecordFiles removes entire record directory
- listRecordFiles returns array of filenames (empty if none)
- fileExists correctly detects file presence
- BUNBASE_STORAGE_DIR environment variable override works
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-file-uploads/11-02-SUMMARY.md`
</output>
