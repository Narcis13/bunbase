---
phase: 11-file-uploads
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/collection.ts
  - src/storage/sanitize.ts
  - src/storage/sanitize.test.ts
autonomous: true

must_haves:
  truths:
    - "File field type is available in schema definitions"
    - "Filenames are sanitized to remove dangerous characters"
    - "Filenames have unique random suffix to prevent collisions"
  artifacts:
    - path: "src/types/collection.ts"
      provides: "File field type and FileFieldOptions"
      contains: "file"
    - path: "src/storage/sanitize.ts"
      provides: "Filename sanitization function"
      exports: ["sanitizeFilename"]
    - path: "src/storage/sanitize.test.ts"
      provides: "Sanitization tests"
      min_lines: 30
  key_links:
    - from: "src/storage/sanitize.ts"
      to: "nanoid"
      via: "import for random suffix"
      pattern: "import.*nanoid"
---

<objective>
Add file field type to collection schema and implement filename sanitization.

Purpose: FILE-01 (file field type) and FILE-05 (filename sanitization) are foundation requirements for file uploads. The file field type enables schema definitions with file attachments, while sanitization prevents path traversal attacks and filename collisions.

Output: Extended FieldType union with 'file', FileFieldOptions interface for file constraints (maxFiles, maxSize, allowedTypes), and sanitizeFilename function with tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-file-uploads/11-RESEARCH.md

@src/types/collection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add file field type and FileFieldOptions</name>
  <files>src/types/collection.ts</files>
  <action>
Extend the existing types file:

1. Add 'file' to the FieldType union:
```typescript
export type FieldType =
  | "text"
  | "number"
  | "boolean"
  | "datetime"
  | "json"
  | "relation"
  | "file";  // NEW
```

2. Add file-specific options to FieldOptions interface:
```typescript
export interface FieldOptions {
  // ... existing options ...
  /** For file fields: maximum number of files (default 1) */
  maxFiles?: number;
  /** For file fields: maximum file size in bytes (default 10MB = 10485760) */
  maxSize?: number;
  /** For file fields: allowed MIME types (e.g., ["image/jpeg", "image/png", "image/*"]) */
  allowedTypes?: string[];
}
```

3. Add file type mapping in FIELD_TYPE_MAP:
```typescript
export const FIELD_TYPE_MAP: Record<FieldType, string> = {
  // ... existing mappings ...
  file: "TEXT",  // JSON array of filenames
} as const;
```

Do NOT create a separate FileFieldOptions interface - reuse FieldOptions per existing pattern.
  </action>
  <verify>Run `bun build src/types/collection.ts` to verify no TypeScript errors</verify>
  <done>'file' appears in FieldType union, maxFiles/maxSize/allowedTypes in FieldOptions, file maps to TEXT in FIELD_TYPE_MAP</done>
</task>

<task type="auto">
  <name>Task 2: Implement filename sanitization with tests</name>
  <files>src/storage/sanitize.ts, src/storage/sanitize.test.ts</files>
  <action>
Create src/storage/ directory and sanitize module.

**src/storage/sanitize.ts:**
```typescript
import { nanoid } from "nanoid";
import path from "path";

/**
 * Sanitize a filename for safe storage.
 * - Removes path components (prevents traversal attacks)
 * - Removes dangerous characters
 * - Adds random suffix for uniqueness
 * - Preserves original extension (lowercase)
 *
 * @param originalName - The original filename from upload
 * @returns Sanitized filename with random suffix
 */
export function sanitizeFilename(originalName: string): string {
  // Get extension (lowercase)
  const ext = path.extname(originalName).toLowerCase();

  // Get base name only (removes any directory path - prevents traversal)
  let baseName = path.basename(originalName, path.extname(originalName));

  // Remove/replace dangerous characters
  // Keep: letters, numbers, underscore, hyphen
  baseName = baseName
    .replace(/[^a-zA-Z0-9_-]/g, '_')   // Replace dangerous chars with underscore
    .replace(/_+/g, '_')               // Collapse multiple underscores
    .replace(/^_+|_+$/g, '')           // Trim leading/trailing underscores
    .substring(0, 100);                // Limit base name length

  // Ensure we have a base name
  if (!baseName) {
    baseName = 'file';
  }

  // Add random suffix (10 chars like PocketBase)
  const suffix = nanoid(10);

  return `${baseName}_${suffix}${ext}`;
}
```

**src/storage/sanitize.test.ts:**
```typescript
import { test, expect, describe } from "bun:test";
import { sanitizeFilename } from "./sanitize";

describe("sanitizeFilename", () => {
  test("preserves extension in lowercase", () => {
    const result = sanitizeFilename("Photo.JPG");
    expect(result).toMatch(/^Photo_[a-zA-Z0-9_-]{10}\.jpg$/);
  });

  test("adds random suffix", () => {
    const result1 = sanitizeFilename("test.txt");
    const result2 = sanitizeFilename("test.txt");
    expect(result1).not.toBe(result2); // Random suffix makes them different
    expect(result1).toMatch(/_[a-zA-Z0-9_-]{10}\.txt$/);
  });

  test("removes path traversal attempts", () => {
    const result = sanitizeFilename("../../../etc/passwd");
    expect(result).not.toContain("..");
    expect(result).not.toContain("/");
    expect(result).toMatch(/^passwd_[a-zA-Z0-9_-]{10}$/);
  });

  test("removes dangerous characters", () => {
    const result = sanitizeFilename("my file<script>.pdf");
    expect(result).not.toContain("<");
    expect(result).not.toContain(">");
    expect(result).not.toContain(" ");
    expect(result).toMatch(/^my_file_script_[a-zA-Z0-9_-]{10}\.pdf$/);
  });

  test("handles files with multiple dots", () => {
    const result = sanitizeFilename("archive.tar.gz");
    expect(result).toMatch(/^archive_tar_[a-zA-Z0-9_-]{10}\.gz$/);
  });

  test("handles empty base name", () => {
    const result = sanitizeFilename(".gitignore");
    expect(result).toMatch(/^file_[a-zA-Z0-9_-]{10}$/);
  });

  test("handles files with only special chars", () => {
    const result = sanitizeFilename("...///...txt");
    expect(result).toMatch(/^file_[a-zA-Z0-9_-]{10}\.txt$/);
  });

  test("truncates very long filenames", () => {
    const longName = "a".repeat(200) + ".pdf";
    const result = sanitizeFilename(longName);
    // Base should be max 100 chars, plus _suffix(10) plus .pdf(4)
    expect(result.length).toBeLessThanOrEqual(100 + 1 + 10 + 4);
  });

  test("handles Windows path separators", () => {
    const result = sanitizeFilename("C:\\Users\\test\\file.doc");
    expect(result).not.toContain("\\");
    expect(result).toMatch(/^file_[a-zA-Z0-9_-]{10}\.doc$/);
  });

  test("preserves hyphens and underscores", () => {
    const result = sanitizeFilename("my-file_name.txt");
    expect(result).toMatch(/^my-file_name_[a-zA-Z0-9_-]{10}\.txt$/);
  });
});
```
  </action>
  <verify>Run `bun test src/storage/sanitize.test.ts` - all tests pass</verify>
  <done>sanitizeFilename function exists, removes path traversal, adds random suffix, all 10 tests pass</done>
</task>

</tasks>

<verification>
1. `bun build src/types/collection.ts` - no errors
2. `bun test src/storage/sanitize.test.ts` - all tests pass
3. Grep for "file" in FieldType shows it's included
</verification>

<success_criteria>
- FieldType includes 'file' option
- FieldOptions includes maxFiles, maxSize, allowedTypes
- FIELD_TYPE_MAP maps 'file' to TEXT
- sanitizeFilename removes path traversal (.., /, \)
- sanitizeFilename adds 10-char random suffix via nanoid
- sanitizeFilename preserves extension in lowercase
- All sanitization tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-file-uploads/11-01-SUMMARY.md`
</output>
