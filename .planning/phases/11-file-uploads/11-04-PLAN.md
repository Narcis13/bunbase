---
phase: 11-file-uploads
plan: 04
type: execute
wave: 2
depends_on: ["11-01", "11-02", "11-03"]
files_modified:
  - src/storage/multipart.ts
  - src/storage/multipart.test.ts
  - src/core/records.ts
  - src/api/server.ts
autonomous: true

must_haves:
  truths:
    - "Multipart form data requests are parsed into data and files"
    - "Records API POST accepts multipart uploads with file fields"
    - "Records API PATCH accepts multipart uploads for file updates"
    - "File validation errors return 400 with clear message"
  artifacts:
    - path: "src/storage/multipart.ts"
      provides: "Multipart request parsing"
      exports: ["parseMultipartRequest", "isMultipartRequest"]
    - path: "src/storage/multipart.test.ts"
      provides: "Multipart parser tests"
      min_lines: 50
    - path: "src/core/records.ts"
      provides: "File-aware record operations"
      contains: "createRecordWithFiles"
  key_links:
    - from: "src/api/server.ts"
      to: "src/storage/multipart.ts"
      via: "import for request parsing"
      pattern: "from.*storage/multipart"
    - from: "src/core/records.ts"
      to: "src/storage/files.ts"
      via: "import for file saving"
      pattern: "from.*storage/files"
---

<objective>
Integrate file uploads into the records API via multipart form data handling.

Purpose: FILE-02 requires multipart upload via records API (create and update). This plan adds multipart request parsing and integrates file handling into the existing record create/update workflow.

Output: Multipart parser with tests, file-aware record operations, and updated API endpoints that detect and handle file uploads.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-file-uploads/11-RESEARCH.md

@src/core/records.ts
@src/api/server.ts
@src/types/collection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multipart request parser with tests</name>
  <files>src/storage/multipart.ts, src/storage/multipart.test.ts</files>
  <action>
Create module for parsing multipart form data requests with comprehensive tests.

**src/storage/multipart.ts:**
```typescript
/**
 * Multipart form data parsing utilities.
 * Uses Bun's native Request.formData() for parsing.
 */

/**
 * Result of parsing a multipart request.
 */
export interface MultipartParseResult {
  /** Regular field data (non-file fields) */
  data: Record<string, unknown>;
  /** File fields mapped to arrays of File objects */
  files: Map<string, File[]>;
}

/**
 * Check if a request contains multipart form data.
 *
 * @param req - The incoming request
 * @returns True if the request is multipart/form-data
 */
export function isMultipartRequest(req: Request): boolean {
  const contentType = req.headers.get("content-type") ?? "";
  return contentType.includes("multipart/form-data");
}

/**
 * Parse multipart form data from a request.
 * Separates regular fields from file fields.
 *
 * File fields are collected into arrays to support multiple files per field.
 * Regular fields are parsed as JSON if possible, otherwise kept as strings.
 *
 * @param req - The incoming request with multipart/form-data
 * @returns Parsed data and files
 */
export async function parseMultipartRequest(
  req: Request
): Promise<MultipartParseResult> {
  const formData = await req.formData();
  const data: Record<string, unknown> = {};
  const files = new Map<string, File[]>();

  for (const [key, value] of formData.entries()) {
    if (value instanceof File) {
      // Skip empty file inputs (browser sends File with size=0 and no name)
      if (value.size === 0 && !value.name) {
        continue;
      }

      // Accumulate files for this field
      const existing = files.get(key) ?? [];
      existing.push(value);
      files.set(key, existing);
    } else {
      // Regular field - try to parse as JSON for complex values
      try {
        data[key] = JSON.parse(value);
      } catch {
        // Not JSON, keep as string
        data[key] = value;
      }
    }
  }

  return { data, files };
}
```

**src/storage/multipart.test.ts:**
```typescript
import { test, expect, describe } from "bun:test";
import { isMultipartRequest, parseMultipartRequest } from "./multipart";

describe("isMultipartRequest", () => {
  test("returns true for multipart/form-data content type", () => {
    const req = new Request("http://localhost/", {
      method: "POST",
      headers: { "Content-Type": "multipart/form-data; boundary=----WebKitFormBoundary" },
    });
    expect(isMultipartRequest(req)).toBe(true);
  });

  test("returns false for application/json content type", () => {
    const req = new Request("http://localhost/", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });
    expect(isMultipartRequest(req)).toBe(false);
  });

  test("returns false for missing content type", () => {
    const req = new Request("http://localhost/", { method: "POST" });
    expect(isMultipartRequest(req)).toBe(false);
  });
});

describe("parseMultipartRequest", () => {
  test("parses string fields from form data", async () => {
    const formData = new FormData();
    formData.append("title", "My Post");
    formData.append("description", "A description");

    const req = new Request("http://localhost/", {
      method: "POST",
      body: formData,
    });

    const result = await parseMultipartRequest(req);

    expect(result.data.title).toBe("My Post");
    expect(result.data.description).toBe("A description");
    expect(result.files.size).toBe(0);
  });

  test("parses JSON fields from form data", async () => {
    const formData = new FormData();
    formData.append("count", "42");
    formData.append("enabled", "true");
    formData.append("tags", JSON.stringify(["a", "b"]));

    const req = new Request("http://localhost/", {
      method: "POST",
      body: formData,
    });

    const result = await parseMultipartRequest(req);

    expect(result.data.count).toBe(42);
    expect(result.data.enabled).toBe(true);
    expect(result.data.tags).toEqual(["a", "b"]);
  });

  test("separates files from data fields", async () => {
    const formData = new FormData();
    formData.append("title", "My Post");
    formData.append("image", new File(["content"], "photo.jpg", { type: "image/jpeg" }));

    const req = new Request("http://localhost/", {
      method: "POST",
      body: formData,
    });

    const result = await parseMultipartRequest(req);

    expect(result.data.title).toBe("My Post");
    expect(result.files.size).toBe(1);
    expect(result.files.has("image")).toBe(true);
    expect(result.files.get("image")![0].name).toBe("photo.jpg");
  });

  test("skips empty file inputs (size=0, no name)", async () => {
    const formData = new FormData();
    formData.append("title", "Test");
    // Simulate browser empty file input
    formData.append("image", new File([], "", { type: "application/octet-stream" }));

    const req = new Request("http://localhost/", {
      method: "POST",
      body: formData,
    });

    const result = await parseMultipartRequest(req);

    expect(result.data.title).toBe("Test");
    expect(result.files.size).toBe(0);
  });

  test("accumulates multiple files per field", async () => {
    const formData = new FormData();
    formData.append("images", new File(["a"], "a.jpg", { type: "image/jpeg" }));
    formData.append("images", new File(["b"], "b.jpg", { type: "image/jpeg" }));
    formData.append("images", new File(["c"], "c.jpg", { type: "image/jpeg" }));

    const req = new Request("http://localhost/", {
      method: "POST",
      body: formData,
    });

    const result = await parseMultipartRequest(req);

    expect(result.files.size).toBe(1);
    expect(result.files.get("images")!.length).toBe(3);
    expect(result.files.get("images")![0].name).toBe("a.jpg");
    expect(result.files.get("images")![1].name).toBe("b.jpg");
    expect(result.files.get("images")![2].name).toBe("c.jpg");
  });

  test("handles File objects with content correctly", async () => {
    const content = "Hello, World!";
    const formData = new FormData();
    formData.append("doc", new File([content], "hello.txt", { type: "text/plain" }));

    const req = new Request("http://localhost/", {
      method: "POST",
      body: formData,
    });

    const result = await parseMultipartRequest(req);
    const file = result.files.get("doc")![0];

    expect(file.name).toBe("hello.txt");
    expect(file.size).toBe(content.length);
    expect(file.type).toBe("text/plain");
    expect(await file.text()).toBe(content);
  });

  test("keeps non-JSON strings as strings", async () => {
    const formData = new FormData();
    formData.append("name", "John Doe");
    formData.append("note", "This is not {valid json}");

    const req = new Request("http://localhost/", {
      method: "POST",
      body: formData,
    });

    const result = await parseMultipartRequest(req);

    expect(result.data.name).toBe("John Doe");
    expect(result.data.note).toBe("This is not {valid json}");
  });

  test("handles empty form data", async () => {
    const formData = new FormData();

    const req = new Request("http://localhost/", {
      method: "POST",
      body: formData,
    });

    const result = await parseMultipartRequest(req);

    expect(Object.keys(result.data).length).toBe(0);
    expect(result.files.size).toBe(0);
  });
});
```
  </action>
  <verify>Run `bun test src/storage/multipart.test.ts` - all tests pass</verify>
  <done>parseMultipartRequest and isMultipartRequest exported with correct types, all 11 tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Add file-aware record operations</name>
  <files>src/core/records.ts</files>
  <action>
Extend records.ts with file handling capabilities.

Add these imports at the top of src/core/records.ts:
```typescript
import { getFields, getCollection } from "./schema.ts";
import { saveFile, deleteFile } from "../storage/files.ts";
import {
  validateFieldFiles,
  formatFileErrors,
  type FileValidationError,
} from "../storage/validation.ts";
```

Add this new function after the existing exports (before the hook-aware operations section):

```typescript
/**
 * Get file field definitions for a collection.
 */
function getFileFields(collectionName: string): Field[] {
  const fields = getFields(collectionName);
  return fields.filter((f) => f.type === "file");
}

/**
 * Validate uploaded files against field options.
 *
 * @param collectionName - Name of the collection
 * @param files - Map of field names to File arrays
 * @returns Array of validation errors (empty if all valid)
 */
function validateUploadedFiles(
  collectionName: string,
  files: Map<string, File[]>
): FileValidationError[] {
  const fileFields = getFileFields(collectionName);
  const errors: FileValidationError[] = [];

  for (const field of fileFields) {
    const fieldFiles = files.get(field.name) ?? [];
    if (fieldFiles.length === 0) continue;

    const fieldErrors = validateFieldFiles(
      field.name,
      fieldFiles,
      field.options ?? {}
    );
    errors.push(...fieldErrors);
  }

  // Check for files uploaded to non-file fields
  for (const [fieldName, fieldFiles] of files) {
    const field = fileFields.find((f) => f.name === fieldName);
    if (!field && fieldFiles.length > 0) {
      errors.push({
        field: fieldName,
        file: "",
        message: `Field "${fieldName}" is not a file field`,
      });
    }
  }

  return errors;
}

/**
 * Save files for a record and return the update data.
 *
 * @param collectionName - Name of the collection
 * @param recordId - ID of the record
 * @param files - Map of field names to File arrays
 * @returns Data object with file field values (filenames or arrays)
 */
async function saveRecordFiles(
  collectionName: string,
  recordId: string,
  files: Map<string, File[]>
): Promise<Record<string, string | string[]>> {
  const fileFields = getFileFields(collectionName);
  const fileData: Record<string, string | string[]> = {};

  for (const field of fileFields) {
    const fieldFiles = files.get(field.name) ?? [];
    if (fieldFiles.length === 0) continue;

    const savedFilenames: string[] = [];
    for (const file of fieldFiles) {
      const filename = await saveFile(collectionName, recordId, file);
      savedFilenames.push(filename);
    }

    // Store as array if maxFiles > 1, else single string
    const maxFiles = field.options?.maxFiles ?? 1;
    fileData[field.name] = maxFiles > 1 ? savedFilenames : savedFilenames[0];
  }

  return fileData;
}

/**
 * Create a new record with file upload support.
 *
 * @param collectionName - Name of the collection
 * @param data - Record data (without files)
 * @param files - Map of field names to uploaded files
 * @param hooks - HookManager instance
 * @param request - Optional HTTP request for context
 * @param authContext - Optional auth context for rule enforcement
 * @returns The created record with file field values
 */
export async function createRecordWithFiles(
  collectionName: string,
  data: Record<string, unknown>,
  files: Map<string, File[]>,
  hooks: HookManager,
  request?: Request,
  authContext?: RecordAuthContext
): Promise<Record<string, unknown>> {
  // Validate files first
  const validationErrors = validateUploadedFiles(collectionName, files);
  if (validationErrors.length > 0) {
    throw new Error(`File validation failed: ${formatFileErrors(validationErrors)}`);
  }

  // Create the record first (to get ID)
  const record = await createRecordWithHooks(
    collectionName,
    data,
    hooks,
    request,
    authContext
  );

  // Save files if any
  if (files.size > 0) {
    const fileData = await saveRecordFiles(
      collectionName,
      record.id as string,
      files
    );

    // Update record with file references if we saved any files
    if (Object.keys(fileData).length > 0) {
      return updateRecord(collectionName, record.id as string, fileData);
    }
  }

  return record;
}

/**
 * Update a record with file upload support.
 *
 * @param collectionName - Name of the collection
 * @param id - Record ID
 * @param data - Record data to update (without files)
 * @param files - Map of field names to uploaded files
 * @param hooks - HookManager instance
 * @param request - Optional HTTP request for context
 * @param authContext - Optional auth context for rule enforcement
 * @returns The updated record with file field values
 */
export async function updateRecordWithFiles(
  collectionName: string,
  id: string,
  data: Record<string, unknown>,
  files: Map<string, File[]>,
  hooks: HookManager,
  request?: Request,
  authContext?: RecordAuthContext
): Promise<Record<string, unknown>> {
  // Validate files first
  const validationErrors = validateUploadedFiles(collectionName, files);
  if (validationErrors.length > 0) {
    throw new Error(`File validation failed: ${formatFileErrors(validationErrors)}`);
  }

  // Update the record data (without files)
  let record = await updateRecordWithHooks(
    collectionName,
    id,
    data,
    hooks,
    request,
    authContext
  );

  // Save new files if any
  if (files.size > 0) {
    const fileData = await saveRecordFiles(collectionName, id, files);

    // Update record with file references if we saved any files
    if (Object.keys(fileData).length > 0) {
      record = updateRecord(collectionName, id, fileData);
    }
  }

  return record;
}
```

Also add the import for the storage modules at the top (after existing imports):
```typescript
import { saveFile } from "../storage/files.ts";
import {
  validateFieldFiles,
  formatFileErrors,
  type FileValidationError,
} from "../storage/validation.ts";
```
  </action>
  <verify>Run `bun build src/core/records.ts` - no TypeScript errors</verify>
  <done>createRecordWithFiles and updateRecordWithFiles exported, file validation and saving integrated</done>
</task>

<task type="auto">
  <name>Task 3: Update API endpoints for multipart handling</name>
  <files>src/api/server.ts</files>
  <action>
Update the records API endpoints to handle both JSON and multipart requests.

Add import at the top of src/api/server.ts:
```typescript
import {
  isMultipartRequest,
  parseMultipartRequest,
} from "../storage/multipart";
import {
  createRecordWithFiles,
  updateRecordWithFiles,
} from "../core/records";
```

Also update the imports from "../core/records" to include the new functions.

Replace the POST handler in "/api/collections/:name/records":
```typescript
/**
 * POST /api/collections/:name/records
 * Create a new record in a collection (with lifecycle hooks)
 * Supports both JSON and multipart/form-data for file uploads
 * Respects collection create rules
 */
POST: async (req) => {
  try {
    const { name } = req.params;
    const user = await optionalUser(req);
    const authContext = { isAdmin: false, user };

    if (isMultipartRequest(req)) {
      // Handle multipart form data (with files)
      const { data, files } = await parseMultipartRequest(req);
      const record = await createRecordWithFiles(
        name,
        data,
        files,
        hookManager,
        req,
        authContext
      );
      return Response.json(record, { status: 201 });
    } else {
      // Handle JSON request (no files)
      const body = await req.json();
      const record = await createRecordWithHooks(name, body, hookManager, req, authContext);
      return Response.json(record, { status: 201 });
    }
  } catch (error) {
    const err = error as Error;
    if (err.message === 'Access denied') {
      return errorResponse(err.message, 403);
    }
    return errorResponse(err.message, mapErrorToStatus(err));
  }
},
```

Replace the PATCH handler in "/api/collections/:name/records/:id":
```typescript
/**
 * PATCH /api/collections/:name/records/:id
 * Update a record by ID (with lifecycle hooks)
 * Supports both JSON and multipart/form-data for file uploads
 * Respects collection update rules
 */
PATCH: async (req) => {
  try {
    const { name, id } = req.params;
    const user = await optionalUser(req);
    const authContext = { isAdmin: false, user };

    if (isMultipartRequest(req)) {
      // Handle multipart form data (with files)
      const { data, files } = await parseMultipartRequest(req);
      const record = await updateRecordWithFiles(
        name,
        id,
        data,
        files,
        hookManager,
        req,
        authContext
      );
      return Response.json(record);
    } else {
      // Handle JSON request (no files)
      const body = await req.json();
      const record = await updateRecordWithHooks(name, id, body, hookManager, req, authContext);
      return Response.json(record);
    }
  } catch (error) {
    const err = error as Error;
    if (err.message === 'Access denied') {
      return errorResponse(err.message, 403);
    }
    return errorResponse(err.message, mapErrorToStatus(err));
  }
},
```
  </action>
  <verify>Run `bun build src/api/server.ts` - no TypeScript errors</verify>
  <done>POST and PATCH endpoints handle multipart/form-data, file validation errors return 400</done>
</task>

</tasks>

<verification>
1. `bun test src/storage/multipart.test.ts` - all tests pass
2. `bun build src/core/records.ts` - no errors
3. `bun build src/api/server.ts` - no errors
4. Manual test: Create record with file via curl multipart
</verification>

<success_criteria>
- isMultipartRequest detects Content-Type: multipart/form-data
- parseMultipartRequest separates data fields from files
- Multipart parser tests pass (empty file, JSON fields, multiple files per field, File vs string)
- createRecordWithFiles validates files, creates record, saves files, updates record
- updateRecordWithFiles validates files, updates record, saves files, updates again
- API POST/PATCH detect multipart and route to file-aware functions
- File validation errors return 400 with clear message
- JSON requests continue to work as before
</success_criteria>

<output>
After completion, create `.planning/phases/11-file-uploads/11-04-SUMMARY.md`
</output>
