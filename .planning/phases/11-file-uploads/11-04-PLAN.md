---
phase: 11-file-uploads
plan: 04
type: execute
wave: 2
depends_on: ["11-01", "11-02", "11-03"]
files_modified:
  - src/storage/multipart.ts
  - src/core/records.ts
  - src/api/server.ts
autonomous: true

must_haves:
  truths:
    - "Multipart form data requests are parsed into data and files"
    - "Records API POST accepts multipart uploads with file fields"
    - "Records API PATCH accepts multipart uploads for file updates"
    - "File validation errors return 400 with clear message"
  artifacts:
    - path: "src/storage/multipart.ts"
      provides: "Multipart request parsing"
      exports: ["parseMultipartRequest", "isMultipartRequest"]
    - path: "src/core/records.ts"
      provides: "File-aware record operations"
      contains: "createRecordWithFiles"
  key_links:
    - from: "src/api/server.ts"
      to: "src/storage/multipart.ts"
      via: "import for request parsing"
      pattern: "from.*storage/multipart"
    - from: "src/core/records.ts"
      to: "src/storage/files.ts"
      via: "import for file saving"
      pattern: "from.*storage/files"
---

<objective>
Integrate file uploads into the records API via multipart form data handling.

Purpose: FILE-02 requires multipart upload via records API (create and update). This plan adds multipart request parsing and integrates file handling into the existing record create/update workflow.

Output: Multipart parser, file-aware record operations, and updated API endpoints that detect and handle file uploads.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-file-uploads/11-RESEARCH.md

@src/core/records.ts
@src/api/server.ts
@src/types/collection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multipart request parser</name>
  <files>src/storage/multipart.ts</files>
  <action>
Create module for parsing multipart form data requests.

**src/storage/multipart.ts:**
```typescript
/**
 * Multipart form data parsing utilities.
 * Uses Bun's native Request.formData() for parsing.
 */

/**
 * Result of parsing a multipart request.
 */
export interface MultipartParseResult {
  /** Regular field data (non-file fields) */
  data: Record<string, unknown>;
  /** File fields mapped to arrays of File objects */
  files: Map<string, File[]>;
}

/**
 * Check if a request contains multipart form data.
 *
 * @param req - The incoming request
 * @returns True if the request is multipart/form-data
 */
export function isMultipartRequest(req: Request): boolean {
  const contentType = req.headers.get("content-type") ?? "";
  return contentType.includes("multipart/form-data");
}

/**
 * Parse multipart form data from a request.
 * Separates regular fields from file fields.
 *
 * File fields are collected into arrays to support multiple files per field.
 * Regular fields are parsed as JSON if possible, otherwise kept as strings.
 *
 * @param req - The incoming request with multipart/form-data
 * @returns Parsed data and files
 */
export async function parseMultipartRequest(
  req: Request
): Promise<MultipartParseResult> {
  const formData = await req.formData();
  const data: Record<string, unknown> = {};
  const files = new Map<string, File[]>();

  for (const [key, value] of formData.entries()) {
    if (value instanceof File) {
      // Skip empty file inputs (browser sends File with size=0 and no name)
      if (value.size === 0 && !value.name) {
        continue;
      }

      // Accumulate files for this field
      const existing = files.get(key) ?? [];
      existing.push(value);
      files.set(key, existing);
    } else {
      // Regular field - try to parse as JSON for complex values
      try {
        data[key] = JSON.parse(value);
      } catch {
        // Not JSON, keep as string
        data[key] = value;
      }
    }
  }

  return { data, files };
}
```
  </action>
  <verify>Run `bun build src/storage/multipart.ts` - no TypeScript errors</verify>
  <done>parseMultipartRequest and isMultipartRequest exported with correct types</done>
</task>

<task type="auto">
  <name>Task 2: Add file-aware record operations</name>
  <files>src/core/records.ts</files>
  <action>
Extend records.ts with file handling capabilities.

Add these imports at the top of src/core/records.ts:
```typescript
import { getFields, getCollection } from "./schema.ts";
import { saveFile, deleteFile } from "../storage/files.ts";
import {
  validateFieldFiles,
  formatFileErrors,
  type FileValidationError,
} from "../storage/validation.ts";
```

Add this new function after the existing exports (before the hook-aware operations section):

```typescript
/**
 * Get file field definitions for a collection.
 */
function getFileFields(collectionName: string): Field[] {
  const fields = getFields(collectionName);
  return fields.filter((f) => f.type === "file");
}

/**
 * Validate uploaded files against field options.
 *
 * @param collectionName - Name of the collection
 * @param files - Map of field names to File arrays
 * @returns Array of validation errors (empty if all valid)
 */
function validateUploadedFiles(
  collectionName: string,
  files: Map<string, File[]>
): FileValidationError[] {
  const fileFields = getFileFields(collectionName);
  const errors: FileValidationError[] = [];

  for (const field of fileFields) {
    const fieldFiles = files.get(field.name) ?? [];
    if (fieldFiles.length === 0) continue;

    const fieldErrors = validateFieldFiles(
      field.name,
      fieldFiles,
      field.options ?? {}
    );
    errors.push(...fieldErrors);
  }

  // Check for files uploaded to non-file fields
  for (const [fieldName, fieldFiles] of files) {
    const field = fileFields.find((f) => f.name === fieldName);
    if (!field && fieldFiles.length > 0) {
      errors.push({
        field: fieldName,
        file: "",
        message: `Field "${fieldName}" is not a file field`,
      });
    }
  }

  return errors;
}

/**
 * Save files for a record and return the update data.
 *
 * @param collectionName - Name of the collection
 * @param recordId - ID of the record
 * @param files - Map of field names to File arrays
 * @returns Data object with file field values (filenames or arrays)
 */
async function saveRecordFiles(
  collectionName: string,
  recordId: string,
  files: Map<string, File[]>
): Promise<Record<string, string | string[]>> {
  const fileFields = getFileFields(collectionName);
  const fileData: Record<string, string | string[]> = {};

  for (const field of fileFields) {
    const fieldFiles = files.get(field.name) ?? [];
    if (fieldFiles.length === 0) continue;

    const savedFilenames: string[] = [];
    for (const file of fieldFiles) {
      const filename = await saveFile(collectionName, recordId, file);
      savedFilenames.push(filename);
    }

    // Store as array if maxFiles > 1, else single string
    const maxFiles = field.options?.maxFiles ?? 1;
    fileData[field.name] = maxFiles > 1 ? savedFilenames : savedFilenames[0];
  }

  return fileData;
}

/**
 * Create a new record with file upload support.
 *
 * @param collectionName - Name of the collection
 * @param data - Record data (without files)
 * @param files - Map of field names to uploaded files
 * @param hooks - HookManager instance
 * @param request - Optional HTTP request for context
 * @param authContext - Optional auth context for rule enforcement
 * @returns The created record with file field values
 */
export async function createRecordWithFiles(
  collectionName: string,
  data: Record<string, unknown>,
  files: Map<string, File[]>,
  hooks: HookManager,
  request?: Request,
  authContext?: RecordAuthContext
): Promise<Record<string, unknown>> {
  // Validate files first
  const validationErrors = validateUploadedFiles(collectionName, files);
  if (validationErrors.length > 0) {
    throw new Error(`File validation failed: ${formatFileErrors(validationErrors)}`);
  }

  // Create the record first (to get ID)
  const record = await createRecordWithHooks(
    collectionName,
    data,
    hooks,
    request,
    authContext
  );

  // Save files if any
  if (files.size > 0) {
    const fileData = await saveRecordFiles(
      collectionName,
      record.id as string,
      files
    );

    // Update record with file references if we saved any files
    if (Object.keys(fileData).length > 0) {
      return updateRecord(collectionName, record.id as string, fileData);
    }
  }

  return record;
}

/**
 * Update a record with file upload support.
 *
 * @param collectionName - Name of the collection
 * @param id - Record ID
 * @param data - Record data to update (without files)
 * @param files - Map of field names to uploaded files
 * @param hooks - HookManager instance
 * @param request - Optional HTTP request for context
 * @param authContext - Optional auth context for rule enforcement
 * @returns The updated record with file field values
 */
export async function updateRecordWithFiles(
  collectionName: string,
  id: string,
  data: Record<string, unknown>,
  files: Map<string, File[]>,
  hooks: HookManager,
  request?: Request,
  authContext?: RecordAuthContext
): Promise<Record<string, unknown>> {
  // Validate files first
  const validationErrors = validateUploadedFiles(collectionName, files);
  if (validationErrors.length > 0) {
    throw new Error(`File validation failed: ${formatFileErrors(validationErrors)}`);
  }

  // Update the record data (without files)
  let record = await updateRecordWithHooks(
    collectionName,
    id,
    data,
    hooks,
    request,
    authContext
  );

  // Save new files if any
  if (files.size > 0) {
    const fileData = await saveRecordFiles(collectionName, id, files);

    // Update record with file references if we saved any files
    if (Object.keys(fileData).length > 0) {
      record = updateRecord(collectionName, id, fileData);
    }
  }

  return record;
}
```

Also add the import for the storage modules at the top (after existing imports):
```typescript
import { saveFile } from "../storage/files.ts";
import {
  validateFieldFiles,
  formatFileErrors,
  type FileValidationError,
} from "../storage/validation.ts";
```
  </action>
  <verify>Run `bun build src/core/records.ts` - no TypeScript errors</verify>
  <done>createRecordWithFiles and updateRecordWithFiles exported, file validation and saving integrated</done>
</task>

<task type="auto">
  <name>Task 3: Update API endpoints for multipart handling</name>
  <files>src/api/server.ts</files>
  <action>
Update the records API endpoints to handle both JSON and multipart requests.

Add import at the top of src/api/server.ts:
```typescript
import {
  isMultipartRequest,
  parseMultipartRequest,
} from "../storage/multipart";
import {
  createRecordWithFiles,
  updateRecordWithFiles,
} from "../core/records";
```

Also update the imports from "../core/records" to include the new functions.

Replace the POST handler in "/api/collections/:name/records":
```typescript
/**
 * POST /api/collections/:name/records
 * Create a new record in a collection (with lifecycle hooks)
 * Supports both JSON and multipart/form-data for file uploads
 * Respects collection create rules
 */
POST: async (req) => {
  try {
    const { name } = req.params;
    const user = await optionalUser(req);
    const authContext = { isAdmin: false, user };

    if (isMultipartRequest(req)) {
      // Handle multipart form data (with files)
      const { data, files } = await parseMultipartRequest(req);
      const record = await createRecordWithFiles(
        name,
        data,
        files,
        hookManager,
        req,
        authContext
      );
      return Response.json(record, { status: 201 });
    } else {
      // Handle JSON request (no files)
      const body = await req.json();
      const record = await createRecordWithHooks(name, body, hookManager, req, authContext);
      return Response.json(record, { status: 201 });
    }
  } catch (error) {
    const err = error as Error;
    if (err.message === 'Access denied') {
      return errorResponse(err.message, 403);
    }
    return errorResponse(err.message, mapErrorToStatus(err));
  }
},
```

Replace the PATCH handler in "/api/collections/:name/records/:id":
```typescript
/**
 * PATCH /api/collections/:name/records/:id
 * Update a record by ID (with lifecycle hooks)
 * Supports both JSON and multipart/form-data for file uploads
 * Respects collection update rules
 */
PATCH: async (req) => {
  try {
    const { name, id } = req.params;
    const user = await optionalUser(req);
    const authContext = { isAdmin: false, user };

    if (isMultipartRequest(req)) {
      // Handle multipart form data (with files)
      const { data, files } = await parseMultipartRequest(req);
      const record = await updateRecordWithFiles(
        name,
        id,
        data,
        files,
        hookManager,
        req,
        authContext
      );
      return Response.json(record);
    } else {
      // Handle JSON request (no files)
      const body = await req.json();
      const record = await updateRecordWithHooks(name, id, body, hookManager, req, authContext);
      return Response.json(record);
    }
  } catch (error) {
    const err = error as Error;
    if (err.message === 'Access denied') {
      return errorResponse(err.message, 403);
    }
    return errorResponse(err.message, mapErrorToStatus(err));
  }
},
```
  </action>
  <verify>Run `bun build src/api/server.ts` - no TypeScript errors</verify>
  <done>POST and PATCH endpoints handle multipart/form-data, file validation errors return 400</done>
</task>

</tasks>

<verification>
1. `bun build src/storage/multipart.ts` - no errors
2. `bun build src/core/records.ts` - no errors
3. `bun build src/api/server.ts` - no errors
4. Manual test: Create record with file via curl multipart
</verification>

<success_criteria>
- isMultipartRequest detects Content-Type: multipart/form-data
- parseMultipartRequest separates data fields from files
- createRecordWithFiles validates files, creates record, saves files, updates record
- updateRecordWithFiles validates files, updates record, saves files, updates again
- API POST/PATCH detect multipart and route to file-aware functions
- File validation errors return 400 with clear message
- JSON requests continue to work as before
</success_criteria>

<output>
After completion, create `.planning/phases/11-file-uploads/11-04-SUMMARY.md`
</output>
