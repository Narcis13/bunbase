---
phase: 11-file-uploads
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/storage/validation.ts
  - src/storage/validation.test.ts
autonomous: true

must_haves:
  truths:
    - "Files exceeding size limit are rejected with clear error"
    - "Files with disallowed MIME types are rejected"
    - "Files exceeding maxFiles count are rejected"
    - "Wildcard MIME types (image/*) work correctly"
  artifacts:
    - path: "src/storage/validation.ts"
      provides: "File validation functions"
      exports: ["validateFile", "validateFieldFiles", "formatBytes"]
    - path: "src/storage/validation.test.ts"
      provides: "Validation tests"
      min_lines: 80
  key_links:
    - from: "src/storage/validation.ts"
      to: "src/types/collection.ts"
      via: "FieldOptions type import"
      pattern: "from.*types/collection"
---

<objective>
Implement file validation for size limits, MIME type restrictions, and file count limits.

Purpose: FILE-06 (configurable size limit), FILE-07 (MIME type validation), and FILE-08 (multiple files per field) require server-side validation before accepting uploads. This prevents DoS attacks and enforces schema constraints.

Output: Validation module with functions to validate individual files and entire field uploads, returning structured error messages.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-file-uploads/11-RESEARCH.md

@src/types/collection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement file validation module</name>
  <files>src/storage/validation.ts</files>
  <action>
Create the file validation module.

**src/storage/validation.ts:**
```typescript
import type { FieldOptions } from "../types/collection";

/** Default maximum file size: 10MB */
const DEFAULT_MAX_SIZE = 10 * 1024 * 1024;

/** Default maximum files per field */
const DEFAULT_MAX_FILES = 1;

/**
 * Error information for a file validation failure.
 */
export interface FileValidationError {
  /** Field name where the error occurred */
  field: string;
  /** Original filename (empty string for field-level errors) */
  file: string;
  /** Human-readable error message */
  message: string;
}

/**
 * Format bytes to human-readable string.
 *
 * @param bytes - Number of bytes
 * @returns Formatted string (e.g., "10.5 MB")
 */
export function formatBytes(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

/**
 * Check if a MIME type matches an allowed type pattern.
 * Supports exact matches and wildcards (e.g., "image/*").
 *
 * @param fileType - The file's MIME type
 * @param allowedType - The allowed type pattern
 * @returns True if the type matches
 */
function matchesMimeType(fileType: string, allowedType: string): boolean {
  if (allowedType.endsWith("/*")) {
    // Wildcard match (e.g., "image/*" matches "image/jpeg")
    const prefix = allowedType.slice(0, -1); // "image/"
    return fileType.startsWith(prefix);
  }
  return fileType === allowedType;
}

/**
 * Validate a single file against field options.
 *
 * @param fieldName - Name of the field for error messages
 * @param file - File object to validate
 * @param options - Field options with validation constraints
 * @returns Error object if validation fails, null if valid
 */
export function validateFile(
  fieldName: string,
  file: File,
  options: FieldOptions = {}
): FileValidationError | null {
  // Check file size
  const maxSize = options.maxSize ?? DEFAULT_MAX_SIZE;
  if (file.size > maxSize) {
    return {
      field: fieldName,
      file: file.name,
      message: `File "${file.name}" exceeds maximum size of ${formatBytes(maxSize)}`,
    };
  }

  // Check MIME type if restrictions defined
  if (options.allowedTypes && options.allowedTypes.length > 0) {
    const isAllowed = options.allowedTypes.some((type) =>
      matchesMimeType(file.type, type)
    );

    if (!isAllowed) {
      return {
        field: fieldName,
        file: file.name,
        message: `File "${file.name}" type "${file.type}" is not allowed. Allowed: ${options.allowedTypes.join(", ")}`,
      };
    }
  }

  return null;
}

/**
 * Validate all files for a field.
 * Checks file count limit, then validates each individual file.
 *
 * @param fieldName - Name of the field for error messages
 * @param files - Array of File objects to validate
 * @param options - Field options with validation constraints
 * @returns Array of error objects (empty if all valid)
 */
export function validateFieldFiles(
  fieldName: string,
  files: File[],
  options: FieldOptions = {}
): FileValidationError[] {
  const errors: FileValidationError[] = [];

  // Check max files count
  const maxFiles = options.maxFiles ?? DEFAULT_MAX_FILES;
  if (files.length > maxFiles) {
    errors.push({
      field: fieldName,
      file: "",
      message: `Field "${fieldName}" allows maximum ${maxFiles} file(s), received ${files.length}`,
    });
  }

  // Validate each file
  for (const file of files) {
    const error = validateFile(fieldName, file, options);
    if (error) {
      errors.push(error);
    }
  }

  return errors;
}

/**
 * Format file validation errors into a single error message.
 *
 * @param errors - Array of validation errors
 * @returns Combined error message
 */
export function formatFileErrors(errors: FileValidationError[]): string {
  return errors.map((e) => e.message).join("; ");
}
```
  </action>
  <verify>Run `bun build src/storage/validation.ts` - no TypeScript errors</verify>
  <done>validateFile, validateFieldFiles, formatBytes, formatFileErrors exported and typed correctly</done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive validation tests</name>
  <files>src/storage/validation.test.ts</files>
  <action>
Create tests covering all validation scenarios.

**src/storage/validation.test.ts:**
```typescript
import { test, expect, describe } from "bun:test";
import {
  validateFile,
  validateFieldFiles,
  formatBytes,
  formatFileErrors,
  type FileValidationError,
} from "./validation";

describe("formatBytes", () => {
  test("formats bytes", () => {
    expect(formatBytes(500)).toBe("500 B");
  });

  test("formats kilobytes", () => {
    expect(formatBytes(1024)).toBe("1.0 KB");
    expect(formatBytes(1536)).toBe("1.5 KB");
  });

  test("formats megabytes", () => {
    expect(formatBytes(1024 * 1024)).toBe("1.0 MB");
    expect(formatBytes(10 * 1024 * 1024)).toBe("10.0 MB");
    expect(formatBytes(10.5 * 1024 * 1024)).toBe("10.5 MB");
  });
});

describe("validateFile", () => {
  describe("size validation", () => {
    test("accepts files under size limit", () => {
      const file = new File(["x".repeat(1000)], "test.txt");
      const error = validateFile("doc", file, { maxSize: 5000 });
      expect(error).toBeNull();
    });

    test("accepts files at exact size limit", () => {
      const file = new File(["x".repeat(1000)], "test.txt");
      const error = validateFile("doc", file, { maxSize: 1000 });
      expect(error).toBeNull();
    });

    test("rejects files over size limit", () => {
      const file = new File(["x".repeat(2000)], "big.txt");
      const error = validateFile("doc", file, { maxSize: 1000 });
      expect(error).not.toBeNull();
      expect(error!.field).toBe("doc");
      expect(error!.file).toBe("big.txt");
      expect(error!.message).toContain("exceeds maximum size");
      expect(error!.message).toContain("1000 B");
    });

    test("uses default 10MB limit when not specified", () => {
      // File just under 10MB should pass
      const content = "x".repeat(9 * 1024 * 1024);
      const file = new File([content], "large.bin");
      const error = validateFile("doc", file, {});
      expect(error).toBeNull();
    });

    test("rejects files over default 10MB limit", () => {
      const content = "x".repeat(11 * 1024 * 1024);
      const file = new File([content], "huge.bin");
      const error = validateFile("doc", file, {});
      expect(error).not.toBeNull();
      expect(error!.message).toContain("10.0 MB");
    });
  });

  describe("MIME type validation", () => {
    test("accepts any type when allowedTypes not specified", () => {
      const file = new File(["data"], "test.exe", { type: "application/octet-stream" });
      const error = validateFile("doc", file, {});
      expect(error).toBeNull();
    });

    test("accepts any type when allowedTypes is empty", () => {
      const file = new File(["data"], "test.exe", { type: "application/octet-stream" });
      const error = validateFile("doc", file, { allowedTypes: [] });
      expect(error).toBeNull();
    });

    test("accepts matching exact MIME type", () => {
      const file = new File(["data"], "photo.jpg", { type: "image/jpeg" });
      const error = validateFile("avatar", file, { allowedTypes: ["image/jpeg", "image/png"] });
      expect(error).toBeNull();
    });

    test("accepts matching wildcard MIME type", () => {
      const jpegFile = new File(["data"], "photo.jpg", { type: "image/jpeg" });
      const pngFile = new File(["data"], "photo.png", { type: "image/png" });
      const gifFile = new File(["data"], "animation.gif", { type: "image/gif" });

      const options = { allowedTypes: ["image/*"] };

      expect(validateFile("pic", jpegFile, options)).toBeNull();
      expect(validateFile("pic", pngFile, options)).toBeNull();
      expect(validateFile("pic", gifFile, options)).toBeNull();
    });

    test("rejects non-matching MIME type", () => {
      const file = new File(["data"], "script.js", { type: "application/javascript" });
      const error = validateFile("avatar", file, { allowedTypes: ["image/jpeg", "image/png"] });

      expect(error).not.toBeNull();
      expect(error!.message).toContain("application/javascript");
      expect(error!.message).toContain("not allowed");
      expect(error!.message).toContain("image/jpeg, image/png");
    });

    test("rejects non-matching wildcard MIME type", () => {
      const file = new File(["data"], "doc.pdf", { type: "application/pdf" });
      const error = validateFile("photo", file, { allowedTypes: ["image/*"] });

      expect(error).not.toBeNull();
      expect(error!.message).toContain("application/pdf");
    });

    test("handles missing file type gracefully", () => {
      const file = new File(["data"], "unknown");
      // file.type defaults to "" for unknown types
      const error = validateFile("doc", file, { allowedTypes: ["text/plain"] });

      expect(error).not.toBeNull();
      expect(error!.message).toContain("not allowed");
    });
  });
});

describe("validateFieldFiles", () => {
  test("accepts valid files within count limit", () => {
    const files = [
      new File(["data"], "file1.txt"),
      new File(["data"], "file2.txt"),
    ];
    const errors = validateFieldFiles("docs", files, { maxFiles: 5 });
    expect(errors).toEqual([]);
  });

  test("accepts files at exact count limit", () => {
    const files = [
      new File(["data"], "file1.txt"),
      new File(["data"], "file2.txt"),
    ];
    const errors = validateFieldFiles("docs", files, { maxFiles: 2 });
    expect(errors).toEqual([]);
  });

  test("rejects files exceeding count limit", () => {
    const files = [
      new File(["data"], "file1.txt"),
      new File(["data"], "file2.txt"),
      new File(["data"], "file3.txt"),
    ];
    const errors = validateFieldFiles("docs", files, { maxFiles: 2 });

    expect(errors.length).toBe(1);
    expect(errors[0].field).toBe("docs");
    expect(errors[0].message).toContain("maximum 2 file(s)");
    expect(errors[0].message).toContain("received 3");
  });

  test("uses default maxFiles of 1", () => {
    const files = [
      new File(["data"], "file1.txt"),
      new File(["data"], "file2.txt"),
    ];
    const errors = validateFieldFiles("avatar", files, {});

    expect(errors.length).toBe(1);
    expect(errors[0].message).toContain("maximum 1 file(s)");
  });

  test("returns multiple errors for multiple issues", () => {
    const files = [
      new File(["x".repeat(2000)], "big1.txt"),  // Too big
      new File(["x".repeat(2000)], "big2.txt"),  // Too big
      new File(["x".repeat(2000)], "big3.txt"),  // Too big (and over count)
    ];
    const errors = validateFieldFiles("docs", files, {
      maxFiles: 2,
      maxSize: 1000,
    });

    // Should have 1 count error + 3 size errors = 4 total
    expect(errors.length).toBe(4);
  });

  test("validates both count and MIME type", () => {
    const files = [
      new File(["data"], "photo.jpg", { type: "image/jpeg" }),
      new File(["data"], "script.js", { type: "application/javascript" }),
    ];
    const errors = validateFieldFiles("images", files, {
      maxFiles: 5,
      allowedTypes: ["image/*"],
    });

    // Should reject the .js file
    expect(errors.length).toBe(1);
    expect(errors[0].file).toBe("script.js");
  });

  test("handles empty files array", () => {
    const errors = validateFieldFiles("docs", [], { maxFiles: 1 });
    expect(errors).toEqual([]);
  });
});

describe("formatFileErrors", () => {
  test("formats single error", () => {
    const errors: FileValidationError[] = [
      { field: "doc", file: "big.txt", message: "File too large" },
    ];
    expect(formatFileErrors(errors)).toBe("File too large");
  });

  test("formats multiple errors with semicolon separator", () => {
    const errors: FileValidationError[] = [
      { field: "doc", file: "", message: "Too many files" },
      { field: "doc", file: "a.txt", message: "File too large" },
    ];
    expect(formatFileErrors(errors)).toBe("Too many files; File too large");
  });

  test("handles empty errors array", () => {
    expect(formatFileErrors([])).toBe("");
  });
});
```
  </action>
  <verify>Run `bun test src/storage/validation.test.ts` - all tests pass</verify>
  <done>All validation tests pass: size limits, MIME types, file count, error formatting</done>
</task>

</tasks>

<verification>
1. `bun build src/storage/validation.ts` - no errors
2. `bun test src/storage/validation.test.ts` - all tests pass
3. Test coverage: size validation, MIME type exact match, MIME type wildcard, file count
</verification>

<success_criteria>
- validateFile checks size against maxSize (default 10MB)
- validateFile checks MIME type against allowedTypes (supports wildcards)
- validateFieldFiles checks file count against maxFiles (default 1)
- validateFieldFiles accumulates all errors (doesn't stop at first)
- formatBytes produces human-readable sizes
- formatFileErrors joins error messages
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-file-uploads/11-03-SUMMARY.md`
</output>
