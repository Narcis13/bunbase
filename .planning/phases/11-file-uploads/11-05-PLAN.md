---
phase: 11-file-uploads
plan: 05
type: execute
wave: 3
depends_on: ["11-02", "11-04"]
files_modified:
  - src/storage/urls.ts
  - src/api/server.ts
autonomous: true

must_haves:
  truths:
    - "Files can be downloaded via GET /api/files/{collection}/{record}/{filename}"
    - "File serving respects collection view rules"
    - "Content-Type is automatically detected from file extension"
    - "File URLs are included in API responses for file fields"
  artifacts:
    - path: "src/storage/urls.ts"
      provides: "File URL generation helpers"
      exports: ["getFileUrl", "addFileUrls"]
    - path: "src/api/server.ts"
      provides: "File serving endpoint"
      contains: "/api/files/:collection/:record/:filename"
  key_links:
    - from: "src/api/server.ts"
      to: "Bun.file"
      via: "file serving"
      pattern: "Bun\\.file"
    - from: "src/api/server.ts"
      to: "src/storage/files.ts"
      via: "storage path functions"
      pattern: "getFilePath"
---

<objective>
Implement file serving endpoint and URL generation helper for API responses.

Purpose: FILE-04 (file serving endpoint) and FILE-10 (file URL generation) enable downloading uploaded files and receiving full URLs in API responses instead of raw filenames.

Output: File serving endpoint at `/api/files/{collection}/{record}/{filename}` with access control, and URL helper that transforms file fields in record responses.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-file-uploads/11-RESEARCH.md

@src/api/server.ts
@src/storage/files.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create URL generation helpers</name>
  <files>src/storage/urls.ts</files>
  <action>
Create module for file URL generation.

**src/storage/urls.ts:**
```typescript
import type { Field } from "../types/collection";

/**
 * Generate the URL for accessing a file.
 *
 * @param baseUrl - Base URL of the server (e.g., "http://localhost:8090")
 * @param collectionName - Name of the collection
 * @param recordId - ID of the record
 * @param filename - Stored filename
 * @returns Full URL to access the file
 */
export function getFileUrl(
  baseUrl: string,
  collectionName: string,
  recordId: string,
  filename: string
): string {
  return `${baseUrl}/api/files/${collectionName}/${recordId}/${encodeURIComponent(filename)}`;
}

/**
 * Add file URLs to a record response.
 * Transforms file field values from filenames to full URLs.
 *
 * For single-file fields, transforms "filename.jpg" to "http://host/api/files/..."
 * For multi-file fields, transforms ["a.jpg", "b.jpg"] to ["http://...", "http://..."]
 *
 * @param record - The record object
 * @param fields - Field definitions for the collection
 * @param baseUrl - Base URL of the server
 * @param collectionName - Name of the collection
 * @returns Record with file fields transformed to URLs
 */
export function addFileUrls(
  record: Record<string, unknown>,
  fields: Field[],
  baseUrl: string,
  collectionName: string
): Record<string, unknown> {
  const result = { ...record };
  const recordId = result.id as string;

  for (const field of fields) {
    if (field.type !== "file") continue;

    const value = result[field.name];
    if (!value) continue;

    if (Array.isArray(value)) {
      // Multiple files - transform each to URL
      result[field.name] = value.map((filename) =>
        typeof filename === "string"
          ? getFileUrl(baseUrl, collectionName, recordId, filename)
          : filename
      );
    } else if (typeof value === "string") {
      // Single file - transform to URL
      result[field.name] = getFileUrl(baseUrl, collectionName, recordId, value);
    }
  }

  return result;
}

/**
 * Transform multiple records to include file URLs.
 *
 * @param records - Array of records
 * @param fields - Field definitions for the collection
 * @param baseUrl - Base URL of the server
 * @param collectionName - Name of the collection
 * @returns Records with file fields transformed to URLs
 */
export function addFileUrlsToList(
  records: Record<string, unknown>[],
  fields: Field[],
  baseUrl: string,
  collectionName: string
): Record<string, unknown>[] {
  return records.map((record) =>
    addFileUrls(record, fields, baseUrl, collectionName)
  );
}
```
  </action>
  <verify>Run `bun build src/storage/urls.ts` - no TypeScript errors</verify>
  <done>getFileUrl, addFileUrls, addFileUrlsToList exported</done>
</task>

<task type="auto">
  <name>Task 2: Add file serving endpoint and integrate URLs in responses</name>
  <files>src/api/server.ts</files>
  <action>
Add file serving endpoint and update record responses to include file URLs.

**Add imports at top of src/api/server.ts:**
```typescript
import { getFilePath, fileExists } from "../storage/files";
import { addFileUrls, addFileUrlsToList } from "../storage/urls";
```

**Add new route for file serving (add to routes object):**
```typescript
// File serving endpoint
"/api/files/:collection/:record/:filename": {
  /**
   * GET /api/files/:collection/:record/:filename
   * Serve a file from storage with access control
   * Respects collection view rules (uses same auth as record view)
   */
  GET: async (req) => {
    try {
      const { collection, record: recordId, filename } = req.params;
      const user = await optionalUser(req);
      const authContext = { isAdmin: false, user };

      // Verify record exists and user can view it
      // This enforces collection view rules for file access
      const recordData = getRecord(collection, recordId, authContext);
      if (!recordData) {
        return errorResponse("Not found", 404);
      }

      // Check file exists
      const exists = await fileExists(collection, recordId, filename);
      if (!exists) {
        return errorResponse("File not found", 404);
      }

      // Get file path and serve
      const filePath = getFilePath(collection, recordId, filename);
      const file = Bun.file(filePath);

      // Return file - Bun automatically sets Content-Type from extension
      return new Response(file);
    } catch (error) {
      const err = error as Error;
      if (err.message === "Access denied") {
        return errorResponse(err.message, 403);
      }
      return errorResponse(err.message, mapErrorToStatus(err));
    }
  },
},
```

**Update the record GET endpoint to include file URLs:**

In "/api/collections/:name/records/:id" GET handler, update to add file URLs:
```typescript
GET: async (req) => {
  try {
    const { name, id } = req.params;
    const user = await optionalUser(req);
    const authContext = { isAdmin: false, user };
    const record = getRecord(name, id, authContext);
    if (!record) {
      return errorResponse(
        `Record "${id}" not found in collection "${name}"`,
        404
      );
    }

    // Add file URLs to response
    const fields = getFields(name);
    const url = new URL(req.url);
    const baseUrl = `${url.protocol}//${url.host}`;
    const recordWithUrls = addFileUrls(record, fields, baseUrl, name);

    return Response.json(recordWithUrls);
  } catch (error) {
    const err = error as Error;
    if (err.message === 'Access denied') {
      return errorResponse(err.message, 403);
    }
    return errorResponse(err.message, mapErrorToStatus(err));
  }
},
```

**Update the records list endpoint to include file URLs:**

In "/api/collections/:name/records" GET handler, update to add file URLs:
```typescript
GET: async (req) => {
  try {
    const { name } = req.params;
    const user = await optionalUser(req);
    const authContext = { isAdmin: false, user };
    const url = new URL(req.url);
    const options = parseQueryOptions(url);
    const result = listRecordsWithQuery(name, options, authContext);

    // Add file URLs to each record in response
    const fields = getFields(name);
    const baseUrl = `${url.protocol}//${url.host}`;
    result.items = addFileUrlsToList(result.items, fields, baseUrl, name);

    return Response.json(result);
  } catch (error) {
    const err = error as Error;
    if (err.message === 'Access denied') {
      return errorResponse(err.message, 403);
    }
    return errorResponse(err.message, mapErrorToStatus(err));
  }
},
```

**Update record create/update responses to include file URLs:**

In POST handler for "/api/collections/:name/records":
```typescript
// After getting the record, before return:
const fields = getFields(name);
const url = new URL(req.url);
const baseUrl = `${url.protocol}//${url.host}`;
const recordWithUrls = addFileUrls(record, fields, baseUrl, name);
return Response.json(recordWithUrls, { status: 201 });
```

Apply same pattern to PATCH handler.
  </action>
  <verify>Run `bun build src/api/server.ts` - no TypeScript errors</verify>
  <done>File serving endpoint exists at /api/files/:collection/:record/:filename, file URLs included in GET/POST/PATCH responses</done>
</task>

</tasks>

<verification>
1. `bun build src/storage/urls.ts` - no errors
2. `bun build src/api/server.ts` - no errors
3. Manual test: GET /api/files/posts/123/image.jpg returns file content
4. Manual test: GET /api/collections/posts/records/123 returns URLs for file fields
</verification>

<success_criteria>
- GET /api/files/:collection/:record/:filename serves file content
- File serving checks record view permissions first
- Missing file returns 404, access denied returns 403
- Content-Type is automatically set by Bun.file()
- Record GET returns file URLs instead of raw filenames
- Records list returns file URLs for all records
- Record create/update responses include file URLs
</success_criteria>

<output>
After completion, create `.planning/phases/11-file-uploads/11-05-SUMMARY.md`
</output>
