---
phase: 11-file-uploads
plan: 05
type: execute
wave: 3
depends_on: ["11-02", "11-04"]
files_modified:
  - src/storage/urls.ts
  - src/api/server.ts
autonomous: true

must_haves:
  truths:
    - "Files can be downloaded via GET /api/files/{collection}/{record}/{filename}"
    - "File serving respects collection view rules"
    - "Content-Type is automatically detected from file extension"
    - "File URLs are included in API responses for file fields"
  artifacts:
    - path: "src/storage/urls.ts"
      provides: "File URL generation helpers"
      exports: ["getFileUrl", "addFileUrls"]
    - path: "src/api/server.ts"
      provides: "File serving endpoint"
      contains: "/api/files/:collection/:record/:filename"
  key_links:
    - from: "src/api/server.ts"
      to: "Bun.file"
      via: "file serving"
      pattern: "Bun\\.file"
    - from: "src/api/server.ts"
      to: "src/storage/files.ts"
      via: "storage path functions"
      pattern: "getFilePath"
---

<objective>
Implement file serving endpoint and URL generation helper for API responses.

Purpose: FILE-04 (file serving endpoint) and FILE-10 (file URL generation) enable downloading uploaded files and receiving full URLs in API responses instead of raw filenames.

Output: File serving endpoint at `/api/files/{collection}/{record}/{filename}` with access control, and URL helper that transforms file fields in record responses.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-file-uploads/11-RESEARCH.md

@src/api/server.ts
@src/storage/files.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create URL generation helpers</name>
  <files>src/storage/urls.ts</files>
  <action>
Create module for file URL generation.

**src/storage/urls.ts:**
```typescript
import type { Field } from "../types/collection";

/**
 * Generate the URL for accessing a file.
 *
 * @param baseUrl - Base URL of the server (e.g., "http://localhost:8090")
 * @param collectionName - Name of the collection
 * @param recordId - ID of the record
 * @param filename - Stored filename
 * @returns Full URL to access the file
 */
export function getFileUrl(
  baseUrl: string,
  collectionName: string,
  recordId: string,
  filename: string
): string {
  return `${baseUrl}/api/files/${collectionName}/${recordId}/${encodeURIComponent(filename)}`;
}

/**
 * Add file URLs to a record response.
 * Transforms file field values from filenames to full URLs.
 *
 * For single-file fields, transforms "filename.jpg" to "http://host/api/files/..."
 * For multi-file fields, transforms ["a.jpg", "b.jpg"] to ["http://...", "http://..."]
 *
 * @param record - The record object
 * @param fields - Field definitions for the collection
 * @param baseUrl - Base URL of the server
 * @param collectionName - Name of the collection
 * @returns Record with file fields transformed to URLs
 */
export function addFileUrls(
  record: Record<string, unknown>,
  fields: Field[],
  baseUrl: string,
  collectionName: string
): Record<string, unknown> {
  const result = { ...record };
  const recordId = result.id as string;

  for (const field of fields) {
    if (field.type !== "file") continue;

    const value = result[field.name];
    if (!value) continue;

    if (Array.isArray(value)) {
      // Multiple files - transform each to URL
      result[field.name] = value.map((filename) =>
        typeof filename === "string"
          ? getFileUrl(baseUrl, collectionName, recordId, filename)
          : filename
      );
    } else if (typeof value === "string") {
      // Single file - transform to URL
      result[field.name] = getFileUrl(baseUrl, collectionName, recordId, value);
    }
  }

  return result;
}

/**
 * Transform multiple records to include file URLs.
 *
 * @param records - Array of records
 * @param fields - Field definitions for the collection
 * @param baseUrl - Base URL of the server
 * @param collectionName - Name of the collection
 * @returns Records with file fields transformed to URLs
 */
export function addFileUrlsToList(
  records: Record<string, unknown>[],
  fields: Field[],
  baseUrl: string,
  collectionName: string
): Record<string, unknown>[] {
  return records.map((record) =>
    addFileUrls(record, fields, baseUrl, collectionName)
  );
}
```
  </action>
  <verify>Run `bun build src/storage/urls.ts` - no TypeScript errors</verify>
  <done>getFileUrl, addFileUrls, addFileUrlsToList exported</done>
</task>

<task type="auto">
  <name>Task 2: Add file serving endpoint and integrate URLs in responses</name>
  <files>src/api/server.ts</files>
  <action>
Add file serving endpoint and update record responses to include file URLs.

**Add imports at top of src/api/server.ts:**
```typescript
import { getFilePath, fileExists } from "../storage/files";
import { addFileUrls, addFileUrlsToList } from "../storage/urls";
```

**Add new route for file serving (add to routes object):**
```typescript
// File serving endpoint
"/api/files/:collection/:record/:filename": {
  /**
   * GET /api/files/:collection/:record/:filename
   * Serve a file from storage with access control
   * Respects collection view rules (uses same auth as record view)
   */
  GET: async (req) => {
    try {
      const { collection, record: recordId, filename } = req.params;
      const user = await optionalUser(req);
      const authContext = { isAdmin: false, user };

      // Verify record exists and user can view it
      // This enforces collection view rules for file access
      const recordData = getRecord(collection, recordId, authContext);
      if (!recordData) {
        return errorResponse("Not found", 404);
      }

      // Check file exists
      const exists = await fileExists(collection, recordId, filename);
      if (!exists) {
        return errorResponse("File not found", 404);
      }

      // Get file path and serve
      const filePath = getFilePath(collection, recordId, filename);
      const file = Bun.file(filePath);

      // Return file - Bun automatically sets Content-Type from extension
      return new Response(file);
    } catch (error) {
      const err = error as Error;
      if (err.message === "Access denied") {
        return errorResponse(err.message, 403);
      }
      return errorResponse(err.message, mapErrorToStatus(err));
    }
  },
},
```

**Update GET /api/collections/:name/records (list endpoint) to include file URLs:**

Replace the entire GET handler for "/api/collections/:name/records":
```typescript
/**
 * GET /api/collections/:name/records
 * List all records in a collection with optional query filters
 * Supports pagination, sorting, filtering
 * Respects collection view rules
 * File field values are transformed to full URLs
 */
GET: async (req) => {
  try {
    const { name } = req.params;
    const user = await optionalUser(req);
    const authContext = { isAdmin: false, user };
    const url = new URL(req.url);
    const options = parseQueryOptions(url);
    const result = listRecordsWithQuery(name, options, authContext);

    // Add file URLs to each record in response
    const fields = getFields(name);
    const baseUrl = `${url.protocol}//${url.host}`;
    result.items = addFileUrlsToList(result.items, fields, baseUrl, name);

    return Response.json(result);
  } catch (error) {
    const err = error as Error;
    if (err.message === 'Access denied') {
      return errorResponse(err.message, 403);
    }
    return errorResponse(err.message, mapErrorToStatus(err));
  }
},
```

**Update GET /api/collections/:name/records/:id (single record) to include file URLs:**

Replace the entire GET handler for "/api/collections/:name/records/:id":
```typescript
/**
 * GET /api/collections/:name/records/:id
 * Get a single record by ID
 * Respects collection view rules
 * File field values are transformed to full URLs
 */
GET: async (req) => {
  try {
    const { name, id } = req.params;
    const user = await optionalUser(req);
    const authContext = { isAdmin: false, user };
    const record = getRecord(name, id, authContext);
    if (!record) {
      return errorResponse(
        `Record "${id}" not found in collection "${name}"`,
        404
      );
    }

    // Add file URLs to response
    const fields = getFields(name);
    const url = new URL(req.url);
    const baseUrl = `${url.protocol}//${url.host}`;
    const recordWithUrls = addFileUrls(record, fields, baseUrl, name);

    return Response.json(recordWithUrls);
  } catch (error) {
    const err = error as Error;
    if (err.message === 'Access denied') {
      return errorResponse(err.message, 403);
    }
    return errorResponse(err.message, mapErrorToStatus(err));
  }
},
```

**Update POST /api/collections/:name/records to include file URLs in response:**

Replace the entire POST handler for "/api/collections/:name/records":
```typescript
/**
 * POST /api/collections/:name/records
 * Create a new record in a collection (with lifecycle hooks)
 * Supports both JSON and multipart/form-data for file uploads
 * Respects collection create rules
 * File field values are transformed to full URLs in response
 */
POST: async (req) => {
  try {
    const { name } = req.params;
    const user = await optionalUser(req);
    const authContext = { isAdmin: false, user };

    let record: Record<string, unknown>;

    if (isMultipartRequest(req)) {
      // Handle multipart form data (with files)
      const { data, files } = await parseMultipartRequest(req);
      record = await createRecordWithFiles(
        name,
        data,
        files,
        hookManager,
        req,
        authContext
      );
    } else {
      // Handle JSON request (no files)
      const body = await req.json();
      record = await createRecordWithHooks(name, body, hookManager, req, authContext);
    }

    // Add file URLs to response
    const fields = getFields(name);
    const url = new URL(req.url);
    const baseUrl = `${url.protocol}//${url.host}`;
    const recordWithUrls = addFileUrls(record, fields, baseUrl, name);

    return Response.json(recordWithUrls, { status: 201 });
  } catch (error) {
    const err = error as Error;
    if (err.message === 'Access denied') {
      return errorResponse(err.message, 403);
    }
    return errorResponse(err.message, mapErrorToStatus(err));
  }
},
```

**Update PATCH /api/collections/:name/records/:id to include file URLs in response:**

Replace the entire PATCH handler for "/api/collections/:name/records/:id":
```typescript
/**
 * PATCH /api/collections/:name/records/:id
 * Update a record by ID (with lifecycle hooks)
 * Supports both JSON and multipart/form-data for file uploads
 * Respects collection update rules
 * File field values are transformed to full URLs in response
 */
PATCH: async (req) => {
  try {
    const { name, id } = req.params;
    const user = await optionalUser(req);
    const authContext = { isAdmin: false, user };

    let record: Record<string, unknown>;

    if (isMultipartRequest(req)) {
      // Handle multipart form data (with files)
      const { data, files } = await parseMultipartRequest(req);
      record = await updateRecordWithFiles(
        name,
        id,
        data,
        files,
        hookManager,
        req,
        authContext
      );
    } else {
      // Handle JSON request (no files)
      const body = await req.json();
      record = await updateRecordWithHooks(name, id, body, hookManager, req, authContext);
    }

    // Add file URLs to response
    const fields = getFields(name);
    const url = new URL(req.url);
    const baseUrl = `${url.protocol}//${url.host}`;
    const recordWithUrls = addFileUrls(record, fields, baseUrl, name);

    return Response.json(recordWithUrls);
  } catch (error) {
    const err = error as Error;
    if (err.message === 'Access denied') {
      return errorResponse(err.message, 403);
    }
    return errorResponse(err.message, mapErrorToStatus(err));
  }
},
```

Note: The POST and PATCH handlers now:
1. Declare `record` variable at the start
2. Assign to it in the if/else branches
3. Add file URLs AFTER getting the record (using shared variables)
4. Return the record with URLs

This ensures proper variable scoping and that all responses include file URLs.
  </action>
  <verify>Run `bun build src/api/server.ts` - no TypeScript errors</verify>
  <done>File serving endpoint exists at /api/files/:collection/:record/:filename, file URLs included in GET/POST/PATCH responses with proper variable scoping</done>
</task>

</tasks>

<verification>
1. `bun build src/storage/urls.ts` - no errors
2. `bun build src/api/server.ts` - no errors
3. Manual test: GET /api/files/posts/123/image.jpg returns file content
4. Manual test: GET /api/collections/posts/records/123 returns URLs for file fields
5. Manual test: POST /api/collections/posts/records returns created record with file URLs
6. Manual test: PATCH /api/collections/posts/records/123 returns updated record with file URLs
</verification>

<success_criteria>
- GET /api/files/:collection/:record/:filename serves file content
- File serving checks record view permissions first
- Missing file returns 404, access denied returns 403
- Content-Type is automatically set by Bun.file()
- Record GET returns file URLs instead of raw filenames
- Records list returns file URLs for all records
- Record POST response includes file URLs
- Record PATCH response includes file URLs
</success_criteria>

<output>
After completion, create `.planning/phases/11-file-uploads/11-05-SUMMARY.md`
</output>
