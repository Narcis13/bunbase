---
phase: 11-file-uploads
plan: 06
type: execute
wave: 3
depends_on: ["11-02", "11-04"]
files_modified:
  - src/storage/hooks.ts
  - src/api/server.ts
  - src/storage/hooks.test.ts
autonomous: true

must_haves:
  truths:
    - "Files are automatically deleted when record is deleted"
    - "File cleanup happens after successful record deletion"
    - "Cleanup errors are logged but don't prevent record deletion"
  artifacts:
    - path: "src/storage/hooks.ts"
      provides: "File cleanup hook registration"
      exports: ["registerFileCleanupHook"]
    - path: "src/storage/hooks.test.ts"
      provides: "Hook tests"
      min_lines: 30
  key_links:
    - from: "src/storage/hooks.ts"
      to: "src/storage/files.ts"
      via: "deleteRecordFiles import"
      pattern: "deleteRecordFiles"
    - from: "src/api/server.ts"
      to: "src/storage/hooks.ts"
      via: "hook registration on server start"
      pattern: "registerFileCleanupHook"
---

<objective>
Implement automatic file cleanup when records are deleted.

Purpose: FILE-09 requires files to be deleted when their parent record is deleted. This prevents orphaned files accumulating on disk. The cleanup uses the existing afterDelete hook pattern.

Output: File cleanup hook that deletes the record's storage directory after deletion, registered at server startup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-file-uploads/11-RESEARCH.md

@src/core/hooks.ts
@src/api/server.ts
@src/storage/files.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file cleanup hook module</name>
  <files>src/storage/hooks.ts</files>
  <action>
Create module for file-related hooks.

**src/storage/hooks.ts:**
```typescript
/**
 * File storage hooks for automatic cleanup.
 */

import { deleteRecordFiles } from "./files";
import { getFields } from "../core/schema";
import type { HookManager } from "../core/hooks";

/**
 * Check if a collection has any file fields.
 */
function hasFileFields(collectionName: string): boolean {
  try {
    const fields = getFields(collectionName);
    return fields.some((f) => f.type === "file");
  } catch {
    // Collection might not exist, no file fields
    return false;
  }
}

/**
 * Register the file cleanup hook that deletes files when records are deleted.
 *
 * This is a global afterDelete hook that:
 * 1. Checks if the collection has file fields
 * 2. If so, deletes the record's storage directory
 * 3. Logs errors but doesn't throw (cleanup failures shouldn't block deletion)
 *
 * @param hooks - HookManager instance to register with
 * @returns Unsubscribe function
 */
export function registerFileCleanupHook(hooks: HookManager): () => void {
  return hooks.on("afterDelete", async (ctx, next) => {
    // Only attempt cleanup for collections with file fields
    if (hasFileFields(ctx.collection)) {
      try {
        await deleteRecordFiles(ctx.collection, ctx.id);
      } catch (error) {
        // Log but don't throw - record is already deleted
        // Cleanup failure shouldn't cause an error response
        console.error(
          `Failed to delete files for record ${ctx.collection}/${ctx.id}:`,
          error
        );
      }
    }

    // Continue to next handler
    await next();
  });
}
```
  </action>
  <verify>Run `bun build src/storage/hooks.ts` - no TypeScript errors</verify>
  <done>registerFileCleanupHook exported, uses afterDelete hook, handles errors gracefully</done>
</task>

<task type="auto">
  <name>Task 2: Register cleanup hook in server startup</name>
  <files>src/api/server.ts</files>
  <action>
Register the file cleanup hook when the server starts.

**Add import at top of src/api/server.ts:**
```typescript
import { registerFileCleanupHook } from "../storage/hooks";
```

**Update startServer function to register the hook:**

Find the `startServer` function and add hook registration after creating the hook manager:

```typescript
export async function startServer(
  port: number = 8090,
  dbPath: string = "bunbase.db",
  hooks?: HookManager,
  smtpConfig?: SmtpConfig | null
) {
  initDatabase(dbPath);

  // Create hook manager if not provided
  const hookManager = hooks ?? new HookManager();

  // Register file cleanup hook for automatic file deletion
  registerFileCleanupHook(hookManager);

  // Initialize email service if configured
  if (smtpConfig) {
    initEmailService(smtpConfig);
    console.log(`Email service configured (${smtpConfig.host}:${smtpConfig.port})`);
  }

  // ... rest of function
```

Also update `createServer` to use the same hook manager reference.

The key change is ensuring registerFileCleanupHook is called with the hookManager before the server starts handling requests.

**Updated createServer signature:**
The hookManager needs to be properly initialized before being passed to createServer. Update the flow:

```typescript
export async function startServer(
  port: number = 8090,
  dbPath: string = "bunbase.db",
  hooks?: HookManager,
  smtpConfig?: SmtpConfig | null
) {
  initDatabase(dbPath);

  // Create hook manager if not provided
  const hookManager = hooks ?? new HookManager();

  // Register file cleanup hook for automatic file deletion on record delete
  registerFileCleanupHook(hookManager);

  // Initialize email service if configured
  if (smtpConfig) {
    initEmailService(smtpConfig);
    console.log(`Email service configured (${smtpConfig.host}:${smtpConfig.port})`);
  }

  // Create initial admin if none exists
  const existingAdmin = getAdminByEmail("admin@bunbase.local");
  if (!existingAdmin) {
    const password = Bun.env.BUNBASE_ADMIN_PASSWORD || generateRandomPassword();
    await createAdmin("admin@bunbase.local", password);
    if (!Bun.env.BUNBASE_ADMIN_PASSWORD) {
      console.log(`Initial admin created: admin@bunbase.local`);
      console.log(`Generated password: ${password}`);
      console.log(
        `Set BUNBASE_ADMIN_PASSWORD env var to use a specific password.`
      );
    }
  }

  const server = createServer(port, hookManager);
  console.log(`BunBase running at http://localhost:${port}`);
  return server;
}
```
  </action>
  <verify>Run `bun build src/api/server.ts` - no TypeScript errors</verify>
  <done>registerFileCleanupHook called in startServer, hook registered before server handles requests</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for file cleanup hook</name>
  <files>src/storage/hooks.test.ts</files>
  <action>
Create tests for the file cleanup hook.

**src/storage/hooks.test.ts:**
```typescript
import { test, expect, describe, beforeEach, afterEach, mock } from "bun:test";
import { rm } from "node:fs/promises";
import { HookManager } from "../core/hooks";
import { registerFileCleanupHook } from "./hooks";
import { saveFile, listRecordFiles } from "./files";
import { initDatabase, closeDatabase } from "../core/database";
import { createCollection, deleteCollection } from "../core/schema";
import { createRecord, deleteRecordWithHooks } from "../core/records";

const TEST_DB = "./test-hooks.db";
const TEST_STORAGE_DIR = "./test-hooks-storage";

describe("file cleanup hook", () => {
  let hooks: HookManager;

  beforeEach(async () => {
    // Set up test environment
    process.env.BUNBASE_STORAGE_DIR = TEST_STORAGE_DIR;
    await rm(TEST_STORAGE_DIR, { recursive: true, force: true });
    await rm(TEST_DB, { force: true });

    // Initialize database
    initDatabase(TEST_DB);

    // Create hook manager and register cleanup hook
    hooks = new HookManager();
    registerFileCleanupHook(hooks);
  });

  afterEach(async () => {
    closeDatabase();
    await rm(TEST_STORAGE_DIR, { recursive: true, force: true });
    await rm(TEST_DB, { force: true });
    delete process.env.BUNBASE_STORAGE_DIR;
  });

  test("deletes files when record with file field is deleted", async () => {
    // Create collection with file field
    createCollection("posts", [
      { name: "title", type: "text", required: true },
      { name: "image", type: "file", required: false },
    ]);

    // Create record
    const record = createRecord("posts", { title: "Test Post" });

    // Save a file for the record
    const file = new File(["test content"], "photo.jpg", { type: "image/jpeg" });
    await saveFile("posts", record.id as string, file);

    // Verify file exists
    const filesBefore = await listRecordFiles("posts", record.id as string);
    expect(filesBefore.length).toBe(1);

    // Delete record (triggers cleanup hook)
    await deleteRecordWithHooks("posts", record.id as string, hooks);

    // Verify files are deleted
    const filesAfter = await listRecordFiles("posts", record.id as string);
    expect(filesAfter.length).toBe(0);
  });

  test("does not error for collections without file fields", async () => {
    // Create collection WITHOUT file fields
    createCollection("notes", [
      { name: "content", type: "text", required: true },
    ]);

    // Create and delete record
    const record = createRecord("notes", { content: "Test note" });

    // Should not throw
    await deleteRecordWithHooks("notes", record.id as string, hooks);
  });

  test("continues chain even if cleanup fails", async () => {
    // Create collection with file field
    createCollection("docs", [
      { name: "name", type: "text", required: true },
      { name: "file", type: "file", required: false },
    ]);

    const record = createRecord("docs", { name: "Test Doc" });

    // Mock deleteRecordFiles to throw
    const originalConsoleError = console.error;
    const errorLogs: unknown[] = [];
    console.error = (...args: unknown[]) => errorLogs.push(args);

    // Even with potential errors, deletion should succeed
    await deleteRecordWithHooks("docs", record.id as string, hooks);

    console.error = originalConsoleError;
    // Record should be deleted even if file cleanup had issues
  });

  test("returns unsubscribe function", async () => {
    const newHooks = new HookManager();
    const unsubscribe = registerFileCleanupHook(newHooks);

    expect(typeof unsubscribe).toBe("function");

    // After unsubscribe, hook should not run
    unsubscribe();

    // Create and delete - should work without cleanup hook
    createCollection("temp", [
      { name: "data", type: "text", required: true },
      { name: "attachment", type: "file", required: false },
    ]);

    const record = createRecord("temp", { data: "test" });
    await deleteRecordWithHooks("temp", record.id as string, newHooks);
    // No errors means success
  });
});
```
  </action>
  <verify>Run `bun test src/storage/hooks.test.ts` - all tests pass</verify>
  <done>Hook tests pass: cleanup runs on delete, handles missing files, errors don't block deletion</done>
</task>

</tasks>

<verification>
1. `bun build src/storage/hooks.ts` - no errors
2. `bun build src/api/server.ts` - no errors
3. `bun test src/storage/hooks.test.ts` - all tests pass
4. Manual test: Delete record with files, verify files are removed from disk
</verification>

<success_criteria>
- registerFileCleanupHook registers afterDelete hook
- Hook only runs for collections with file fields
- Hook deletes entire record storage directory
- Cleanup errors are logged but don't prevent deletion
- Hook is registered in startServer before handling requests
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-file-uploads/11-06-SUMMARY.md`
</output>
