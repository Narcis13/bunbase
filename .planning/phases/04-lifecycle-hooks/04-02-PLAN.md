---
phase: 04-lifecycle-hooks
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/core/records.ts
  - src/api/server.ts
  - src/api/server.test.ts
autonomous: true

must_haves:
  truths:
    - "POST endpoint executes beforeCreate and afterCreate hooks"
    - "PATCH endpoint executes beforeUpdate and afterUpdate hooks"
    - "DELETE endpoint executes beforeDelete and afterDelete hooks"
    - "Before hook errors return 400 and cancel the operation"
    - "After hook errors are logged but request succeeds"
    - "Hooks receive request context (method, path, headers)"
  artifacts:
    - path: "src/core/records.ts"
      provides: "Hook-aware record operations"
      exports: ["createRecordWithHooks", "updateRecordWithHooks", "deleteRecordWithHooks"]
    - path: "src/api/server.ts"
      provides: "Server with hook integration"
      contains: "hooks.trigger"
    - path: "src/api/server.test.ts"
      provides: "Integration tests for hooks in HTTP endpoints"
      min_lines: 50
  key_links:
    - from: "src/api/server.ts"
      to: "src/core/hooks.ts"
      via: "HookManager import and trigger calls"
      pattern: "import.*HookManager.*from.*hooks"
    - from: "src/core/records.ts"
      to: "src/core/hooks.ts"
      via: "Optional hooks parameter"
      pattern: "HookManager"
---

<objective>
Integrate lifecycle hooks into the HTTP server endpoints for create, update, and delete operations.

Purpose: Connects the HookManager from Plan 01 to the actual CRUD operations, enabling developers to register custom logic that executes at specific points in the request lifecycle.

Output: Server endpoints that trigger appropriate hooks with full request context, proper error handling (before cancels, after logs), and integration tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-lifecycle-hooks/04-RESEARCH.md
@.planning/phases/04-lifecycle-hooks/04-01-SUMMARY.md
@src/core/records.ts
@src/api/server.ts
@src/core/hooks.ts
@src/types/hooks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hook-aware record operations</name>
  <files>src/core/records.ts</files>
  <action>
Add new exported functions that wrap existing operations with hook support. Keep existing functions unchanged for backward compatibility.

1. Import HookManager and context types:
```typescript
import { HookManager } from "./hooks";
import type { BeforeCreateContext, AfterCreateContext, BeforeUpdateContext, AfterUpdateContext, BeforeDeleteContext, AfterDeleteContext } from "../types/hooks";
```

2. Add helper to build request context:
```typescript
function buildRequestContext(req?: Request): { method: string; path: string; headers: Headers } | undefined {
  if (!req) return undefined;
  return {
    method: req.method,
    path: new URL(req.url).pathname,
    headers: req.headers,
  };
}
```

3. Add `createRecordWithHooks(collectionName, data, hooks, request?)`:
- Build BeforeCreateContext with collection, data (copy), and optional request context
- Call `await hooks.trigger('beforeCreate', beforeContext)`
- Use `beforeContext.data` for createRecord (allows hooks to modify data)
- Build AfterCreateContext with collection, record, and request context
- Wrap afterCreate trigger in try/catch, log errors with `console.error('afterCreate hook error:', error)`
- Return record

4. Add `updateRecordWithHooks(collectionName, id, data, hooks, request?)`:
- Fetch existing record first via getRecord
- Build BeforeUpdateContext with collection, id, data (copy), existing, and request
- Call `await hooks.trigger('beforeUpdate', beforeContext)`
- Use `beforeContext.data` for updateRecord
- Build AfterUpdateContext with collection, record, request
- Wrap afterUpdate trigger in try/catch, log errors
- Return updated record

5. Add `deleteRecordWithHooks(collectionName, id, hooks, request?)`:
- Fetch existing record first via getRecord
- Build BeforeDeleteContext with collection, id, existing, request
- Call `await hooks.trigger('beforeDelete', beforeContext)`
- Call deleteRecord
- Build AfterDeleteContext with collection, id, request
- Wrap afterDelete trigger in try/catch, log errors
- Return void

Key: Copy data objects before passing to hooks to allow safe mutation. After hooks swallow errors (log only).
  </action>
  <verify>TypeScript compiles: `bunx tsc --noEmit`</verify>
  <done>Three new hook-aware functions exported alongside existing functions</done>
</task>

<task type="auto">
  <name>Task 2: Wire hooks into server endpoints</name>
  <files>src/api/server.ts</files>
  <action>
Update server.ts to use hook-aware functions and expose hooks for registration:

1. Add imports:
```typescript
import { HookManager } from "../core/hooks";
import {
  createRecordWithHooks,
  updateRecordWithHooks,
  deleteRecordWithHooks,
} from "../core/records";
```

2. Update `createServer` function signature to accept optional hooks parameter:
```typescript
export function createServer(port: number = 8090, hooks?: HookManager) {
  // Create default hooks instance if not provided
  const hookManager = hooks ?? new HookManager();
```

3. Update POST handler to use createRecordWithHooks:
```typescript
POST: async (req) => {
  try {
    const { name } = req.params;
    const body = await req.json();
    const record = await createRecordWithHooks(name, body, hookManager, req);
    return Response.json(record, { status: 201 });
  } catch (error) {
    const err = error as Error;
    return errorResponse(err.message, mapErrorToStatus(err));
  }
},
```

4. Update PATCH handler to use updateRecordWithHooks:
```typescript
PATCH: async (req) => {
  try {
    const { name, id } = req.params;
    const body = await req.json();
    const record = await updateRecordWithHooks(name, id, body, hookManager, req);
    return Response.json(record);
  } catch (error) {
    const err = error as Error;
    return errorResponse(err.message, mapErrorToStatus(err));
  }
},
```

5. Update DELETE handler to use deleteRecordWithHooks:
```typescript
DELETE: async (req) => {
  try {
    const { name, id } = req.params;
    await deleteRecordWithHooks(name, id, hookManager, req);
    return new Response(null, { status: 204 });
  } catch (error) {
    const err = error as Error;
    return errorResponse(err.message, mapErrorToStatus(err));
  }
},
```

6. Update `startServer` to accept and pass hooks:
```typescript
export function startServer(port: number = 8090, dbPath: string = "bunbase.db", hooks?: HookManager) {
  initDatabase(dbPath);
  const server = createServer(port, hooks);
  console.log(`BunBase running at http://localhost:${port}`);
  return server;
}
```

7. Add convenience export for HookManager:
```typescript
export { HookManager } from "../core/hooks";
```

Note: GET endpoints don't need hooks (read operations don't have lifecycle events in v0.1).
  </action>
  <verify>TypeScript compiles: `bunx tsc --noEmit`</verify>
  <done>Server endpoints use hook-aware functions and accept HookManager parameter</done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests</name>
  <files>src/api/server.test.ts</files>
  <action>
Add integration tests to existing server.test.ts that verify hook execution through HTTP:

Add new describe block for hooks:

```typescript
describe("Lifecycle Hooks", () => {
  // ... tests
});
```

Tests to add:

1. **beforeCreate hook modifies data:**
- Register hook that adds a field (e.g., `ctx.data.hookAdded = true`)
- POST to create record
- Verify response contains the added field

2. **beforeCreate hook cancels operation:**
- Register hook that throws `new Error("Blocked by hook")`
- POST to create record
- Verify 400 response with error message
- Verify record was NOT created (GET returns 404)

3. **afterCreate hook executes after success:**
- Register afterCreate hook that sets a flag (use closure variable)
- POST to create record
- Verify flag was set after request completes

4. **afterCreate hook error doesn't fail request:**
- Register afterCreate hook that throws
- POST to create record
- Verify 201 response (success despite hook error)
- Verify record WAS created

5. **beforeUpdate hook receives existing record:**
- Create a record
- Register beforeUpdate hook that checks `ctx.existing` has original values
- PATCH the record
- Verify hook saw correct existing data (use closure to capture)

6. **beforeDelete hook can cancel deletion:**
- Create a record
- Register beforeDelete hook that throws "Cannot delete"
- DELETE the record
- Verify 400 response
- Verify record still exists (GET returns 200)

7. **Hooks receive request context:**
- Register hook that captures `ctx.request`
- Make request with custom header
- Verify hook received method, path, and headers

8. **Collection-scoped hooks only run for matching collection:**
- Register hook for "users" collection
- Create record in "posts" collection
- Verify hook did NOT run (use closure flag)

Each test should:
- Create fresh HookManager instance
- Pass it to createServer
- Clean up after (stop server, etc.)

Use the existing test patterns from server.test.ts for setup/teardown.
  </action>
  <verify>All tests pass: `bun test src/api/server.test.ts`</verify>
  <done>Minimum 8 integration tests covering all hook events and error semantics</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Existing tests still pass: `bun test`
3. New hook integration tests pass
4. Before hooks can modify data and cancel operations
5. After hooks log errors but don't fail requests
6. Request context available in hooks
</verification>

<success_criteria>
- All 8 HOOK requirements covered:
  - HOOK-01: beforeCreate via createRecordWithHooks
  - HOOK-02: afterCreate via createRecordWithHooks
  - HOOK-03: beforeUpdate via updateRecordWithHooks
  - HOOK-04: afterUpdate via updateRecordWithHooks
  - HOOK-05: beforeDelete via deleteRecordWithHooks
  - HOOK-06: afterDelete via deleteRecordWithHooks
  - HOOK-07: Before hooks cancel by throwing (returns 400)
  - HOOK-08: Context includes record, collection, and request
- Server exposes HookManager for external registration
- All tests pass (existing + new)
</success_criteria>

<output>
After completion, create `.planning/phases/04-lifecycle-hooks/04-02-SUMMARY.md`
</output>
