---
phase: 04-lifecycle-hooks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/hooks.ts
  - src/core/hooks.ts
  - src/core/hooks.test.ts
autonomous: true

must_haves:
  truths:
    - "HookManager can register handlers for all 6 hook events"
    - "Handlers execute in registration order (FIFO)"
    - "Collection-scoped handlers only run for matching collections"
    - "Before hooks can cancel by throwing or not calling next()"
    - "Multiple hooks chain correctly via next() function"
  artifacts:
    - path: "src/types/hooks.ts"
      provides: "Hook event types and context interfaces"
      exports: ["HookEventMap", "BeforeCreateContext", "AfterCreateContext", "BeforeUpdateContext", "AfterUpdateContext", "BeforeDeleteContext", "AfterDeleteContext", "HookHandler", "Next"]
    - path: "src/core/hooks.ts"
      provides: "HookManager class with middleware chain execution"
      exports: ["HookManager"]
    - path: "src/core/hooks.test.ts"
      provides: "Unit tests for hook registration and execution"
      min_lines: 100
  key_links:
    - from: "src/core/hooks.ts"
      to: "src/types/hooks.ts"
      via: "type imports"
      pattern: "import.*from.*types/hooks"
---

<objective>
Create the HookManager core module with type-safe event registration and middleware chain execution.

Purpose: Provides the foundation for lifecycle hooks that will be integrated into CRUD operations. The HookManager follows PocketBase's proven middleware pattern where hooks execute sequentially with `next()` control.

Output: HookManager class with full test coverage for registration, execution order, collection scoping, and cancellation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-lifecycle-hooks/04-RESEARCH.md
@src/types/collection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hook type definitions</name>
  <files>src/types/hooks.ts</files>
  <action>
Create hook type definitions following the research patterns:

1. Define `Next` type as `() => Promise<void>`

2. Define `HookHandler<T>` as `(context: T, next: Next) => Promise<void> | void`

3. Define base context interface:
```typescript
interface BaseHookContext {
  collection: string;
  request?: {
    method: string;
    path: string;
    headers: Headers;
  };
}
```

4. Define context interfaces for each hook event extending BaseHookContext:
- `BeforeCreateContext`: adds `data: Record<string, unknown>`
- `AfterCreateContext`: adds `record: Record<string, unknown>`
- `BeforeUpdateContext`: adds `id: string`, `data: Record<string, unknown>`, `existing: Record<string, unknown>`
- `AfterUpdateContext`: adds `record: Record<string, unknown>`
- `BeforeDeleteContext`: adds `id: string`, `existing: Record<string, unknown>`
- `AfterDeleteContext`: adds `id: string`

5. Define `HookEventMap` type mapping event names to context types:
```typescript
type HookEventMap = {
  beforeCreate: BeforeCreateContext;
  afterCreate: AfterCreateContext;
  beforeUpdate: BeforeUpdateContext;
  afterUpdate: AfterUpdateContext;
  beforeDelete: BeforeDeleteContext;
  afterDelete: AfterDeleteContext;
};
```

6. Export `HookEvent` as `keyof HookEventMap`

All types exported. Include JSDoc comments explaining each context's purpose.
  </action>
  <verify>TypeScript compiles without errors: `bunx tsc --noEmit`</verify>
  <done>All 6 hook event context types defined and exported with clear documentation</done>
</task>

<task type="auto">
  <name>Task 2: Implement HookManager class</name>
  <files>src/core/hooks.ts</files>
  <action>
Implement the HookManager class following the research middleware pattern:

1. Import types from `../types/hooks.ts`

2. Define internal `HandlerEntry<T>` interface:
```typescript
interface HandlerEntry<T> {
  handler: HookHandler<T>;
  collection?: string; // undefined = all collections
}
```

3. Implement `HookManager` class:
- Private `handlers` object storing arrays of HandlerEntry per event
- `on<K extends keyof HookEventMap>(event, handlerOrCollection, handler?)` method:
  - Supports both `on('beforeCreate', handler)` and `on('beforeCreate', 'users', handler)` signatures
  - Returns unsubscribe function `() => void`
  - Preserves insertion order using arrays
- `trigger<K extends keyof HookEventMap>(event, context)` method:
  - Filters handlers to those matching context.collection (or global)
  - Executes as middleware chain via private `executeChain` method
- Private `executeChain<T>(context, handlers[])` method:
  - Recursively calls handlers with context and next function
  - Empty handlers array = immediate return
  - Each handler receives `next` that calls the remaining chain

4. Export `HookManager` class and create default export instance `hooks`

Key behaviors:
- Registration order is execution order (FIFO)
- Global handlers (no collection) run for all collections
- Collection-specific handlers run only for matching collection
- Handlers can throw to abort chain
- Handlers can skip `next()` to silently abort chain
  </action>
  <verify>TypeScript compiles: `bunx tsc --noEmit`</verify>
  <done>HookManager class exports with on(), trigger(), and proper middleware chain execution</done>
</task>

<task type="auto">
  <name>Task 3: Write comprehensive tests</name>
  <files>src/core/hooks.test.ts</files>
  <action>
Create test file using Bun test runner with comprehensive coverage:

```typescript
import { test, expect, describe, beforeEach } from "bun:test";
import { HookManager } from "./hooks";
```

Test groups:

1. **Registration tests:**
- Can register handler for each event type
- Returns unsubscribe function that removes handler
- Multiple handlers can be registered for same event

2. **Execution order tests:**
- Handlers execute in registration order
- Global handlers and collection handlers interleave by registration order
- Later registered handlers execute after earlier ones

3. **Collection scoping tests:**
- Global handler runs for any collection
- Collection-specific handler only runs for matching collection
- Collection-specific handler skipped for non-matching collection
- Mix of global and collection handlers filters correctly

4. **Middleware chain tests:**
- Handler receives context and next function
- Calling next() continues to next handler
- NOT calling next() stops chain silently
- Throwing error stops chain with error
- Context modifications persist through chain

5. **Cancellation tests (HOOK-07):**
- Throwing in before hook propagates error
- Not calling next() silently stops (no error thrown)
- Chain stops at first throw
- After-throw handlers don't execute

6. **Context tests (HOOK-08):**
- BeforeCreate context has collection and data
- AfterCreate context has collection and record
- BeforeUpdate context has collection, id, data, existing
- AfterUpdate context has collection and record
- BeforeDelete context has collection, id, existing
- AfterDelete context has collection and id
- Request context is optional and passes through

Use async/await throughout. Each test should be isolated (new HookManager instance).
  </action>
  <verify>All tests pass: `bun test src/core/hooks.test.ts`</verify>
  <done>Minimum 15 test cases covering registration, execution order, scoping, chaining, and cancellation</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. All tests pass: `bun test src/core/hooks.test.ts`
3. HookManager supports all 6 hook events
4. Middleware chain execution works correctly
5. Collection scoping filters handlers properly
</verification>

<success_criteria>
- HookManager class implemented with type-safe event registration
- Middleware chain pattern with next() function working
- Collection-scoped and global handlers supported
- Before hooks can cancel by throwing or not calling next()
- All tests pass covering the 8 requirements relevant to core hooks
</success_criteria>

<output>
After completion, create `.planning/phases/04-lifecycle-hooks/04-01-SUMMARY.md`
</output>
