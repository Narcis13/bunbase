---
phase: 05-admin-authentication
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/auth/middleware.ts
  - src/auth/middleware.test.ts
  - src/api/server.ts
  - src/api/auth.test.ts
autonomous: true

must_haves:
  truths:
    - "Admin can log in at POST /_/api/auth/login with email/password and receive JWT"
    - "Invalid credentials return 401 Unauthorized"
    - "Protected routes return 401 without valid JWT"
    - "Protected routes succeed with valid JWT in Authorization header"
    - "Admin can change password at POST /_/api/auth/password with valid JWT"
    - "Initial admin is created on first startup if not exists"
  artifacts:
    - path: "src/auth/middleware.ts"
      provides: "Route protection helper"
      exports: ["requireAdmin", "extractBearerToken"]
    - path: "src/api/server.ts"
      provides: "Auth routes and protected route pattern"
      contains: "/_/api/auth/login"
    - path: "src/api/auth.test.ts"
      provides: "Integration tests for auth endpoints"
      min_lines: 80
  key_links:
    - from: "src/auth/middleware.ts"
      to: "src/auth/jwt.ts"
      via: "verifyAdminToken call"
      pattern: "verifyAdminToken"
    - from: "src/api/server.ts"
      to: "src/auth/admin.ts"
      via: "verifyAdminPassword and createAdminToken"
      pattern: "(verifyAdminPassword|createAdminToken)"
    - from: "src/api/server.ts"
      to: "/_/api/auth"
      via: "route definitions"
      pattern: "/_/api/auth"
---

<objective>
Add route protection middleware and auth HTTP endpoints: login, password change, and a protected test route. Wire initial admin creation on startup.

Purpose: Complete the authentication flow so admins can log in, access protected routes, and change their password.
Output: Working auth endpoints integrated into the HTTP server with comprehensive tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-admin-authentication/05-RESEARCH.md
@.planning/phases/05-admin-authentication/05-01-SUMMARY.md

# Existing modules to integrate with
@src/api/server.ts
@src/auth/admin.ts
@src/auth/jwt.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create route protection middleware</name>
  <files>
    src/auth/middleware.ts
    src/auth/middleware.test.ts
  </files>
  <action>
1. Create src/auth/middleware.ts with these functions:
   ```typescript
   import { verifyAdminToken } from "./jwt";
   import { getAdminById, Admin } from "./admin";

   /**
    * Extract Bearer token from Authorization header.
    */
   export function extractBearerToken(req: Request): string | null {
     const authHeader = req.headers.get("Authorization");
     if (!authHeader?.startsWith("Bearer ")) {
       return null;
     }
     return authHeader.slice(7); // "Bearer ".length === 7
   }

   /**
    * Verify request has valid admin JWT.
    * Returns Admin if valid, or 401 Response if not.
    */
   export async function requireAdmin(req: Request): Promise<Admin | Response> {
     const token = extractBearerToken(req);
     if (!token) {
       return Response.json({ error: "Unauthorized" }, { status: 401 });
     }

     const payload = await verifyAdminToken(token);
     if (!payload) {
       return Response.json({ error: "Unauthorized" }, { status: 401 });
     }

     const admin = getAdminById(payload.adminId);
     if (!admin) {
       return Response.json({ error: "Unauthorized" }, { status: 401 });
     }

     // Return admin without password_hash
     const { password_hash, ...safeAdmin } = admin as any;
     return safeAdmin;
   }
   ```

2. Create src/auth/middleware.test.ts with tests:
   - extractBearerToken returns token from valid Authorization header
   - extractBearerToken returns null for missing header
   - extractBearerToken returns null for non-Bearer auth
   - requireAdmin returns 401 Response when no token
   - requireAdmin returns 401 Response when invalid token
   - requireAdmin returns 401 Response when admin not found
   - requireAdmin returns Admin when valid token and admin exists

   For requireAdmin tests, create a real admin in :memory: database and generate real token.
   Set JWT_SECRET in test environment.
  </action>
  <verify>
    bun test src/auth/middleware.test.ts
  </verify>
  <done>
    Middleware exports extractBearerToken and requireAdmin. requireAdmin returns Admin for valid requests, 401 Response for invalid.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add auth routes to server</name>
  <files>
    src/api/server.ts
    src/api/auth.test.ts
  </files>
  <action>
1. Update src/api/server.ts to add auth routes and initial admin setup:

   Add imports at top:
   ```typescript
   import { createAdmin, verifyAdminPassword, getAdminByEmail, updateAdminPassword } from "../auth/admin";
   import { createAdminToken } from "../auth/jwt";
   import { requireAdmin } from "../auth/middleware";
   ```

   Add new routes in the routes object:
   ```typescript
   // Admin auth routes
   "/_/api/auth/login": {
     POST: async (req) => {
       try {
         const { email, password } = await req.json();
         if (!email || !password) {
           return Response.json({ error: "Email and password required" }, { status: 400 });
         }
         const admin = await verifyAdminPassword(email, password);
         if (!admin) {
           return Response.json({ error: "Invalid credentials" }, { status: 401 });
         }
         const token = await createAdminToken(admin.id);
         return Response.json({ token, admin });
       } catch (error) {
         const err = error as Error;
         return Response.json({ error: err.message }, { status: 400 });
       }
     },
   },

   "/_/api/auth/password": {
     POST: async (req) => {
       const adminOrError = await requireAdmin(req);
       if (adminOrError instanceof Response) return adminOrError;
       const admin = adminOrError;
       try {
         const { newPassword } = await req.json();
         if (!newPassword || newPassword.length < 8) {
           return Response.json({ error: "Password must be at least 8 characters" }, { status: 400 });
         }
         await updateAdminPassword(admin.id, newPassword);
         return Response.json({ message: "Password updated" });
       } catch (error) {
         const err = error as Error;
         return Response.json({ error: err.message }, { status: 400 });
       }
     },
   },

   "/_/api/auth/me": {
     GET: async (req) => {
       const adminOrError = await requireAdmin(req);
       if (adminOrError instanceof Response) return adminOrError;
       return Response.json(adminOrError);
     },
   },
   ```

2. Add initial admin setup in startServer function:
   ```typescript
   export async function startServer(
     port: number = 8090,
     dbPath: string = "bunbase.db",
     hooks?: HookManager
   ) {
     initDatabase(dbPath);

     // Create initial admin if none exists
     const existingAdmin = getAdminByEmail("admin@bunbase.local");
     if (!existingAdmin) {
       const password = Bun.env.BUNBASE_ADMIN_PASSWORD || generateRandomPassword();
       await createAdmin("admin@bunbase.local", password);
       if (!Bun.env.BUNBASE_ADMIN_PASSWORD) {
         console.log(`Initial admin created: admin@bunbase.local`);
         console.log(`Generated password: ${password}`);
         console.log(`Set BUNBASE_ADMIN_PASSWORD env var to use a specific password.`);
       }
     }

     const server = createServer(port, hooks);
     console.log(`BunBase running at http://localhost:${port}`);
     return server;
   }

   function generateRandomPassword(): string {
     const chars = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789";
     let result = "";
     for (let i = 0; i < 16; i++) {
       result += chars[Math.floor(Math.random() * chars.length)];
     }
     return result;
   }
   ```

   Note: startServer becomes async due to createAdmin being async.

3. Create src/api/auth.test.ts with integration tests:
   - POST /_/api/auth/login with valid credentials returns token and admin
   - POST /_/api/auth/login with invalid email returns 401
   - POST /_/api/auth/login with invalid password returns 401
   - POST /_/api/auth/login with missing fields returns 400
   - GET /_/api/auth/me without token returns 401
   - GET /_/api/auth/me with invalid token returns 401
   - GET /_/api/auth/me with valid token returns admin
   - POST /_/api/auth/password without token returns 401
   - POST /_/api/auth/password with valid token changes password
   - POST /_/api/auth/password with short password returns 400
   - Old password fails after password change
   - New password works after password change

   Use createServer with :memory: database. Create admin directly in tests.
   Set JWT_SECRET in test environment.
  </action>
  <verify>
    bun test src/api/auth.test.ts
  </verify>
  <done>
    Auth routes work: login returns JWT, protected routes return 401 without token, password change works with valid token.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite and verify integration</name>
  <files></files>
  <action>
1. Run all tests to ensure no regressions:
   ```bash
   bun test
   ```

2. Manual verification of the complete auth flow:
   ```bash
   # Start server with test password
   JWT_SECRET=test-secret-32-chars-minimum-length BUNBASE_ADMIN_PASSWORD=testpass123 bun run src/api/server.ts &
   sleep 1

   # Login
   curl -X POST http://localhost:8090/_/api/auth/login \
     -H "Content-Type: application/json" \
     -d '{"email":"admin@bunbase.local","password":"testpass123"}'

   # Save token and test protected route
   TOKEN=$(curl -s -X POST http://localhost:8090/_/api/auth/login \
     -H "Content-Type: application/json" \
     -d '{"email":"admin@bunbase.local","password":"testpass123"}' | jq -r '.token')

   curl http://localhost:8090/_/api/auth/me \
     -H "Authorization: Bearer $TOKEN"

   # Test without token (should 401)
   curl http://localhost:8090/_/api/auth/me

   # Change password
   curl -X POST http://localhost:8090/_/api/auth/password \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer $TOKEN" \
     -d '{"newPassword":"newpassword123"}'

   # Kill server
   pkill -f "bun run src/api/server.ts"
   ```

3. Verify all requirements are covered:
   - AUTH-01: Admin can log in at /_/login (using /_/api/auth/login)
   - AUTH-02: System issues JWT token on successful login
   - AUTH-03: All admin UI routes require valid JWT (/_/api/auth/me protected)
   - AUTH-04: Admin can change password through settings (/_/api/auth/password)
  </action>
  <verify>
    bun test
    # All tests pass (should be ~150+ tests total)
  </verify>
  <done>
    Full test suite passes. Manual curl commands demonstrate working auth flow. All 4 AUTH requirements verified.
  </done>
</task>

</tasks>

<verification>
Run complete test suite:
```bash
bun test
```

Expected: All existing tests pass + new auth tests pass.

Manual verification checklist:
1. Login with correct credentials returns JWT token
2. Login with wrong password returns 401
3. GET /_/api/auth/me without token returns 401
4. GET /_/api/auth/me with valid token returns admin
5. Password change with valid token succeeds
6. Old password fails after change
7. New password works after change
</verification>

<success_criteria>
1. POST /_/api/auth/login returns JWT for valid credentials, 401 for invalid
2. Protected routes (/_/api/auth/me, /_/api/auth/password) return 401 without token
3. Protected routes succeed with valid JWT in Authorization: Bearer header
4. Password change endpoint works with valid token
5. Initial admin created on first startup
6. All tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/05-admin-authentication/05-02-SUMMARY.md`
</output>
