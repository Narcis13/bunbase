---
phase: 05-admin-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/auth/admin.ts
  - src/auth/admin.test.ts
  - src/auth/jwt.ts
  - src/auth/jwt.test.ts
  - src/core/database.ts
autonomous: true

user_setup:
  - service: environment
    why: "JWT signing requires a secret key"
    env_vars:
      - name: JWT_SECRET
        source: "Generate with: openssl rand -base64 32"
      - name: BUNBASE_ADMIN_PASSWORD
        source: "Initial admin password (optional - auto-generated if not set)"

must_haves:
  truths:
    - "Admin record can be created with email and password"
    - "Password is stored as argon2id hash, never plaintext"
    - "Admin password can be verified against stored hash"
    - "JWT token can be created for an admin ID"
    - "JWT token can be verified and admin ID extracted"
    - "Invalid/expired tokens are rejected"
  artifacts:
    - path: "src/auth/admin.ts"
      provides: "Admin CRUD operations with password hashing"
      exports: ["createAdmin", "getAdminByEmail", "getAdminById", "verifyAdminPassword", "updateAdminPassword"]
    - path: "src/auth/jwt.ts"
      provides: "JWT token creation and verification"
      exports: ["createAdminToken", "verifyAdminToken"]
    - path: "src/auth/admin.test.ts"
      provides: "Tests for admin module"
      min_lines: 50
    - path: "src/auth/jwt.test.ts"
      provides: "Tests for JWT module"
      min_lines: 40
  key_links:
    - from: "src/auth/admin.ts"
      to: "Bun.password"
      via: "hash and verify functions"
      pattern: "Bun\\.password\\.(hash|verify)"
    - from: "src/auth/jwt.ts"
      to: "jose"
      via: "SignJWT and jwtVerify"
      pattern: "(SignJWT|jwtVerify)"
    - from: "src/auth/admin.ts"
      to: "_admins table"
      via: "database queries"
      pattern: "_admins"
---

<objective>
Create the foundational auth modules: admin account management with secure password hashing, and JWT token utilities for authentication.

Purpose: These modules provide the building blocks for the auth routes - admin credential storage and token generation/verification.
Output: Two tested modules (admin.ts, jwt.ts) ready for integration into HTTP endpoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-admin-authentication/05-RESEARCH.md

# Existing modules to integrate with
@src/core/database.ts
@src/utils/id.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create admin module with password hashing</name>
  <files>
    src/core/database.ts
    src/auth/admin.ts
    src/auth/admin.test.ts
  </files>
  <action>
1. Update src/core/database.ts to add _admins table initialization:
   ```sql
   CREATE TABLE IF NOT EXISTS _admins (
     id TEXT PRIMARY KEY,
     email TEXT UNIQUE NOT NULL,
     password_hash TEXT NOT NULL,
     created_at TEXT DEFAULT (datetime('now')),
     updated_at TEXT DEFAULT (datetime('now'))
   );
   ```
   Add this to INIT_METADATA_SQL constant.

2. Create src/auth/admin.ts with these functions:
   - `createAdmin(email: string, password: string): Promise<Admin>` - Hash password with Bun.password.hash(), insert into _admins, return admin without password_hash
   - `getAdminByEmail(email: string): Admin | null` - Query by email, return admin with password_hash for internal use
   - `getAdminById(id: string): Admin | null` - Query by id, return admin with password_hash for internal use
   - `verifyAdminPassword(email: string, password: string): Promise<Admin | null>` - Get admin by email, verify with Bun.password.verify(), return admin without password_hash or null
   - `updateAdminPassword(id: string, newPassword: string): Promise<void>` - Hash new password, update _admins

   Type definitions:
   ```typescript
   interface Admin {
     id: string;
     email: string;
     created_at: string;
     updated_at: string;
   }
   interface AdminWithHash extends Admin {
     password_hash: string;
   }
   ```

   Use nanoid from src/utils/id.ts for ID generation. Use getDatabase() from src/core/database.ts.

3. Create src/auth/admin.test.ts with tests:
   - createAdmin creates admin with hashed password (not plaintext)
   - createAdmin throws on duplicate email
   - getAdminByEmail returns admin for existing email
   - getAdminByEmail returns null for unknown email
   - verifyAdminPassword returns admin for correct password
   - verifyAdminPassword returns null for incorrect password
   - updateAdminPassword changes the password (old fails, new works)

   Use initDatabase(":memory:") for test isolation.
  </action>
  <verify>
    bun test src/auth/admin.test.ts
  </verify>
  <done>
    Admin module exports all 5 functions. Password is stored as argon2id hash (starts with $argon2id$). All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create JWT utilities module</name>
  <files>
    src/auth/jwt.ts
    src/auth/jwt.test.ts
  </files>
  <action>
1. Install jose dependency:
   ```bash
   bun add jose
   ```

2. Create src/auth/jwt.ts with these functions:
   ```typescript
   import { SignJWT, jwtVerify, JWTPayload } from "jose";

   // Get secret from environment, fail fast if missing
   function getSecret(): Uint8Array {
     const secret = Bun.env.JWT_SECRET;
     if (!secret) {
       throw new Error("JWT_SECRET environment variable is required");
     }
     return new TextEncoder().encode(secret);
   }

   interface AdminTokenPayload extends JWTPayload {
     adminId: string;
   }

   export async function createAdminToken(adminId: string): Promise<string> {
     return await new SignJWT({ adminId })
       .setProtectedHeader({ alg: "HS256" })
       .setIssuedAt()
       .setExpirationTime("24h")
       .sign(getSecret());
   }

   export async function verifyAdminToken(token: string): Promise<AdminTokenPayload | null> {
     try {
       const { payload } = await jwtVerify(token, getSecret(), {
         algorithms: ["HS256"],
       });
       if (!payload.adminId || typeof payload.adminId !== "string") {
         return null;
       }
       return payload as AdminTokenPayload;
     } catch {
       return null;
     }
   }
   ```

3. Create src/auth/jwt.test.ts with tests:
   - createAdminToken returns a string token (3 dot-separated parts)
   - verifyAdminToken returns payload with adminId for valid token
   - verifyAdminToken returns null for invalid token
   - verifyAdminToken returns null for expired token (use short expiry for test)
   - verifyAdminToken returns null for token signed with different secret
   - createAdminToken throws if JWT_SECRET not set

   Set JWT_SECRET in test environment: `process.env.JWT_SECRET = "test-secret-at-least-32-chars-long";`
  </action>
  <verify>
    bun test src/auth/jwt.test.ts
  </verify>
  <done>
    JWT module exports createAdminToken and verifyAdminToken. Token format is valid JWT. Invalid/expired tokens return null. Missing JWT_SECRET throws error.
  </done>
</task>

</tasks>

<verification>
Run all auth tests:
```bash
bun test src/auth/
```

Expected: All tests pass. Both modules export their functions correctly.

Verify argon2id usage:
```bash
bun -e "import { createAdmin } from './src/auth/admin'; import { initDatabase } from './src/core/database'; initDatabase(':memory:'); createAdmin('test@test.com', 'password').then(console.log)"
```
Check that password_hash in database starts with `$argon2id$`.
</verification>

<success_criteria>
1. Admin can be created with email/password, password stored as argon2id hash
2. Admin password can be verified against stored hash
3. JWT tokens can be created and verified
4. Invalid/expired tokens are rejected
5. Missing JWT_SECRET fails fast with clear error
6. All tests pass (both admin.test.ts and jwt.test.ts)
</success_criteria>

<output>
After completion, create `.planning/phases/05-admin-authentication/05-01-SUMMARY.md`
</output>
