---
phase: 09-email-service
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/email/transport.ts
  - src/email/send.ts
  - src/email/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Email service can be initialized with SMTP config"
    - "isEmailConfigured() returns true after initialization, false before"
    - "sendEmail() returns success with messageId when configured"
    - "sendEmail() returns error when not configured"
    - "Template placeholders are replaced in email body"
  artifacts:
    - path: "src/email/transport.ts"
      provides: "Nodemailer transport management"
      exports: ["initEmailService", "isEmailConfigured", "getTransport"]
    - path: "src/email/send.ts"
      provides: "Send email function with template support"
      exports: ["sendEmail", "EmailOptions", "EmailResult"]
    - path: "src/email/index.ts"
      provides: "Public API re-exports"
      exports: ["initEmailService", "isEmailConfigured", "sendEmail", "SmtpConfig", "loadSmtpConfig"]
    - path: "package.json"
      provides: "nodemailer dependency"
      contains: "nodemailer"
  key_links:
    - from: "src/email/send.ts"
      to: "src/email/transport.ts"
      via: "getTransport import"
      pattern: "import.*getTransport.*from.*transport"
    - from: "src/email/send.ts"
      to: "src/email/templates.ts"
      via: "replacePlaceholders import"
      pattern: "import.*replacePlaceholders.*from.*templates"
---

<objective>
Implement email transport and send functionality using Nodemailer.

Purpose: Provide the core email sending capability that Phase 10 (User Authentication) will use for verification and password reset emails. This is the heart of the email service.

Output: Working email send function with template support, ready for integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-email-service/09-RESEARCH.md

# Prior plan artifacts
@src/email/config.ts
@src/email/templates.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install nodemailer and create transport management</name>
  <files>package.json, src/email/transport.ts</files>
  <action>
**Step 1: Install nodemailer**
```bash
bun install nodemailer
bun install --dev @types/nodemailer
```

**Step 2: Create `src/email/transport.ts`**

1. **Imports:**
   ```typescript
   import nodemailer, { Transporter } from "nodemailer";
   import { SmtpConfig } from "./config";
   ```

2. **Module state:**
   - `let transporter: Transporter | null = null;`
   - `let config: SmtpConfig | null = null;`

3. **initEmailService(smtpConfig: SmtpConfig): void**
   - Store config
   - Create nodemailer transporter with config values
   - Set `host`, `port`, `secure`, `auth: { user, pass }`

4. **isEmailConfigured(): boolean**
   - Return `config !== null && transporter !== null`

5. **getTransport(): Transporter | null**
   - Return the transporter (internal use by send.ts)
   - Return null if not initialized

6. **getConfig(): SmtpConfig | null**
   - Return the stored config (needed for `from` address)
   - Return null if not initialized

Do NOT verify SMTP connection on init (per research recommendation - lazy verification on first send).
  </action>
  <verify>
Run `bun build src/email/transport.ts` - should compile without errors.
Check nodemailer in package.json: `grep nodemailer package.json`
  </verify>
  <done>
nodemailer and @types/nodemailer installed. Transport module exports initEmailService, isEmailConfigured, getTransport, getConfig. Transporter created lazily on init.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sendEmail function with template support</name>
  <files>src/email/send.ts</files>
  <action>
Create `src/email/send.ts` with:

1. **EmailOptions interface:**
   ```typescript
   export interface EmailOptions {
     to: string;
     subject: string;
     text: string;
     html?: string;
     placeholders?: Record<string, string>;
   }
   ```

2. **EmailResult interface:**
   ```typescript
   export interface EmailResult {
     success: boolean;
     messageId?: string;
     error?: string;
   }
   ```

3. **sendEmail function:**
   ```typescript
   export async function sendEmail(options: EmailOptions): Promise<EmailResult>
   ```

   Implementation:
   - Check `isEmailConfigured()` first - return `{ success: false, error: "Email service not configured" }` if not
   - Get transporter and config from transport.ts
   - Apply `replacePlaceholders()` to `text` if `options.placeholders` provided
   - Apply `replacePlaceholders()` to `html` if both exist
   - Call `transporter.sendMail()` with:
     - `from`: config.from
     - `to`: options.to
     - `subject`: options.subject
     - `text`: processed text
     - `html`: processed html (if provided)
   - Wrap in try/catch
   - On success: return `{ success: true, messageId: info.messageId }`
   - On error: return `{ success: false, error: "Failed to send email: {message}" }`
   - **Important:** Do NOT log the error object directly (may contain credentials). Only log error.message.
  </action>
  <verify>
Run `bun build src/email/send.ts` - should compile without errors.
Check imports resolve: `bun -e "import { sendEmail, EmailOptions, EmailResult } from './src/email/send.ts'; console.log(typeof sendEmail)"`
  </verify>
  <done>
sendEmail function exported with EmailOptions and EmailResult types. Checks configuration before sending. Applies template placeholders. Returns structured result. Error messages sanitized (no credentials leaked).
  </done>
</task>

<task type="auto">
  <name>Task 3: Create public API index file</name>
  <files>src/email/index.ts</files>
  <action>
Create `src/email/index.ts` that re-exports the public API:

```typescript
// Configuration
export { SmtpConfig, SmtpCliValues, loadSmtpConfig } from "./config";

// Transport management
export { initEmailService, isEmailConfigured } from "./transport";

// Send function
export { sendEmail, EmailOptions, EmailResult } from "./send";
```

**Do NOT export:**
- `getTransport` - internal use only
- `getConfig` - internal use only
- `replacePlaceholders` - internal use only (exposed via sendEmail's placeholders option)

This follows the pattern of exposing a clean public API while keeping implementation details private.
  </action>
  <verify>
Run `bun -e "import { initEmailService, isEmailConfigured, sendEmail, SmtpConfig, loadSmtpConfig } from './src/email/index.ts'; console.log('All exports work')"`

Verify internal modules are NOT exported:
`bun -e "import { getTransport } from './src/email/index.ts'" 2>&1 | grep -q "does not provide" && echo "Correctly not exported" || echo "ERROR: getTransport should not be exported"`
  </verify>
  <done>
src/email/index.ts exports public API: initEmailService, isEmailConfigured, sendEmail, SmtpConfig, SmtpCliValues, loadSmtpConfig, EmailOptions, EmailResult. Internal functions not exposed.
  </done>
</task>

</tasks>

<verification>
1. `bun install` completes without errors
2. `bun build src/email/index.ts` compiles successfully
3. All public exports accessible via index.ts
4. isEmailConfigured() returns false before init, true after init
5. sendEmail() returns error result when not configured
</verification>

<success_criteria>
- nodemailer ^7.0.12 in package.json dependencies
- @types/nodemailer in devDependencies
- initEmailService() creates nodemailer transporter
- isEmailConfigured() correctly reports state
- sendEmail() applies placeholders and sends via transporter
- sendEmail() returns structured EmailResult (success/error)
- Clean public API via src/email/index.ts
- No credentials leaked in error messages
</success_criteria>

<output>
After completion, create `.planning/phases/09-email-service/09-02-SUMMARY.md`
</output>
