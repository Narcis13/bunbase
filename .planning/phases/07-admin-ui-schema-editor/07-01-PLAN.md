---
phase: 07-admin-ui-schema-editor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/server.ts
autonomous: true

must_haves:
  truths:
    - "POST /_/api/collections creates a new collection with fields"
    - "PATCH /_/api/collections/:name renames a collection"
    - "DELETE /_/api/collections/:name removes a collection and its data"
    - "POST /_/api/collections/:name/fields adds a field to a collection"
    - "PATCH /_/api/collections/:name/fields/:fieldName updates a field"
    - "DELETE /_/api/collections/:name/fields/:fieldName removes a field"
  artifacts:
    - path: "src/api/server.ts"
      provides: "Schema mutation HTTP endpoints"
      contains: "createCollection"
  key_links:
    - from: "POST /_/api/collections"
      to: "createCollection"
      via: "route handler calls schema function"
      pattern: "createCollection\\(.*\\)"
    - from: "POST /_/api/collections/:name/fields"
      to: "addField"
      via: "route handler calls schema function"
      pattern: "addField\\(.*\\)"
---

<objective>
Add HTTP route handlers for schema mutation operations to expose existing schema functions to the admin UI.

Purpose: The schema manager functions (createCollection, updateCollection, deleteCollection, addField, updateField, removeField) exist in src/core/schema.ts but are not exposed as HTTP endpoints. The admin UI needs these to perform schema editing.

Output: Six new admin API routes in server.ts that call the corresponding schema functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/api/server.ts
@src/core/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add collection-level schema routes</name>
  <files>src/api/server.ts</files>
  <action>
Add three new route handlers to the routes object in server.ts:

1. Modify the existing `"/_/api/collections"` route object to add POST handler:
```typescript
POST: async (req) => {
  const adminOrError = await requireAdmin(req);
  if (adminOrError instanceof Response) return adminOrError;
  try {
    const { name, fields } = await req.json();
    if (!name || typeof name !== "string") {
      return errorResponse("Collection name is required", 400);
    }
    const collection = createCollection(name, fields || []);
    return Response.json(collection, { status: 201 });
  } catch (error) {
    const err = error as Error;
    return errorResponse(err.message, mapErrorToStatus(err));
  }
},
```

2. Add new route `"/_/api/collections/:name"` with PATCH and DELETE handlers:
```typescript
"/_/api/collections/:name": {
  PATCH: async (req) => {
    const adminOrError = await requireAdmin(req);
    if (adminOrError instanceof Response) return adminOrError;
    const { name } = req.params;
    try {
      const { newName } = await req.json();
      if (!newName || typeof newName !== "string") {
        return errorResponse("New collection name is required", 400);
      }
      const collection = updateCollection(name, newName);
      return Response.json(collection);
    } catch (error) {
      const err = error as Error;
      return errorResponse(err.message, mapErrorToStatus(err));
    }
  },
  DELETE: async (req) => {
    const adminOrError = await requireAdmin(req);
    if (adminOrError instanceof Response) return adminOrError;
    const { name } = req.params;
    try {
      deleteCollection(name);
      return new Response(null, { status: 204 });
    } catch (error) {
      const err = error as Error;
      return errorResponse(err.message, mapErrorToStatus(err));
    }
  },
},
```

3. Add the necessary imports at the top:
```typescript
import {
  getAllCollections,
  getFields,
  createCollection,
  updateCollection,
  deleteCollection,
} from "../core/schema";
```

Note: Place the new "/_/api/collections/:name" route BEFORE the generic "/_/api/collections" route to ensure proper route matching.
  </action>
  <verify>Run `bun run src/api/server.ts &` then test:
- `curl -X POST http://localhost:8090/_/api/collections -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d '{"name":"test_phase7","fields":[{"name":"title","type":"text","required":true}]}'` returns 201
- `curl -X PATCH http://localhost:8090/_/api/collections/test_phase7 -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d '{"newName":"test_renamed"}'` returns 200
- `curl -X DELETE http://localhost:8090/_/api/collections/test_renamed -H "Authorization: Bearer $TOKEN"` returns 204</verify>
  <done>Collection-level schema mutation routes (POST, PATCH, DELETE) are working with admin auth protection.</done>
</task>

<task type="auto">
  <name>Task 2: Add field-level schema routes</name>
  <files>src/api/server.ts</files>
  <action>
Add a new route for field operations and modify the existing fields route:

1. Add imports for field functions:
```typescript
import {
  getAllCollections,
  getFields,
  createCollection,
  updateCollection,
  deleteCollection,
  addField,
  updateField,
  removeField,
} from "../core/schema";
```

2. Modify existing `"/_/api/collections/:name/fields"` route to add POST handler:
```typescript
"/_/api/collections/:name/fields": {
  GET: async (req) => {
    // ... existing GET handler stays the same
  },
  POST: async (req) => {
    const adminOrError = await requireAdmin(req);
    if (adminOrError instanceof Response) return adminOrError;
    const { name } = req.params;
    try {
      const fieldData = await req.json();
      if (!fieldData.name || !fieldData.type) {
        return errorResponse("Field name and type are required", 400);
      }
      const field = addField(name, {
        name: fieldData.name,
        type: fieldData.type,
        required: fieldData.required ?? false,
        options: fieldData.options ?? null,
      });
      return Response.json(field, { status: 201 });
    } catch (error) {
      const err = error as Error;
      return errorResponse(err.message, mapErrorToStatus(err));
    }
  },
},
```

3. Add new route for individual field operations:
```typescript
"/_/api/collections/:name/fields/:fieldName": {
  PATCH: async (req) => {
    const adminOrError = await requireAdmin(req);
    if (adminOrError instanceof Response) return adminOrError;
    const { name, fieldName } = req.params;
    try {
      const updates = await req.json();
      const field = updateField(name, fieldName, updates);
      return Response.json(field);
    } catch (error) {
      const err = error as Error;
      return errorResponse(err.message, mapErrorToStatus(err));
    }
  },
  DELETE: async (req) => {
    const adminOrError = await requireAdmin(req);
    if (adminOrError instanceof Response) return adminOrError;
    const { name, fieldName } = req.params;
    try {
      removeField(name, fieldName);
      return new Response(null, { status: 204 });
    } catch (error) {
      const err = error as Error;
      return errorResponse(err.message, mapErrorToStatus(err));
    }
  },
},
```

Note: Place the specific route "/_/api/collections/:name/fields/:fieldName" BEFORE the generic "/_/api/collections/:name/fields" route for proper matching.
  </action>
  <verify>Test field operations:
- Create collection: `curl -X POST http://localhost:8090/_/api/collections -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d '{"name":"test_fields"}'` returns 201
- Add field: `curl -X POST http://localhost:8090/_/api/collections/test_fields/fields -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d '{"name":"description","type":"text","required":false}'` returns 201
- Update field: `curl -X PATCH http://localhost:8090/_/api/collections/test_fields/fields/description -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d '{"required":true}'` returns 200
- Delete field: `curl -X DELETE http://localhost:8090/_/api/collections/test_fields/fields/description -H "Authorization: Bearer $TOKEN"` returns 204
- Cleanup: `curl -X DELETE http://localhost:8090/_/api/collections/test_fields -H "Authorization: Bearer $TOKEN"` returns 204</verify>
  <done>Field-level schema mutation routes (POST, PATCH, DELETE) are working with admin auth protection.</done>
</task>

</tasks>

<verification>
All schema mutation endpoints return expected status codes:
- POST collection: 201 with collection object
- PATCH collection: 200 with updated collection
- DELETE collection: 204 no content
- POST field: 201 with field object
- PATCH field: 200 with updated field
- DELETE field: 204 no content

All endpoints require admin authentication (401 without valid JWT).
All endpoints handle errors properly (400 for validation, 404 for not found, 409 for conflicts).
</verification>

<success_criteria>
1. `curl -X POST /_/api/collections` with valid JWT creates a new collection
2. `curl -X DELETE /_/api/collections/:name` with valid JWT deletes a collection
3. `curl -X POST /_/api/collections/:name/fields` with valid JWT adds a field
4. `curl -X DELETE /_/api/collections/:name/fields/:fieldName` with valid JWT removes a field
5. All routes return 401 without valid JWT
</success_criteria>

<output>
After completion, create `.planning/phases/07-admin-ui-schema-editor/07-01-SUMMARY.md`
</output>
