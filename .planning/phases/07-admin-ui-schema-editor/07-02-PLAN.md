---
phase: 07-admin-ui-schema-editor
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/admin/components/ui/select.tsx
  - src/admin/lib/api.ts
  - src/admin/hooks/useSchema.ts
autonomous: true

must_haves:
  truths:
    - "Select component renders dropdown with options"
    - "Schema API functions call backend endpoints"
    - "useSchema hook fetches and manages schema state"
  artifacts:
    - path: "src/admin/components/ui/select.tsx"
      provides: "shadcn Select component"
      contains: "SelectTrigger"
    - path: "src/admin/lib/api.ts"
      provides: "Schema CRUD API functions"
      contains: "createCollection"
    - path: "src/admin/hooks/useSchema.ts"
      provides: "Schema state management hook"
      contains: "useSchema"
  key_links:
    - from: "src/admin/hooks/useSchema.ts"
      to: "src/admin/lib/api.ts"
      via: "hook uses API functions"
      pattern: "fetchWithAuth"
---

<objective>
Add the shadcn Select component and create schema API wrapper functions with a custom hook for managing schema state.

Purpose: The schema editor UI needs a Select dropdown for field type selection and API functions to call the backend schema routes. The useSchema hook will manage loading fields for a collection.

Output: Select component, schema API functions in api.ts, and useSchema hook.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-admin-ui-schema-editor/07-RESEARCH.md
@src/admin/lib/api.ts
@src/admin/components/ui/button.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @radix-ui/react-select and add Select component</name>
  <files>package.json, src/admin/components/ui/select.tsx</files>
  <action>
1. Install the dependency:
```bash
bun add @radix-ui/react-select
```

2. Create `src/admin/components/ui/select.tsx` with the shadcn Select component:

```typescript
/**
 * Select component built on Radix UI primitives.
 * Used for field type selection in schema editor.
 */

import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown } from "lucide-react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectContent = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectItem = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectLabel = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectSeparator = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectItem,
  SelectLabel,
  SelectSeparator,
};
```
  </action>
  <verify>Verify installation: `grep "@radix-ui/react-select" package.json` shows the dependency.
Verify file exists: `ls src/admin/components/ui/select.tsx` succeeds.
Verify TypeScript: `bun build src/admin/components/ui/select.tsx --no-bundle` compiles without errors.</verify>
  <done>Select component is installed and ready for use in schema editor forms.</done>
</task>

<task type="auto">
  <name>Task 2: Add schema API functions to api.ts</name>
  <files>src/admin/lib/api.ts</files>
  <action>
Add schema CRUD functions to the existing api.ts file. Append after the existing functions:

```typescript
// ============================================================================
// Schema API Functions
// ============================================================================

/**
 * Field input type for creating/updating fields.
 */
export interface FieldInput {
  name: string;
  type: "text" | "number" | "boolean" | "datetime" | "json" | "relation";
  required?: boolean;
  options?: { target?: string } | null;
}

/**
 * Field type returned from API.
 */
export interface Field {
  id: string;
  collection_id: string;
  name: string;
  type: "text" | "number" | "boolean" | "datetime" | "json" | "relation";
  required: boolean;
  options: { target?: string } | null;
  created_at: string;
}

/**
 * Collection type returned from API.
 */
export interface Collection {
  id: string;
  name: string;
  created_at: string;
  updated_at: string;
  fieldCount?: number;
  recordCount?: number;
}

/**
 * Create a new collection with optional fields.
 *
 * @param name - Collection name (must start with letter, alphanumeric + underscore)
 * @param fields - Optional array of field definitions
 * @returns Created collection
 */
export async function createCollection(
  name: string,
  fields: FieldInput[] = []
): Promise<Collection> {
  const response = await fetchWithAuth("/_/api/collections", {
    method: "POST",
    body: JSON.stringify({ name, fields }),
  });
  return response.json();
}

/**
 * Rename a collection.
 *
 * @param name - Current collection name
 * @param newName - New collection name
 * @returns Updated collection
 */
export async function renameCollection(
  name: string,
  newName: string
): Promise<Collection> {
  const response = await fetchWithAuth(`/_/api/collections/${name}`, {
    method: "PATCH",
    body: JSON.stringify({ newName }),
  });
  return response.json();
}

/**
 * Delete a collection and all its records.
 *
 * @param name - Collection name
 */
export async function deleteCollection(name: string): Promise<void> {
  await fetchWithAuth(`/_/api/collections/${name}`, {
    method: "DELETE",
  });
}

/**
 * Add a field to a collection.
 *
 * @param collection - Collection name
 * @param field - Field definition
 * @returns Created field
 */
export async function addField(
  collection: string,
  field: FieldInput
): Promise<Field> {
  const response = await fetchWithAuth(
    `/_/api/collections/${collection}/fields`,
    {
      method: "POST",
      body: JSON.stringify(field),
    }
  );
  return response.json();
}

/**
 * Update a field in a collection.
 *
 * @param collection - Collection name
 * @param fieldName - Current field name
 * @param updates - Fields to update
 * @returns Updated field
 */
export async function updateField(
  collection: string,
  fieldName: string,
  updates: Partial<FieldInput>
): Promise<Field> {
  const response = await fetchWithAuth(
    `/_/api/collections/${collection}/fields/${fieldName}`,
    {
      method: "PATCH",
      body: JSON.stringify(updates),
    }
  );
  return response.json();
}

/**
 * Delete a field from a collection.
 *
 * @param collection - Collection name
 * @param fieldName - Field name
 */
export async function deleteField(
  collection: string,
  fieldName: string
): Promise<void> {
  await fetchWithAuth(
    `/_/api/collections/${collection}/fields/${fieldName}`,
    {
      method: "DELETE",
    }
  );
}

/**
 * Fetch fields for a collection.
 *
 * @param collection - Collection name
 * @returns Array of fields
 */
export async function fetchFields(collection: string): Promise<Field[]> {
  const response = await fetchWithAuth(
    `/_/api/collections/${collection}/fields`
  );
  return response.json();
}

/**
 * Fetch all collections.
 *
 * @returns Array of collections with field and record counts
 */
export async function fetchCollections(): Promise<Collection[]> {
  const response = await fetchWithAuth("/_/api/collections");
  return response.json();
}
```
  </action>
  <verify>TypeScript compiles: `bun build src/admin/lib/api.ts --no-bundle` succeeds without errors.</verify>
  <done>Schema API functions are available for use by schema editor components.</done>
</task>

<task type="auto">
  <name>Task 3: Create useSchema hook</name>
  <files>src/admin/hooks/useSchema.ts</files>
  <action>
Create `src/admin/hooks/useSchema.ts` with a hook for managing schema state:

```typescript
/**
 * Hook for managing schema state (fields) for a collection.
 * Provides loading, error handling, and refetch capability.
 */

import { useState, useEffect, useCallback } from "react";
import { fetchFields, type Field } from "@/lib/api";

interface UseSchemaResult {
  fields: Field[];
  loading: boolean;
  error: string | null;
  refetch: () => void;
}

/**
 * Fetch and manage fields for a collection.
 *
 * @param collection - Collection name
 * @returns Fields array, loading state, error, and refetch function
 */
export function useSchema(collection: string): UseSchemaResult {
  const [fields, setFields] = useState<Field[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const loadFields = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const data = await fetchFields(collection);
      setFields(data);
    } catch (e) {
      setError((e as Error).message);
    } finally {
      setLoading(false);
    }
  }, [collection]);

  useEffect(() => {
    loadFields();
  }, [loadFields]);

  return {
    fields,
    loading,
    error,
    refetch: loadFields,
  };
}
```
  </action>
  <verify>TypeScript compiles: `bun build src/admin/hooks/useSchema.ts --no-bundle` succeeds without errors.</verify>
  <done>useSchema hook is available for schema editor components to fetch and manage field state.</done>
</task>

</tasks>

<verification>
1. @radix-ui/react-select is in package.json dependencies
2. src/admin/components/ui/select.tsx exists and exports Select components
3. src/admin/lib/api.ts has all schema CRUD functions (createCollection, renameCollection, deleteCollection, addField, updateField, deleteField, fetchFields, fetchCollections)
4. src/admin/hooks/useSchema.ts exports useSchema hook
5. All files compile with TypeScript without errors
</verification>

<success_criteria>
1. `bun add @radix-ui/react-select` completes successfully
2. Select component can be imported: `import { Select } from "@/components/ui/select"`
3. Schema API functions are exported from api.ts
4. useSchema hook can be imported and used
5. No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-admin-ui-schema-editor/07-02-SUMMARY.md`
</output>
