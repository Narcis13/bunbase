---
phase: 07-admin-ui-schema-editor
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - src/admin/components/schema/FieldsTable.tsx
  - src/admin/components/schema/FieldForm.tsx
  - src/admin/components/schema/FieldSheet.tsx
  - src/admin/components/schema/SchemaView.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can see list of fields in a table"
    - "Admin can open form to create new field"
    - "Admin can edit existing field via form"
    - "Field form has type dropdown with all 6 field types"
    - "Relation field shows target collection selector"
  artifacts:
    - path: "src/admin/components/schema/FieldsTable.tsx"
      provides: "Table display of collection fields"
      contains: "FieldsTable"
    - path: "src/admin/components/schema/FieldForm.tsx"
      provides: "Form for field create/edit"
      contains: "FieldForm"
    - path: "src/admin/components/schema/FieldSheet.tsx"
      provides: "Sheet container for field form"
      contains: "FieldSheet"
    - path: "src/admin/components/schema/SchemaView.tsx"
      provides: "Main schema editor view"
      contains: "SchemaView"
  key_links:
    - from: "src/admin/components/schema/SchemaView.tsx"
      to: "src/admin/lib/api.ts"
      via: "calls schema API functions"
      pattern: "addField|updateField|deleteField"
    - from: "src/admin/components/schema/FieldForm.tsx"
      to: "src/admin/components/ui/select.tsx"
      via: "uses Select for field type"
      pattern: "Select.*type"
---

<objective>
Create the schema editor UI components: FieldsTable for displaying fields, FieldForm for the field edit form, FieldSheet for the slide-over panel, and SchemaView as the container component.

Purpose: These components allow admins to view and modify collection schemas through the admin UI. The pattern follows RecordsView/RecordForm established in Phase 6.

Output: Complete schema editor UI components ready to integrate into the app.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-admin-ui-schema-editor/07-RESEARCH.md
@src/admin/components/records/RecordsView.tsx
@src/admin/components/records/RecordForm.tsx
@src/admin/components/records/RecordsTable.tsx
@src/admin/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FieldsTable component</name>
  <files>src/admin/components/schema/FieldsTable.tsx</files>
  <action>
Create `src/admin/components/schema/FieldsTable.tsx`:

```typescript
/**
 * Fields table component displaying collection fields.
 * Uses TanStack Table for consistent data table experience.
 */

import { MoreHorizontal } from "lucide-react";
import {
  useReactTable,
  getCoreRowModel,
  flexRender,
  type ColumnDef,
} from "@tanstack/react-table";
import type { Field } from "@/lib/api";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Skeleton } from "@/components/ui/skeleton";

interface FieldsTableProps {
  fields: Field[];
  loading: boolean;
  onEdit: (field: Field) => void;
  onDelete: (field: Field) => void;
}

/**
 * Type badge colors for visual distinction.
 */
const TYPE_COLORS: Record<string, string> = {
  text: "bg-blue-100 text-blue-800",
  number: "bg-green-100 text-green-800",
  boolean: "bg-purple-100 text-purple-800",
  datetime: "bg-orange-100 text-orange-800",
  json: "bg-gray-100 text-gray-800",
  relation: "bg-pink-100 text-pink-800",
};

/**
 * FieldsTable displays a collection's fields in a table with actions.
 */
export function FieldsTable({
  fields,
  loading,
  onEdit,
  onDelete,
}: FieldsTableProps) {
  const columns: ColumnDef<Field>[] = [
    {
      accessorKey: "name",
      header: "Name",
      cell: ({ row }) => (
        <span className="font-mono text-sm">{row.original.name}</span>
      ),
    },
    {
      accessorKey: "type",
      header: "Type",
      cell: ({ row }) => (
        <span
          className={`px-2 py-1 rounded-md text-xs font-medium ${
            TYPE_COLORS[row.original.type] || "bg-gray-100"
          }`}
        >
          {row.original.type}
        </span>
      ),
    },
    {
      accessorKey: "required",
      header: "Required",
      cell: ({ row }) => (
        <span className={row.original.required ? "text-green-600" : "text-muted-foreground"}>
          {row.original.required ? "Yes" : "No"}
        </span>
      ),
    },
    {
      id: "options",
      header: "Options",
      cell: ({ row }) => {
        if (row.original.type === "relation" && row.original.options?.target) {
          return (
            <span className="text-sm text-muted-foreground">
              → {row.original.options.target}
            </span>
          );
        }
        return <span className="text-muted-foreground">—</span>;
      },
    },
    {
      id: "actions",
      header: "",
      cell: ({ row }) => (
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
              <span className="sr-only">Open menu</span>
              <MoreHorizontal className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end">
            <DropdownMenuItem onClick={() => onEdit(row.original)}>
              Edit
            </DropdownMenuItem>
            <DropdownMenuItem
              onClick={() => onDelete(row.original)}
              className="text-destructive"
            >
              Delete
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      ),
    },
  ];

  const table = useReactTable({
    data: fields,
    columns,
    getCoreRowModel: getCoreRowModel(),
  });

  if (loading) {
    return (
      <div className="space-y-2">
        {[1, 2, 3].map((i) => (
          <Skeleton key={i} className="h-12 w-full" />
        ))}
      </div>
    );
  }

  if (fields.length === 0) {
    return (
      <div className="text-center py-12 text-muted-foreground">
        No fields defined. Click "Add Field" to create one.
      </div>
    );
  }

  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          {table.getHeaderGroups().map((headerGroup) => (
            <TableRow key={headerGroup.id}>
              {headerGroup.headers.map((header) => (
                <TableHead key={header.id}>
                  {header.isPlaceholder
                    ? null
                    : flexRender(
                        header.column.columnDef.header,
                        header.getContext()
                      )}
                </TableHead>
              ))}
            </TableRow>
          ))}
        </TableHeader>
        <TableBody>
          {table.getRowModel().rows.map((row) => (
            <TableRow key={row.id}>
              {row.getVisibleCells().map((cell) => (
                <TableCell key={cell.id}>
                  {flexRender(cell.column.columnDef.cell, cell.getContext())}
                </TableCell>
              ))}
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
```
  </action>
  <verify>TypeScript compiles: `bun build src/admin/components/schema/FieldsTable.tsx --no-bundle` succeeds.</verify>
  <done>FieldsTable component displays fields with type badges, required status, options, and actions dropdown.</done>
</task>

<task type="auto">
  <name>Task 2: Create FieldForm and FieldSheet components</name>
  <files>src/admin/components/schema/FieldForm.tsx, src/admin/components/schema/FieldSheet.tsx</files>
  <action>
1. Create `src/admin/components/schema/FieldForm.tsx`:

```typescript
/**
 * Field form component for creating and editing fields.
 * Uses react-hook-form with Select for field type.
 */

import { useEffect } from "react";
import { useForm, Controller } from "react-hook-form";
import type { Field, FieldInput, Collection } from "@/lib/api";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface FieldFormProps {
  field: Field | null;
  collections: Collection[];
  currentCollection: string;
  onSubmit: (data: FieldInput) => void;
  loading: boolean;
}

const FIELD_TYPES = [
  { value: "text", label: "Text", description: "String values" },
  { value: "number", label: "Number", description: "Numeric values" },
  { value: "boolean", label: "Boolean", description: "True/false values" },
  { value: "datetime", label: "DateTime", description: "Date and time" },
  { value: "json", label: "JSON", description: "Complex data structures" },
  { value: "relation", label: "Relation", description: "Link to another collection" },
] as const;

const RESERVED_NAMES = ["id", "created_at", "updated_at"];

/**
 * FieldForm renders form inputs for field properties.
 * Handles create (field=null) and edit (field provided) modes.
 */
export function FieldForm({
  field,
  collections,
  currentCollection,
  onSubmit,
  loading,
}: FieldFormProps) {
  const {
    register,
    handleSubmit,
    control,
    watch,
    reset,
    formState: { errors },
  } = useForm<FieldInput>({
    defaultValues: {
      name: field?.name ?? "",
      type: field?.type ?? "text",
      required: field?.required ?? false,
      options: field?.options ?? null,
    },
  });

  // Reset form when field changes (switching between create/edit)
  useEffect(() => {
    reset({
      name: field?.name ?? "",
      type: field?.type ?? "text",
      required: field?.required ?? false,
      options: field?.options ?? null,
    });
  }, [field, reset]);

  const fieldType = watch("type");

  // Filter out current collection from relation targets
  const availableCollections = collections.filter(
    (c) => c.name !== currentCollection
  );

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* Field Name */}
      <div className="space-y-2">
        <Label htmlFor="name">Field Name</Label>
        <Input
          id="name"
          placeholder="e.g., title, description, price"
          {...register("name", {
            required: "Field name is required",
            pattern: {
              value: /^[a-zA-Z][a-zA-Z0-9_]*$/,
              message:
                "Must start with letter, contain only letters, numbers, underscores",
            },
            validate: {
              notReserved: (value) =>
                !RESERVED_NAMES.includes(value) ||
                "This name is reserved for system fields",
            },
          })}
          disabled={loading}
        />
        {errors.name && (
          <p className="text-sm text-destructive">{errors.name.message}</p>
        )}
      </div>

      {/* Field Type */}
      <div className="space-y-2">
        <Label htmlFor="type">Field Type</Label>
        <Controller
          name="type"
          control={control}
          rules={{ required: "Field type is required" }}
          render={({ field: formField }) => (
            <Select
              value={formField.value}
              onValueChange={formField.onChange}
              disabled={loading}
            >
              <SelectTrigger id="type">
                <SelectValue placeholder="Select field type" />
              </SelectTrigger>
              <SelectContent>
                {FIELD_TYPES.map((type) => (
                  <SelectItem key={type.value} value={type.value}>
                    <div className="flex flex-col">
                      <span>{type.label}</span>
                      <span className="text-xs text-muted-foreground">
                        {type.description}
                      </span>
                    </div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          )}
        />
        {errors.type && (
          <p className="text-sm text-destructive">{errors.type.message}</p>
        )}
      </div>

      {/* Required Toggle */}
      <div className="flex items-center justify-between">
        <div className="space-y-0.5">
          <Label htmlFor="required">Required</Label>
          <p className="text-sm text-muted-foreground">
            Records must have a value for this field
          </p>
        </div>
        <Controller
          name="required"
          control={control}
          render={({ field: formField }) => (
            <Switch
              id="required"
              checked={formField.value}
              onCheckedChange={formField.onChange}
              disabled={loading}
            />
          )}
        />
      </div>

      {/* Relation Target (conditional) */}
      {fieldType === "relation" && (
        <div className="space-y-2">
          <Label htmlFor="target">Target Collection</Label>
          <Controller
            name="options.target"
            control={control}
            rules={{
              required:
                fieldType === "relation"
                  ? "Target collection is required for relations"
                  : false,
            }}
            render={({ field: formField }) => (
              <Select
                value={formField.value ?? ""}
                onValueChange={formField.onChange}
                disabled={loading}
              >
                <SelectTrigger id="target">
                  <SelectValue placeholder="Select target collection" />
                </SelectTrigger>
                <SelectContent>
                  {availableCollections.length === 0 ? (
                    <div className="px-2 py-1.5 text-sm text-muted-foreground">
                      No other collections available
                    </div>
                  ) : (
                    availableCollections.map((c) => (
                      <SelectItem key={c.id} value={c.name}>
                        {c.name}
                      </SelectItem>
                    ))
                  )}
                </SelectContent>
              </Select>
            )}
          />
          {errors.options?.target && (
            <p className="text-sm text-destructive">
              {errors.options.target.message}
            </p>
          )}
        </div>
      )}

      {/* Submit Button */}
      <Button type="submit" className="w-full" disabled={loading}>
        {loading ? "Saving..." : field ? "Update Field" : "Create Field"}
      </Button>
    </form>
  );
}
```

2. Create `src/admin/components/schema/FieldSheet.tsx`:

```typescript
/**
 * Field sheet component - slide-over panel for field form.
 * Wraps FieldForm in a Sheet for consistent UX with RecordSheet.
 */

import type { Field, FieldInput, Collection } from "@/lib/api";
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { FieldForm } from "./FieldForm";

interface FieldSheetProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  field: Field | null;
  collections: Collection[];
  currentCollection: string;
  onSubmit: (data: FieldInput) => void;
  loading: boolean;
}

/**
 * FieldSheet displays the field form in a slide-over panel.
 */
export function FieldSheet({
  open,
  onOpenChange,
  field,
  collections,
  currentCollection,
  onSubmit,
  loading,
}: FieldSheetProps) {
  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent>
        <SheetHeader>
          <SheetTitle>{field ? "Edit Field" : "New Field"}</SheetTitle>
          <SheetDescription>
            {field
              ? `Modify the "${field.name}" field configuration.`
              : "Add a new field to this collection."}
          </SheetDescription>
        </SheetHeader>
        <div className="mt-6">
          <FieldForm
            field={field}
            collections={collections}
            currentCollection={currentCollection}
            onSubmit={onSubmit}
            loading={loading}
          />
        </div>
      </SheetContent>
    </Sheet>
  );
}
```
  </action>
  <verify>TypeScript compiles:
- `bun build src/admin/components/schema/FieldForm.tsx --no-bundle` succeeds
- `bun build src/admin/components/schema/FieldSheet.tsx --no-bundle` succeeds</verify>
  <done>FieldForm with type selector and conditional relation target, wrapped in FieldSheet slide-over panel.</done>
</task>

<task type="auto">
  <name>Task 3: Create SchemaView container component</name>
  <files>src/admin/components/schema/SchemaView.tsx</files>
  <action>
Create `src/admin/components/schema/SchemaView.tsx`:

```typescript
/**
 * Schema view component - main container for schema editor.
 * Displays fields table with add/edit/delete capabilities.
 */

import { useState, useEffect } from "react";
import { Plus, ArrowLeft, Trash2 } from "lucide-react";
import { toast } from "sonner";
import { FieldsTable } from "./FieldsTable";
import { FieldSheet } from "./FieldSheet";
import { useSchema } from "@/hooks/useSchema";
import {
  addField,
  updateField,
  deleteField,
  deleteCollection,
  fetchCollections,
  type Field,
  type FieldInput,
  type Collection,
} from "@/lib/api";
import { Button } from "@/components/ui/button";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

interface SchemaViewProps {
  collection: string;
  onBack: () => void;
  onCollectionDeleted: () => void;
}

/**
 * SchemaView displays the schema editor for a collection.
 * Allows adding, editing, and deleting fields.
 */
export function SchemaView({
  collection,
  onBack,
  onCollectionDeleted,
}: SchemaViewProps) {
  const { fields, loading, error, refetch } = useSchema(collection);
  const [collections, setCollections] = useState<Collection[]>([]);

  // Sheet state
  const [sheetOpen, setSheetOpen] = useState(false);
  const [editingField, setEditingField] = useState<Field | null>(null);
  const [saving, setSaving] = useState(false);

  // Delete field dialog state
  const [deleteFieldOpen, setDeleteFieldOpen] = useState(false);
  const [deletingField, setDeletingField] = useState<Field | null>(null);
  const [deletingFieldLoading, setDeletingFieldLoading] = useState(false);

  // Delete collection dialog state
  const [deleteCollectionOpen, setDeleteCollectionOpen] = useState(false);
  const [deletingCollection, setDeletingCollection] = useState(false);

  // Load collections for relation target selector
  useEffect(() => {
    fetchCollections()
      .then(setCollections)
      .catch((e) => console.error("Failed to load collections:", e));
  }, []);

  // Handle add field
  const handleAddField = () => {
    setEditingField(null);
    setSheetOpen(true);
  };

  // Handle edit field
  const handleEditField = (field: Field) => {
    setEditingField(field);
    setSheetOpen(true);
  };

  // Handle delete field click
  const handleDeleteFieldClick = (field: Field) => {
    setDeletingField(field);
    setDeleteFieldOpen(true);
  };

  // Submit add/edit field
  const handleSubmit = async (data: FieldInput) => {
    setSaving(true);
    try {
      if (editingField) {
        // Update existing field
        await updateField(collection, editingField.name, data);
        toast.success(`Field "${data.name}" updated`);
      } else {
        // Add new field
        await addField(collection, data);
        toast.success(`Field "${data.name}" created`);
      }
      setSheetOpen(false);
      refetch();
    } catch (e) {
      toast.error((e as Error).message);
    } finally {
      setSaving(false);
    }
  };

  // Confirm delete field
  const handleDeleteFieldConfirm = async () => {
    if (!deletingField) return;

    setDeletingFieldLoading(true);
    try {
      await deleteField(collection, deletingField.name);
      toast.success(`Field "${deletingField.name}" deleted`);
      setDeleteFieldOpen(false);
      setDeletingField(null);
      refetch();
    } catch (e) {
      toast.error((e as Error).message);
    } finally {
      setDeletingFieldLoading(false);
    }
  };

  // Confirm delete collection
  const handleDeleteCollectionConfirm = async () => {
    setDeletingCollection(true);
    try {
      await deleteCollection(collection);
      toast.success(`Collection "${collection}" deleted`);
      onCollectionDeleted();
    } catch (e) {
      toast.error((e as Error).message);
      setDeletingCollection(false);
    }
  };

  if (error) {
    return (
      <div className="text-center py-12">
        <p className="text-destructive">Error: {error}</p>
        <Button onClick={refetch} variant="outline" className="mt-4">
          Retry
        </Button>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="sm" onClick={onBack}>
            <ArrowLeft className="mr-2 h-4 w-4" />
            Back
          </Button>
          <div>
            <h2 className="text-xl font-semibold">Schema: {collection}</h2>
            <p className="text-sm text-muted-foreground">
              {loading ? "Loading..." : `${fields.length} field${fields.length !== 1 ? "s" : ""}`}
            </p>
          </div>
        </div>
        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={() => setDeleteCollectionOpen(true)}
            className="text-destructive hover:text-destructive"
          >
            <Trash2 className="mr-2 h-4 w-4" />
            Delete Collection
          </Button>
          <Button onClick={handleAddField}>
            <Plus className="mr-2 h-4 w-4" />
            Add Field
          </Button>
        </div>
      </div>

      {/* System fields info */}
      <div className="rounded-md border border-blue-200 bg-blue-50 p-4 text-sm text-blue-800">
        <strong>System fields:</strong> Every collection automatically includes{" "}
        <code className="font-mono">id</code>,{" "}
        <code className="font-mono">created_at</code>, and{" "}
        <code className="font-mono">updated_at</code> fields. These are managed
        by the system and cannot be modified.
      </div>

      {/* Fields table */}
      <FieldsTable
        fields={fields}
        loading={loading}
        onEdit={handleEditField}
        onDelete={handleDeleteFieldClick}
      />

      {/* Field sheet */}
      <FieldSheet
        open={sheetOpen}
        onOpenChange={setSheetOpen}
        field={editingField}
        collections={collections}
        currentCollection={collection}
        onSubmit={handleSubmit}
        loading={saving}
      />

      {/* Delete field confirmation */}
      <AlertDialog open={deleteFieldOpen} onOpenChange={setDeleteFieldOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete field?</AlertDialogTitle>
            <AlertDialogDescription>
              This will permanently delete the{" "}
              <code className="font-mono bg-muted px-1 rounded">
                {deletingField?.name}
              </code>{" "}
              field and all its data from every record in this collection. This
              action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={deletingFieldLoading}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDeleteFieldConfirm}
              disabled={deletingFieldLoading}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              {deletingFieldLoading ? "Deleting..." : "Delete Field"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Delete collection confirmation */}
      <AlertDialog
        open={deleteCollectionOpen}
        onOpenChange={setDeleteCollectionOpen}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete collection?</AlertDialogTitle>
            <AlertDialogDescription>
              This will permanently delete the{" "}
              <code className="font-mono bg-muted px-1 rounded">
                {collection}
              </code>{" "}
              collection and ALL its records. This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={deletingCollection}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDeleteCollectionConfirm}
              disabled={deletingCollection}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              {deletingCollection ? "Deleting..." : "Delete Collection"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
```
  </action>
  <verify>TypeScript compiles: `bun build src/admin/components/schema/SchemaView.tsx --no-bundle` succeeds.</verify>
  <done>SchemaView container with fields table, add/edit sheet, and delete confirmations for both fields and collection.</done>
</task>

</tasks>

<verification>
1. All schema components exist in src/admin/components/schema/
2. FieldsTable displays fields with type badges, required status, and actions
3. FieldForm has field type selector with all 6 types
4. FieldForm shows target collection selector when type is "relation"
5. FieldSheet wraps FieldForm in slide-over panel
6. SchemaView integrates all components with CRUD operations
7. Delete confirmations warn about data loss
8. All TypeScript files compile without errors
</verification>

<success_criteria>
1. Components compile without TypeScript errors
2. FieldsTable can render a list of fields with type badges
3. FieldForm validates field name (starts with letter, alphanumeric + underscore, not reserved)
4. FieldForm shows relation target dropdown only when type is "relation"
5. SchemaView can add, edit, and delete fields
6. Delete dialogs show appropriate warnings about data loss
</success_criteria>

<output>
After completion, create `.planning/phases/07-admin-ui-schema-editor/07-03-SUMMARY.md`
</output>
