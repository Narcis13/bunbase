---
phase: 07-admin-ui-schema-editor
plan: 04
type: execute
wave: 3
depends_on: ["07-03"]
files_modified:
  - src/admin/App.tsx
  - src/admin/components/layout/AppSidebar.tsx
  - src/admin/components/layout/Layout.tsx
  - src/admin/components/schema/CreateCollectionSheet.tsx
autonomous: false

must_haves:
  truths:
    - "Admin can navigate to schema editor from collection view"
    - "Admin can create a new collection from the sidebar"
    - "Schema changes appear immediately in sidebar"
    - "Deleting collection returns to dashboard"
  artifacts:
    - path: "src/admin/App.tsx"
      provides: "Extended view state with schema view"
      contains: "type.*schema"
    - path: "src/admin/components/layout/AppSidebar.tsx"
      provides: "Schema edit button and create collection button"
      contains: "Edit Schema"
    - path: "src/admin/components/layout/Layout.tsx"
      provides: "Passes onSchemaEdit and onRefreshCollections to AppSidebar"
      contains: "onSchemaEdit"
    - path: "src/admin/components/schema/CreateCollectionSheet.tsx"
      provides: "Form to create new collection"
      contains: "CreateCollectionSheet"
  key_links:
    - from: "src/admin/App.tsx"
      to: "src/admin/components/schema/SchemaView.tsx"
      via: "renders SchemaView for schema view type"
      pattern: "SchemaView"
    - from: "src/admin/components/layout/AppSidebar.tsx"
      to: "src/admin/lib/api.ts"
      via: "calls createCollection"
      pattern: "createCollection"
    - from: "src/admin/components/layout/AppSidebar.tsx"
      to: "src/admin/hooks/useCollections.ts"
      via: "exposes refetch for sidebar refresh"
      pattern: "refetch"
    - from: "src/admin/components/layout/Layout.tsx"
      to: "src/admin/components/layout/AppSidebar.tsx"
      via: "passes onSchemaEdit and onRefreshCollections props"
      pattern: "onSchemaEdit|onRefreshCollections"
---

<objective>
Integrate the schema editor into the admin UI with navigation from collection view, create collection functionality in sidebar, and proper view state handling.

Purpose: Users need to navigate to the schema editor and create new collections. This plan wires up the schema editor components into the existing app routing and adds create collection capability.

Output: Complete integration of schema editor with navigation and collection creation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/admin/App.tsx
@src/admin/components/layout/AppSidebar.tsx
@src/admin/components/layout/Layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CreateCollectionSheet component</name>
  <files>src/admin/components/schema/CreateCollectionSheet.tsx</files>
  <action>
Create `src/admin/components/schema/CreateCollectionSheet.tsx`:

```typescript
/**
 * Create collection sheet - form to create a new collection.
 * Opens from sidebar "New Collection" button.
 */

import { useState } from "react";
import { useForm } from "react-hook-form";
import { toast } from "sonner";
import { createCollection, type FieldInput } from "@/lib/api";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";

interface CreateCollectionSheetProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onCreated: (collectionName: string) => void;
}

interface FormData {
  name: string;
}

/**
 * CreateCollectionSheet allows creating a new empty collection.
 * After creation, navigates to the schema editor to add fields.
 */
export function CreateCollectionSheet({
  open,
  onOpenChange,
  onCreated,
}: CreateCollectionSheetProps) {
  const [loading, setLoading] = useState(false);

  const {
    register,
    handleSubmit,
    reset,
    formState: { errors },
  } = useForm<FormData>({
    defaultValues: { name: "" },
  });

  const onSubmit = async (data: FormData) => {
    setLoading(true);
    try {
      // Create empty collection (no fields initially)
      await createCollection(data.name, []);
      toast.success(`Collection "${data.name}" created`);
      reset();
      onOpenChange(false);
      // Navigate to schema editor for the new collection
      onCreated(data.name);
    } catch (e) {
      toast.error((e as Error).message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent>
        <SheetHeader>
          <SheetTitle>New Collection</SheetTitle>
          <SheetDescription>
            Create a new collection. You can add fields in the schema editor
            after creation.
          </SheetDescription>
        </SheetHeader>
        <form onSubmit={handleSubmit(onSubmit)} className="mt-6 space-y-6">
          <div className="space-y-2">
            <Label htmlFor="collection-name">Collection Name</Label>
            <Input
              id="collection-name"
              placeholder="e.g., posts, products, users"
              {...register("name", {
                required: "Collection name is required",
                pattern: {
                  value: /^[a-zA-Z][a-zA-Z0-9_]*$/,
                  message:
                    "Must start with letter, contain only letters, numbers, underscores",
                },
                validate: {
                  notSystem: (value) =>
                    !value.startsWith("_") ||
                    "Names starting with underscore are reserved for system collections",
                },
              })}
              disabled={loading}
            />
            {errors.name && (
              <p className="text-sm text-destructive">{errors.name.message}</p>
            )}
            <p className="text-xs text-muted-foreground">
              Use lowercase letters and underscores (e.g., blog_posts)
            </p>
          </div>

          <Button type="submit" className="w-full" disabled={loading}>
            {loading ? "Creating..." : "Create Collection"}
          </Button>
        </form>
      </SheetContent>
    </Sheet>
  );
}
```
  </action>
  <verify>TypeScript compiles: `bun build src/admin/components/schema/CreateCollectionSheet.tsx --no-bundle` succeeds.</verify>
  <done>CreateCollectionSheet component ready for integration with sidebar.</done>
</task>

<task type="auto">
  <name>Task 2: Update AppSidebar with schema navigation and create collection</name>
  <files>src/admin/components/layout/AppSidebar.tsx</files>
  <action>
Update `src/admin/components/layout/AppSidebar.tsx` to add:
1. "Edit Schema" button next to each collection
2. "New Collection" button at the bottom of collections list
3. Accept refetch callback from parent for sidebar refresh

Read the current file first, then modify it to add:

1. Import CreateCollectionSheet and Settings icon:
```typescript
import { Database, Settings, Plus, LayoutDashboard } from "lucide-react";
import { CreateCollectionSheet } from "@/components/schema/CreateCollectionSheet";
import { Button } from "@/components/ui/button";
```

2. Add state for create collection sheet:
```typescript
const [createOpen, setCreateOpen] = useState(false);
```

3. Update the AppSidebarProps interface to include schema navigation and refetch:
```typescript
interface AppSidebarProps {
  currentCollection?: string;
  onNavigate: (view: { type: string; collection?: string }) => void;
  onSchemaEdit?: (collection: string) => void;
  onRefreshCollections?: () => void;
}
```

4. Update the component signature and destructure refetch from useCollections:
```typescript
export function AppSidebar({
  currentCollection,
  onNavigate,
  onSchemaEdit,
  onRefreshCollections,
}: AppSidebarProps) {
  const { collections, loading, refetch } = useCollections();
  const [createOpen, setCreateOpen] = useState(false);
```

5. In each collection SidebarMenuItem, wrap the button in a div with hover effect for the settings icon:
```typescript
<SidebarMenuItem key={collection.id}>
  <div className="flex items-center group">
    <SidebarMenuButton
      onClick={() =>
        onNavigate({
          type: "collection",
          collection: collection.name,
        })
      }
      isActive={currentCollection === collection.name}
      className="flex-1"
    >
      <Database className="h-4 w-4" />
      <span className="truncate">{collection.name}</span>
      <span className="ml-auto text-xs text-muted-foreground">
        {collection.recordCount}
      </span>
    </SidebarMenuButton>
    {onSchemaEdit && (
      <Button
        variant="ghost"
        size="sm"
        className="h-7 w-7 p-0 opacity-0 group-hover:opacity-100 transition-opacity"
        onClick={(e) => {
          e.stopPropagation();
          onSchemaEdit(collection.name);
        }}
        title="Edit Schema"
      >
        <Settings className="h-3.5 w-3.5" />
      </Button>
    )}
  </div>
</SidebarMenuItem>
```

6. Add "New Collection" button after the SidebarMenu in the user collections section:
```typescript
<SidebarGroupContent>
  {loading ? (
    // ... existing loading skeleton ...
  ) : userCollections.length === 0 ? (
    // ... existing empty state ...
  ) : (
    <SidebarMenu>
      {/* ... existing collection items ... */}
    </SidebarMenu>
  )}
  <Button
    variant="outline"
    size="sm"
    className="w-full mt-2"
    onClick={() => setCreateOpen(true)}
  >
    <Plus className="mr-2 h-4 w-4" />
    New Collection
  </Button>
</SidebarGroupContent>
```

7. Add CreateCollectionSheet at the end of the Sidebar component (before closing </Sidebar>):
```typescript
<CreateCollectionSheet
  open={createOpen}
  onOpenChange={setCreateOpen}
  onCreated={(name) => {
    // Refresh collections list in sidebar
    refetch();
    // Also call parent's refresh if provided (for consistency)
    onRefreshCollections?.();
    // Navigate to schema editor for the new collection
    if (onSchemaEdit) {
      onSchemaEdit(name);
    }
  }}
/>
```
  </action>
  <verify>TypeScript compiles: `bun build src/admin/components/layout/AppSidebar.tsx --no-bundle` succeeds.</verify>
  <done>AppSidebar has schema edit buttons, new collection button, create collection sheet integration, and exposes refetch capability.</done>
</task>

<task type="auto">
  <name>Task 3: Extend App.tsx and Layout.tsx for schema editor integration</name>
  <files>src/admin/App.tsx, src/admin/components/layout/Layout.tsx</files>
  <action>
1. Update `src/admin/components/layout/Layout.tsx` to pass through onSchemaEdit and onRefreshCollections to AppSidebar:

Read the current file first, then modify:

```typescript
/**
 * Main layout component for admin UI.
 * Provides sidebar navigation and content area.
 */

import { SidebarProvider, SidebarInset, SidebarTrigger } from "@/components/ui/sidebar";
import { AppSidebar } from "./AppSidebar";

interface LayoutProps {
  children: React.ReactNode;
  currentCollection?: string;
  onNavigate: (view: { type: string; collection?: string }) => void;
  onSchemaEdit?: (collection: string) => void;
  onRefreshCollections?: () => void;
}

/**
 * Layout provides the main structure for the admin UI.
 * Includes sidebar navigation and main content area with header.
 *
 * @param children - Content to render in the main area
 * @param currentCollection - Name of the currently selected collection
 * @param onNavigate - Callback for view navigation
 * @param onSchemaEdit - Callback to navigate to schema editor
 * @param onRefreshCollections - Callback to refresh collections in sidebar
 */
export function Layout({
  children,
  currentCollection,
  onNavigate,
  onSchemaEdit,
  onRefreshCollections,
}: LayoutProps) {
  return (
    <SidebarProvider>
      <AppSidebar
        currentCollection={currentCollection}
        onNavigate={onNavigate}
        onSchemaEdit={onSchemaEdit}
        onRefreshCollections={onRefreshCollections}
      />
      <SidebarInset>
        <header className="flex h-14 items-center gap-4 border-b px-4">
          <SidebarTrigger />
          <h1 className="text-lg font-semibold">
            {currentCollection || "Dashboard"}
          </h1>
        </header>
        <main className="flex-1 p-4">{children}</main>
      </SidebarInset>
    </SidebarProvider>
  );
}
```

2. Update `src/admin/App.tsx` to:
   - Add schema view type
   - Import and render SchemaView
   - Wire up navigation callbacks
   - Create a ref-based refetch mechanism for collections

Read the current file first, then modify:

a. Import SchemaView and useRef:
```typescript
import { useState, useRef, useCallback } from "react";
import { SchemaView } from "@/components/schema/SchemaView";
```

b. Extend the View type:
```typescript
type View =
  | { type: "dashboard" }
  | { type: "collection"; collection: string }
  | { type: "schema"; collection: string };
```

c. Add a ref for triggering sidebar refresh:
```typescript
// Ref to hold the current refetch function from sidebar
const refreshCollectionsRef = useRef<(() => void) | null>(null);

// Callback to trigger sidebar refresh
const handleRefreshCollections = useCallback(() => {
  refreshCollectionsRef.current?.();
}, []);
```

d. Update the handleNavigate function to handle schema view:
```typescript
const handleNavigate = (newView: { type: string; collection?: string }) => {
  if (newView.type === "dashboard") {
    setView({ type: "dashboard" });
  } else if (newView.type === "collection" && newView.collection) {
    setView({ type: "collection", collection: newView.collection });
  } else if (newView.type === "schema" && newView.collection) {
    setView({ type: "schema", collection: newView.collection });
  }
};
```

e. Add schema edit handler:
```typescript
const handleSchemaEdit = (collection: string) => {
  setView({ type: "schema", collection });
};
```

f. Update the Layout component to pass all props:
```typescript
<Layout
  currentCollection={
    view.type === "collection"
      ? view.collection
      : view.type === "schema"
        ? view.collection
        : undefined
  }
  onNavigate={handleNavigate}
  onSchemaEdit={handleSchemaEdit}
  onRefreshCollections={handleRefreshCollections}
>
```

g. Add SchemaView rendering in the return statement (after collection view):
```typescript
{view.type === "schema" && (
  <SchemaView
    collection={view.collection}
    onBack={() => setView({ type: "collection", collection: view.collection })}
    onCollectionDeleted={() => {
      handleRefreshCollections();
      setView({ type: "dashboard" });
    }}
    onRefreshCollections={handleRefreshCollections}
  />
)}
```

Note: The ref-based approach allows App.tsx to trigger sidebar refreshes without lifting all state up. The AppSidebar can call onRefreshCollections prop, and App.tsx can also call it when SchemaView modifies collections.
  </action>
  <verify>Start dev server: `bun --hot src/api/server.ts &`
Navigate to http://localhost:8090/_/ and verify:
1. Collections show Settings icon on hover
2. "New Collection" button appears at bottom of collections
3. Clicking Settings icon shows schema editor
4. Creating a new collection navigates to schema editor</verify>
  <done>App.tsx has schema view routing, Layout.tsx passes props through, and sidebar refresh mechanism is wired up.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete schema editor integration with navigation, create collection, and field CRUD</what-built>
  <how-to-verify>
1. Start the server: `bun --hot src/api/server.ts`
2. Open http://localhost:8090/_/ and log in with admin credentials
3. Test create collection:
   - Click "New Collection" button in sidebar
   - Enter collection name (e.g., "products")
   - Verify it creates and navigates to schema editor
   - Verify the new collection appears in the sidebar immediately
4. Test add field:
   - Click "Add Field" button
   - Fill in: name="title", type="text", required=on
   - Click "Create Field"
   - Verify field appears in table
   - Verify sidebar field count updates
5. Test edit field:
   - Click the three-dot menu on the field row
   - Click "Edit"
   - Change required to off
   - Click "Update Field"
   - Verify change appears
6. Test delete field:
   - Click the three-dot menu on a field
   - Click "Delete"
   - Confirm deletion
   - Verify field is removed
   - Verify sidebar field count updates
7. Test delete collection:
   - Click "Delete Collection" button
   - Confirm deletion
   - Verify it returns to dashboard and collection is gone from sidebar
8. Test navigation:
   - Hover over a collection in sidebar - Settings icon should appear
   - Click Settings icon - should show schema editor
   - Click "Back" button - should return to records view
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. Create collection form validates name (starts with letter, alphanumeric + underscore)
2. Create collection creates empty collection and navigates to schema editor
3. Schema editor shows fields table with add/edit/delete
4. Adding/editing fields uses Select for type dropdown
5. Relation fields show target collection selector
6. Delete confirmations warn about data loss
7. Navigation works: sidebar -> schema -> back to records
8. Schema changes reflect immediately in the sidebar (field counts, collection list)
</verification>

<success_criteria>
1. Admin can create a new collection via "New Collection" button
2. Admin can navigate to schema editor via Settings icon on collection
3. Admin can add, edit, and delete fields
4. Admin can delete entire collection
5. Schema changes take effect immediately (sidebar updates, new fields usable in records view)
6. All navigation flows work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/07-admin-ui-schema-editor/07-04-SUMMARY.md`
</output>
