---
phase: 12-realtime-sse
plan: 04
type: execute
wave: 2
depends_on: ["12-01", "12-02"]
files_modified:
  - src/realtime/manager.ts
  - src/api/server.ts
autonomous: true

must_haves:
  truths:
    - "Client can subscribe to collection changes via POST /api/realtime"
    - "Client can subscribe to specific record changes"
    - "Client can unsubscribe by sending empty subscriptions array"
    - "Invalid client ID returns 404"
    - "Auth context is captured for permission filtering"
  artifacts:
    - path: "src/api/server.ts"
      provides: "POST /api/realtime endpoint for subscriptions"
      contains: "POST:"
  key_links:
    - from: "src/api/server.ts"
      to: "src/realtime/manager.ts"
      via: "setSubscriptions"
      pattern: "setSubscriptions"
    - from: "src/api/server.ts"
      to: "src/realtime/topics.ts"
      via: "topic parsing"
      pattern: "parseTopic"
---

<objective>
Implement subscription management endpoint for subscribing to collection and record changes.

Purpose: Enable clients to subscribe/unsubscribe to topics (SSE-03, SSE-04, SSE-08).
Output: POST /api/realtime endpoint that manages client subscriptions
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-realtime-sse/12-RESEARCH.md

# Required for implementation
@src/api/server.ts
@src/realtime/manager.ts
@src/realtime/topics.ts
@src/auth/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add subscription parsing to manager</name>
  <files>src/realtime/manager.ts</files>
  <action>
Update RealtimeManager to parse and store subscriptions:

1. In `src/realtime/manager.ts`:
   - Import `parseTopic`, `Subscription` from `./topics`
   - If Subscription is defined locally in manager.ts, remove it and import from topics.ts instead
   - Ensure topics.ts exports Subscription type

2. Update `setSubscriptions` method:
   ```typescript
   setSubscriptions(clientId: string, topics: string[]): void {
     const client = this.clients.get(clientId);
     if (!client) return;

     // Parse topics into subscriptions, filter out invalid ones
     client.subscriptions = topics
       .map(topic => parseTopic(topic))
       .filter((s): s is Subscription => s !== null);

     client.lastActivity = Date.now();
   }
   ```

3. Add method `getSubscribersForRecord(collection: string, recordId: string): RealtimeClient[]`:
   - Import `matchesSubscription` from `./topics`
   - Iterate over all clients
   - For each client, check if any subscription matches
   - Return array of matching clients

   ```typescript
   getSubscribersForRecord(collection: string, recordId: string): RealtimeClient[] {
     const subscribers: RealtimeClient[] = [];

     for (const client of this.clients.values()) {
       for (const sub of client.subscriptions) {
         if (matchesSubscription(sub, collection, recordId)) {
           subscribers.push(client);
           break; // Don't add same client twice
         }
       }
     }

     return subscribers;
   }
   ```

4. Add test for getSubscribersForRecord in manager.test.ts
  </action>
  <verify>Run `bun test src/realtime/manager.test.ts` - all tests pass including new subscriber lookup</verify>
  <done>RealtimeManager parses topic strings and can find subscribers for a record</done>
</task>

<task type="auto">
  <name>Task 2: Add POST /api/realtime endpoint</name>
  <files>src/api/server.ts</files>
  <action>
Add POST endpoint for subscription management:

1. In the existing `/api/realtime` route object, add POST handler:

```typescript
"/api/realtime": {
  GET: async (req) => { /* existing SSE connection handler */ },

  POST: async (req) => {
    try {
      interface SubscriptionRequest {
        clientId: string;
        subscriptions?: string[];
      }

      const body = await req.json() as SubscriptionRequest;

      if (!body.clientId) {
        return Response.json({ error: "clientId is required" }, { status: 400 });
      }

      // Verify client exists
      const client = realtimeManager.getClient(body.clientId);
      if (!client) {
        return Response.json({ error: "Invalid client ID" }, { status: 404 });
      }

      // Extract optional user auth
      const user = await optionalUser(req);

      // If client already has auth, verify it matches (prevent hijacking)
      if (client.user && user && client.user.id !== user.id) {
        return Response.json({ error: "Authorization mismatch" }, { status: 403 });
      }

      // Set auth context if provided and not already set
      if (user && !client.user) {
        realtimeManager.setClientAuth(body.clientId, user);
      }

      // Update subscriptions (empty array = unsubscribe all)
      const subscriptions = body.subscriptions ?? [];
      realtimeManager.setSubscriptions(body.clientId, subscriptions);

      return new Response(null, { status: 204 });
    } catch (error) {
      return Response.json({ error: "Invalid request body" }, { status: 400 });
    }
  },
},
```

2. Ensure optionalUser is imported from auth/middleware (already should be)

3. The endpoint:
   - Requires clientId in body
   - Returns 404 if client not found (SSE connection must be established first)
   - Optionally accepts Authorization header for user context
   - Validates auth doesn't change mid-session
   - Parses and stores subscriptions
   - Empty subscriptions array clears all subscriptions (unsubscribe)
   - Returns 204 No Content on success
  </action>
  <verify>
1. Start server: `bun run src/api/server.ts`
2. Connect SSE: `curl -N http://localhost:8090/api/realtime` (note clientId from PB_CONNECT)
3. Subscribe: `curl -X POST http://localhost:8090/api/realtime -H "Content-Type: application/json" -d '{"clientId":"<id>","subscriptions":["posts/*"]}'` - returns 204
4. Invalid clientId: `curl -X POST http://localhost:8090/api/realtime -H "Content-Type: application/json" -d '{"clientId":"invalid","subscriptions":["posts/*"]}'` - returns 404
  </verify>
  <done>POST /api/realtime accepts clientId and subscriptions, stores them in manager, supports optional auth</done>
</task>

</tasks>

<verification>
- POST /api/realtime with valid clientId returns 204
- POST /api/realtime with invalid clientId returns 404
- POST /api/realtime without clientId returns 400
- Subscriptions are parsed and stored (can verify via getSubscribersForRecord)
- `bun test src/realtime/` passes all tests
</verification>

<success_criteria>
1. Client can subscribe to topics after establishing SSE connection
2. Invalid client IDs are rejected with 404
3. Empty subscriptions array clears all subscriptions
4. Auth context is captured from Authorization header
5. Auth mismatch returns 403
</success_criteria>

<output>
After completion, create `.planning/phases/12-realtime-sse/12-04-SUMMARY.md`
</output>
