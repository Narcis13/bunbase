---
phase: 12-realtime-sse
plan: 03
type: execute
wave: 2
depends_on: ["12-01", "12-02"]
files_modified:
  - src/realtime/manager.ts
  - src/api/server.ts
autonomous: true

must_haves:
  truths:
    - "Client can connect to GET /api/realtime and receive SSE stream"
    - "Client receives PB_CONNECT event with clientId on connect"
    - "Connection stays open with periodic ping comments"
    - "Client disconnection is detected and client removed from manager"
  artifacts:
    - path: "src/api/server.ts"
      provides: "SSE endpoint at /api/realtime"
      contains: '"/api/realtime"'
  key_links:
    - from: "src/api/server.ts"
      to: "src/realtime/manager.ts"
      via: "RealtimeManager instance"
      pattern: "realtimeManager"
    - from: "src/api/server.ts"
      to: "src/realtime/sse.ts"
      via: "message formatting"
      pattern: "formatSSE"
---

<objective>
Implement SSE connection endpoint with client ID assignment and keep-alive pings.

Purpose: Enable clients to establish SSE connections and receive realtime events (SSE-01, SSE-02, SSE-09).
Output: GET /api/realtime endpoint that sends PB_CONNECT event and maintains connection with pings
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-realtime-sse/12-RESEARCH.md

# Required for implementation
@src/api/server.ts
@src/realtime/sse.ts
@src/realtime/manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sendSSE helpers to manager</name>
  <files>src/realtime/manager.ts</files>
  <action>
Add helper methods to RealtimeManager for sending SSE messages:

1. Update `src/realtime/manager.ts`:
   - Import `formatSSEMessage`, `formatSSEComment` from `./sse`
   - Import `nanoid` from nanoid

   - Add async method `sendEvent(clientId: string, event: string, data: unknown): Promise<boolean>`
     - Get client from map
     - If not found, return false
     - Format message with formatSSEMessage({ event, data, id: nanoid() })
     - Write to controller: `await controller.write(message)`
     - Flush controller: `await controller.flush()`
     - Return true
     - Wrap in try/catch - on error, return false (client likely disconnected)

   - Add async method `sendComment(clientId: string, comment: string): Promise<boolean>`
     - Get client from map
     - If not found, return false
     - Format with formatSSEComment(comment)
     - Write and flush
     - Return true
     - Wrap in try/catch - on error, return false

   - Add method `getAllClientIds(): string[]` - returns Array.from(clients.keys())
  </action>
  <verify>Run `bun test src/realtime/manager.test.ts` - existing tests still pass</verify>
  <done>RealtimeManager can send SSE events and comments to clients</done>
</task>

<task type="auto">
  <name>Task 2: Add SSE connection endpoint to server</name>
  <files>src/api/server.ts</files>
  <action>
Add GET /api/realtime endpoint for SSE connections:

1. In `src/api/server.ts`:
   - Import `RealtimeManager` from `../realtime/manager`
   - Import `formatSSEMessage`, `formatSSEComment` from `../realtime/sse`
   - Import `nanoid` from `nanoid`

2. In `createServer` function:
   - Create RealtimeManager instance (or accept as parameter like hookManager)
   - Store reference for broadcasting (export or pass to hooks)

3. Add route in routes object:
   ```typescript
   "/api/realtime": {
     GET: async (req) => {
       const clientId = nanoid();
       const signal = req.signal;

       return new Response(
         new ReadableStream({
           type: "direct",
           async pull(controller: ReadableStreamDirectController) {
             // Send PB_CONNECT event with clientId
             const connectMsg = formatSSEMessage({
               event: "PB_CONNECT",
               data: { clientId },
               id: nanoid(),
             });
             await controller.write(connectMsg);
             await controller.flush();

             // Register client with manager
             realtimeManager.registerClient(clientId, controller);

             // Ping loop - every 30 seconds
             const pingInterval = 30000;
             while (!signal.aborted) {
               await Bun.sleep(pingInterval);
               if (!signal.aborted) {
                 try {
                   const ping = formatSSEComment("ping");
                   await controller.write(ping);
                   await controller.flush();
                   realtimeManager.updateActivity(clientId);
                 } catch {
                   break; // Connection error, exit loop
                 }
               }
             }

             // Cleanup on disconnect
             realtimeManager.removeClient(clientId);
             try {
               controller.close();
             } catch {
               // Already closed
             }
           },
         }),
         {
           status: 200,
           headers: {
             "Content-Type": "text/event-stream",
             "Cache-Control": "no-cache, no-transform",
             "Connection": "keep-alive",
             "X-Accel-Buffering": "no",
           },
         }
       );
     },
   },
   ```

4. Update `startServer` to create and pass RealtimeManager (like hookManager pattern)

5. Export realtimeManager instance (or provide getter) for hook integration in later plans
  </action>
  <verify>Start server with `bun run src/api/server.ts`, connect with `curl -N http://localhost:8090/api/realtime` and verify PB_CONNECT event received with clientId</verify>
  <done>GET /api/realtime establishes SSE connection, sends PB_CONNECT with clientId, maintains keep-alive pings</done>
</task>

</tasks>

<verification>
- Server starts without errors
- `curl -N http://localhost:8090/api/realtime` receives:
  - `event: PB_CONNECT` with `data: {"clientId":"..."}` immediately
  - Ping comments (`: ping`) every 30 seconds
- Disconnecting curl removes client from manager
</verification>

<success_criteria>
1. SSE endpoint returns proper Content-Type and headers
2. PB_CONNECT event sent immediately with unique clientId
3. Keep-alive pings sent every 30 seconds
4. Client disconnection detected and cleaned up
5. Server remains stable with multiple concurrent connections
</success_criteria>

<output>
After completion, create `.planning/phases/12-realtime-sse/12-03-SUMMARY.md`
</output>
