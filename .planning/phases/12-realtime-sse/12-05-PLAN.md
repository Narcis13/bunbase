---
phase: 12-realtime-sse
plan: 05
type: execute
wave: 3
depends_on: ["12-03", "12-04"]
files_modified:
  - src/realtime/broadcast.ts
  - src/realtime/broadcast.test.ts
  - src/realtime/hooks.ts
  - src/api/server.ts
autonomous: true

must_haves:
  truths:
    - "Create events are broadcast to collection subscribers"
    - "Update events are broadcast to collection and record subscribers"
    - "Delete events are broadcast to collection and record subscribers"
    - "Events are filtered by collection view/list rules"
    - "Unauthorized subscribers do not receive events"
  artifacts:
    - path: "src/realtime/broadcast.ts"
      provides: "Event broadcasting with permission filtering"
      exports: ["broadcastRecordEvent"]
    - path: "src/realtime/hooks.ts"
      provides: "Hook registration for broadcasting"
      exports: ["registerRealtimeHooks"]
  key_links:
    - from: "src/realtime/hooks.ts"
      to: "src/core/hooks.ts"
      via: "HookManager.on"
      pattern: 'hooks.on\\("after'
    - from: "src/realtime/broadcast.ts"
      to: "src/auth/rules.ts"
      via: "evaluateRule"
      pattern: "evaluateRule"
---

<objective>
Implement event broadcasting with permission filtering and hook integration.

Purpose: Broadcast create/update/delete events to subscribed clients with proper access control (SSE-05, SSE-06, SSE-07).
Output: Broadcasting system that sends events to authorized subscribers only
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-realtime-sse/12-RESEARCH.md

# Required for implementation
@src/realtime/manager.ts
@src/core/hooks.ts
@src/auth/rules.ts
@src/core/schema.ts
@src/api/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create broadcast module with permission filtering</name>
  <files>src/realtime/broadcast.ts, src/realtime/broadcast.test.ts</files>
  <action>
Create broadcasting logic with permission filtering:

1. Create `src/realtime/broadcast.ts`:

```typescript
import type { RealtimeManager, RealtimeClient } from "./manager";
import { matchesSubscription } from "./topics";
import { evaluateRule, type RuleContext } from "../auth/rules";
import { getCollection } from "../core/schema";

export type RecordAction = "create" | "update" | "delete";

/**
 * Broadcast a record event to all authorized subscribers.
 * Fire-and-forget - errors are logged but don't propagate.
 *
 * @param manager - RealtimeManager instance
 * @param action - The action type (create, update, delete)
 * @param collection - Collection name
 * @param record - The record data (for create/update) or { id } for delete
 */
export async function broadcastRecordEvent(
  manager: RealtimeManager,
  action: RecordAction,
  collection: string,
  record: Record<string, unknown>
): Promise<void> {
  const recordId = record.id as string;
  const subscribers = manager.getSubscribersForRecord(collection, recordId);

  if (subscribers.length === 0) return;

  // Get collection for rule evaluation
  const collectionDef = getCollection(collection);
  if (!collectionDef) return;

  for (const client of subscribers) {
    // Determine which rule to check based on subscription type
    const sub = client.subscriptions.find(s =>
      matchesSubscription(s, collection, recordId)
    );
    if (!sub) continue;

    // Collection-wide subscription uses listRule, specific record uses viewRule
    const rule = sub.recordId === "*"
      ? collectionDef.rules?.listRule ?? null
      : collectionDef.rules?.viewRule ?? null;

    // Build auth context for rule evaluation
    const authContext: RuleContext = {
      isAdmin: false, // SSE clients are never admin
      auth: client.user,
      record,
    };

    // Check access permission
    const hasAccess = evaluateRule(rule, authContext);
    if (!hasAccess) continue;

    // Send event - event name is the collection name (PocketBase convention)
    // Data includes action and record
    const eventData = { action, record };

    try {
      await manager.sendEvent(client.id, collection, eventData);
    } catch (error) {
      // Client likely disconnected, remove from manager
      console.error(`Broadcast error for client ${client.id}:`, error);
      manager.removeClient(client.id);
    }
  }
}
```

2. Create `src/realtime/broadcast.test.ts` with tests:
   - Test that subscribers receive events
   - Test that non-subscribers don't receive events
   - Test that unauthorized users don't receive events (rule denies)
   - Test that public collections (empty string rule) allow all
   - Test that locked collections (null rule) deny non-admin
   - Test wildcard vs specific record subscription filtering

Use mock RealtimeManager and mock collection definitions for unit testing.
Import test utilities from existing test patterns.
  </action>
  <verify>Run `bun test src/realtime/broadcast.test.ts` - all tests pass</verify>
  <done>broadcastRecordEvent sends events only to authorized subscribers based on collection rules</done>
</task>

<task type="auto">
  <name>Task 2: Create hook registration for broadcasting</name>
  <files>src/realtime/hooks.ts, src/api/server.ts</files>
  <action>
Create hook registration and integrate with server:

1. Create `src/realtime/hooks.ts`:

```typescript
import type { HookManager } from "../core/hooks";
import type { RealtimeManager } from "./manager";
import { broadcastRecordEvent } from "./broadcast";

/**
 * Register realtime hooks for broadcasting record events.
 * Hooks are fire-and-forget - they don't block the API response.
 */
export function registerRealtimeHooks(
  hooks: HookManager,
  realtimeManager: RealtimeManager
): void {
  // afterCreate - broadcast to collection subscribers
  hooks.on("afterCreate", async (ctx, next) => {
    await next();

    // Fire and forget - don't block response
    broadcastRecordEvent(
      realtimeManager,
      "create",
      ctx.collection,
      ctx.record
    ).catch(err => console.error("Realtime broadcast error:", err));
  });

  // afterUpdate - broadcast to collection and record subscribers
  hooks.on("afterUpdate", async (ctx, next) => {
    await next();

    broadcastRecordEvent(
      realtimeManager,
      "update",
      ctx.collection,
      ctx.record
    ).catch(err => console.error("Realtime broadcast error:", err));
  });

  // afterDelete - broadcast to collection and record subscribers
  hooks.on("afterDelete", async (ctx, next) => {
    await next();

    // For delete, we only have the ID, not the full record
    // Create minimal record object for broadcasting
    const record = { id: ctx.id };

    broadcastRecordEvent(
      realtimeManager,
      "delete",
      ctx.collection,
      record
    ).catch(err => console.error("Realtime broadcast error:", err));
  });
}
```

2. Update `src/api/server.ts` in `startServer`:
   - Import `registerRealtimeHooks` from `../realtime/hooks`
   - After creating realtimeManager and before returning server
   - Call `registerRealtimeHooks(hookManager, realtimeManager)`

```typescript
// In startServer function, after realtimeManager is created:
registerRealtimeHooks(hookManager, realtimeManager);
```

3. Create `src/realtime/index.ts` to export all realtime modules:
```typescript
export { RealtimeManager, type RealtimeClient, type Subscription } from "./manager";
export { formatSSEMessage, formatSSEComment, type SSEMessage } from "./sse";
export { parseTopic, matchesSubscription, formatTopic } from "./topics";
export { broadcastRecordEvent, type RecordAction } from "./broadcast";
export { registerRealtimeHooks } from "./hooks";
```
  </action>
  <verify>
1. Start server: `bun run src/api/server.ts`
2. Open SSE connection and subscribe to a collection
3. Create/update/delete a record in that collection via API
4. Verify SSE client receives the event
  </verify>
  <done>Record create/update/delete events are broadcast to subscribed clients with permission filtering</done>
</task>

</tasks>

<verification>
- `bun test src/realtime/` passes all tests
- SSE client subscribed to "posts/*" receives create/update/delete events for posts
- SSE client subscribed to "posts/abc123" only receives events for that specific record
- Unauthorized clients (based on collection rules) don't receive events
- API responses are not delayed by broadcast operations (fire-and-forget)
</verification>

<success_criteria>
1. afterCreate broadcasts to collection/* subscribers
2. afterUpdate broadcasts to collection/* and collection/recordId subscribers
3. afterDelete broadcasts to collection/* and collection/recordId subscribers
4. Events respect collection view/list rules
5. Broadcast errors don't affect API responses
6. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-realtime-sse/12-05-SUMMARY.md`
</output>
