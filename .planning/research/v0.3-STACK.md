# Stack Research: BunBase v0.3

**Project:** BunBase v0.3 - Custom API Routes & Unified Error Handling
**Researched:** 2026-01-30
**Mode:** Stack dimension research for subsequent milestone
**Confidence:** HIGH

## Executive Summary

No new dependencies are needed for v0.3. Bun provides all required capabilities natively:

1. **Custom routes** - `Bun.serve()` routes are static at compile time, but the existing `fetch()` fallback pattern can handle dynamic dispatch to user-defined handlers
2. **Error responses** - Requires only a unified error class and consistent JSON structure (already partially implemented with `errorResponse()`)
3. **Binary embedding** - Routes must be discovered at build time and imported; Bun's `files` option in `Bun.build()` can inject route manifests

The challenge is architectural, not library-based: designing a convention that works with Bun's compile constraints.

## Stack Additions

**None required.** The existing stack fully supports v0.3 requirements.

| Category | Needed? | Rationale |
|----------|---------|-----------|
| Router library | NO | Bun.serve() routes are sufficient; Express-like libraries (bun-route, Hono) add overhead without value here |
| Validation | NO | Already using zod |
| Error handling | NO | Native Error subclasses are sufficient |
| Build tooling | NO | Existing Bun.build() pipeline works |

## Bun Native Features

### Route Handling (Bun.serve)

**Source:** [Bun Routing Documentation](https://bun.com/docs/runtime/http/routing)

Bun.serve() provides:

```typescript
Bun.serve({
  routes: {
    "/api/custom/:param": {
      GET: (req) => Response.json({ param: req.params.param }),
      POST: async (req) => {
        const body = await req.json();
        return Response.json({ created: true, ...body });
      },
    },
  },
  fetch(req) {
    // Fallback for unmatched routes
    return new Response("Not Found", { status: 404 });
  },
});
```

**Key capabilities:**
- Path parameters (`:id`) with type-safe `req.params`
- Per-method handlers (GET, POST, PATCH, DELETE)
- Wildcard routes (`/api/*`)
- Static Response optimization
- `server.reload()` for hot-updating routes (development only, NOT for compiled binary)

**Constraint for compiled binaries:** Routes must be statically analyzable at build time. The `routes` object cannot be dynamically constructed at runtime in a compiled binary.

### File-based Route Discovery

**Source:** [Bun Bundler Documentation](https://bun.sh/docs/bundler)

For embedding user routes in the compiled binary, we have two options:

**Option A: Build-time manifest generation (RECOMMENDED)**

```typescript
// scripts/build.ts
import { Glob } from "bun";

// Discover routes at build time
const routeFiles = new Glob("./routes/**/*.ts").scanSync(".");
const routeImports = Array.from(routeFiles).map(file => {
  const route = file.replace("./routes", "").replace(/\.ts$/, "");
  return `"${route}": await import("./${file}")`;
});

// Generate manifest
const manifest = `export const routes = { ${routeImports.join(", ")} };`;
await Bun.write("./src/generated/routes.ts", manifest);

// Then compile
await Bun.build({
  entrypoints: ["./src/cli.ts"],
  compile: { outfile: "./bunbase" },
});
```

**Option B: Bun.build files option (in-memory)**

```typescript
await Bun.build({
  entrypoints: ["./src/cli.ts"],
  files: {
    "./src/routes-manifest.ts": generateRouteManifest(),
  },
  compile: { outfile: "./bunbase" },
});
```

### Error Response Patterns

Bun's Response.json() handles all error response needs:

```typescript
// PocketBase-compatible error structure
interface ApiError {
  code: number;
  message: string;
  data?: Record<string, ValidationError>;
}

interface ValidationError {
  code: string;
  message: string;
}

// Usage
return Response.json({
  code: 400,
  message: "Validation failed",
  data: {
    title: {
      code: "validation_required",
      message: "Title is required"
    }
  }
}, { status: 400 });
```

## Integration Points

### 1. Route Registration with Existing Server

The current `createServer()` function uses a static `routes` object. Custom routes integrate via:

**Pattern: Merge at server creation**

```typescript
// src/api/server.ts
export function createServer(
  port: number,
  hooks?: HookManager,
  realtime?: RealtimeManager,
  customRoutes?: Record<string, RouteHandler>  // NEW
) {
  return Bun.serve({
    routes: {
      // Built-in routes (current implementation)
      "/api/collections/:name/records": { ... },

      // Custom routes merged in
      ...customRoutes,
    },
    fetch(req) {
      return errorResponse("Not found", 404);
    },
  });
}
```

### 2. Route Context Access

Custom routes need access to BunBase internals:

```typescript
interface RouteContext {
  db: Database;                    // bun:sqlite instance
  hooks: HookManager;              // lifecycle hooks
  realtime: RealtimeManager;       // SSE broadcasting
  auth: {
    requireAdmin: (req: Request) => Promise<Admin | Response>;
    optionalUser: (req: Request) => Promise<AuthenticatedUser | null>;
    buildAuthContext: (req: Request) => Promise<AuthContext>;
  };
  records: {
    get: typeof getRecord;
    list: typeof listRecordsWithQuery;
    create: typeof createRecordWithHooks;
    update: typeof updateRecordWithHooks;
    delete: typeof deleteRecordWithHooks;
  };
}
```

### 3. Unified Error Handling Integration

Current implementation has scattered `errorResponse()` calls. Unification requires:

```typescript
// Current (scattered)
catch (error) {
  const err = error as Error;
  if (err.message === 'Access denied') {
    return errorResponse(err.message, 403);
  }
  return errorResponse(err.message, mapErrorToStatus(err));
}

// Unified (centralized)
catch (error) {
  return handleApiError(error);  // Returns PocketBase-compatible Response
}
```

### 4. Build Pipeline Integration

Existing build:
```bash
bun run build:admin && bun build --compile --minify src/cli.ts --outfile bunbase
```

With custom routes:
```bash
bun run build:admin && bun run build:routes && bun build --compile --minify src/cli.ts --outfile bunbase
```

Where `build:routes` discovers and generates the route manifest.

## NOT Adding

| Library | Why NOT |
|---------|---------|
| **Hono** | Adds 30KB+ and routing abstraction when Bun.serve() routes are sufficient |
| **bun-route** | Express-like API is unnecessary; Bun.serve() has native route params |
| **http-errors** | Overkill; simple Error subclass is enough |
| **zod-validation-error** | Already have zod; error formatting is straightforward |
| **path-to-regexp** | Bun.serve() handles route patterns natively |

## Single Binary Considerations

### Route Discovery Must Be Build-Time

Routes cannot be discovered at runtime in a compiled binary because:

1. `fs.readdirSync()` reads from disk, not embedded files
2. `import()` dynamic imports must resolve to known paths
3. `Bun.embeddedFiles` only contains explicitly included files

**Solution: Generate route manifest during build**

```typescript
// Workflow:
// 1. User creates routes/send-email.ts
// 2. Build script scans routes/ directory
// 3. Generates src/generated/route-manifest.ts with static imports
// 4. Manifest is bundled into binary
// 5. Server reads manifest at startup
```

### File Structure Convention

```
project/
  routes/                    # User's custom routes
    send-email.ts           # POST /api/custom/send-email
    webhooks/
      stripe.ts             # POST /api/custom/webhooks/stripe
  bunbase.db
  bunbase                   # Compiled binary (includes routes)
```

### Route File Format

```typescript
// routes/send-email.ts
import type { RouteContext } from "bunbase";

export const POST = async (req: Request, ctx: RouteContext) => {
  const { to, subject, body } = await req.json();

  // Access BunBase internals
  const user = await ctx.auth.optionalUser(req);
  if (!user) {
    throw new ApiError(401, "Unauthorized");
  }

  // Use existing email service
  await ctx.email.send({ to, subject, body });

  return Response.json({ success: true });
};
```

## Version Compatibility

| Component | Current Version | Notes |
|-----------|----------------|-------|
| Bun | latest | Bun.serve() routes require v1.2.3+ |
| bun:sqlite | built-in | No changes needed |
| zod | ^3.24.0 | No changes needed |
| jose | ^6.1.3 | No changes needed |

## Sources

- [Bun.serve() Routing Documentation](https://bun.com/docs/runtime/http/routing) - Official route handling reference
- [Bun Bundler Documentation](https://bun.sh/docs/bundler) - Build and compile options
- [Bun Executable Compilation](https://bun.sh/docs/bundler/executables) - Single binary constraints
- [PocketBase API Error Format](https://github.com/pocketbase/pocketbase/discussions/3922) - Error response structure reference
- [PocketBase JS Routing](https://pocketbase.io/docs/js-routing/) - Custom route patterns in PocketBase
- Local codebase analysis: `/Users/narcisbrindusescu/newme/bunbase/src/api/server.ts`
