# Pitfalls Research: BunBase v0.3 Custom API Endpoints

**Domain:** Custom API routes in a BaaS with binary compilation
**Researched:** 2026-01-30
**Confidence:** HIGH (verified with official Bun docs and existing codebase)

## Executive Summary

Adding custom API routes to BunBase presents three categories of risk: (1) binary compilation pitfalls where routes must be statically analyzable at build time, (2) integration pitfalls where custom routes must coexist with existing auto-generated CRUD routes and share context correctly, and (3) error handling pitfalls where inconsistent error responses between custom and system routes create poor DX. The most critical pitfall is **dynamic route discovery at runtime**, which fundamentally breaks `bun build --compile`.

## Critical Pitfalls

### 1. Dynamic Route Discovery at Runtime (HIGH)

**Risk:** Using filesystem scanning or dynamic imports to discover routes at runtime breaks binary compilation. Routes cannot be discovered dynamically in a compiled binary because the filesystem structure doesn't exist.

**Warning Signs:**
- Code using `fs.readdirSync()` or `Bun.Glob` to find route files
- Dynamic `import()` with runtime-computed paths
- FileSystemRouter usage expecting filesystem access

**Prevention:**
- Generate a static route manifest at build time
- Use explicit imports: `import userRoutes from "./routes/users/index.ts"`
- Build script must enumerate all route files and generate import statements
- Consider a `routes.generated.ts` file created during build

**Phase:** Phase 1 (Core Infrastructure) - Route loader design must account for this from the start

**Code example of what NOT to do:**
```typescript
// BROKEN in compiled binary
const routeFiles = glob.sync("./routes/**/*.ts");
for (const file of routeFiles) {
  const module = await import(file); // ModuleNotFound error
}
```

**Correct approach:**
```typescript
// routes.generated.ts (created at build time)
import * as users_get from "./routes/users/get.ts";
import * as users_post from "./routes/users/post.ts";
export const routes = {
  "users/get": users_get,
  "users/post": users_post
};
```

---

### 2. Handler Export Convention Mismatch (HIGH)

**Risk:** Users export handlers with wrong names/signatures, leading to silent failures where routes don't work but no error is thrown.

**Warning Signs:**
- Route file exists but endpoint returns 404
- Handler defined but never called
- TypeScript showing no errors but runtime behavior wrong

**Prevention:**
- Strict TypeScript types for handler exports
- Validate exports at build time, not runtime
- Clear error messages: "Route file X exports 'get' but expected 'GET'"
- Document convention clearly: `export const GET`, `export const POST` (uppercase)

**Phase:** Phase 1 (Core Infrastructure) - Validation must be part of route loading

**Example of the pitfall:**
```typescript
// routes/users.ts
export const get = (req) => { ... }  // WRONG - lowercase
export function GET(req) { ... }      // WRONG - function, not const (depends on convention)
export const GET = (req) => { ... }   // CORRECT
```

---

### 3. Context Injection Scope Leakage (HIGH)

**Risk:** Custom routes receive shared context (db, auth, records) but modify it in ways that leak state between requests or break other routes.

**Warning Signs:**
- Intermittent failures on high traffic
- "Database is locked" errors
- Auth state from one request appearing in another

**Prevention:**
- Make injected context immutable where possible
- Document clearly what's safe to modify vs read-only
- Provide scoped transaction API rather than raw db access
- Use request-scoped context, not singleton

**Phase:** Phase 2 (Context Injection) - Design context API to prevent misuse

**Dangerous pattern:**
```typescript
export const GET = async ({ db, auth }) => {
  // DON'T DO THIS - mutating shared state
  db.pragma("journal_mode = OFF");
  auth.permissions.push("admin"); // Leaks to other requests
};
```

---

### 4. Binary Embedding Missing Route Files (MEDIUM)

**Risk:** Route files not included in compiled binary because they weren't statically imported or explicitly added to build.

**Warning Signs:**
- Routes work in development but not in compiled binary
- `ModuleNotFound` errors only in production
- Some routes work, others don't

**Prevention:**
- Build script explicitly lists all route entrypoints
- Test compiled binary in CI before release
- Use `Bun.embeddedFiles` to verify expected files are present
- Build-time validation that manifest matches filesystem

**Phase:** Phase 3 (Build Integration) - Critical for binary compilation

**Build command must include all routes:**
```bash
bun build --compile ./src/cli.ts ./routes/**/*.ts --outfile bunbase
```

---

## Integration Pitfalls

### 5. Route Priority Conflicts with Auto-Generated CRUD (MEDIUM)

**Risk:** Custom routes and auto-generated CRUD routes conflict. User defines `/api/collections/users/records` custom route that shadows or conflicts with auto-generated route.

**Warning Signs:**
- Custom route overrides system behavior unexpectedly
- CRUD operations stop working for specific collections
- Unpredictable behavior based on route registration order

**Prevention:**
- Define clear precedence rules: custom routes > auto-generated (or vice versa)
- Namespace custom routes differently: `/api/custom/...` vs `/api/collections/...`
- Warn at startup if custom route shadows system route
- Document reserved route patterns

**Phase:** Phase 1 (Core Infrastructure) - Route merging strategy

**Current BunBase routes that must be protected:**
```
/api/collections/:name/records          - CRUD
/api/collections/:name/records/:id      - CRUD
/api/collections/:name/auth/*           - User auth
/api/files/:collection/:record/:file    - File serving
/api/realtime                           - SSE
/_/api/*                                - Admin API
/_/*                                    - Admin UI
```

---

### 6. Missing Auth Context in Custom Routes (MEDIUM)

**Risk:** Custom routes don't receive auth context or receive it in different format than system routes, leading to inconsistent security behavior.

**Warning Signs:**
- Custom routes bypass auth rules
- `req.auth` undefined in custom handlers
- Different error format for 401/403 between custom and system routes

**Prevention:**
- Inject auth context using same middleware as system routes
- Reuse `buildAuthContext()` from existing server code
- Provide `requireAuth()` helper that works identically to admin routes
- Test auth scenarios for custom routes

**Phase:** Phase 2 (Context Injection) - Auth must be part of context

**BunBase already has auth helpers that should be reused:**
```typescript
// From existing server.ts
import { requireAdmin, optionalUser, buildAuthContext } from "../auth/middleware";
```

---

### 7. Hook Interaction with Custom Routes (MEDIUM)

**Risk:** Custom routes that create/update/delete records don't trigger lifecycle hooks, or trigger them differently than system routes.

**Warning Signs:**
- `beforeCreate` hook runs for API but not custom route
- Realtime events not broadcast for custom route changes
- File cleanup hooks not running

**Prevention:**
- Custom routes must use `createRecordWithHooks()`, not raw SQL
- Document that direct db access bypasses hooks
- Provide helper that wraps operations with hooks
- Test hook execution for custom route operations

**Phase:** Phase 2 (Context Injection) - Records API in context must use hooks

**Existing hook-aware functions to expose:**
```typescript
// These must be available in custom route context
createRecordWithHooks()
updateRecordWithHooks()
deleteRecordWithHooks()
```

---

## Binary Compilation Pitfalls

### 8. Development vs Production Behavior Divergence (MEDIUM)

**Risk:** Routes work in development (`bun --hot`) but fail in compiled binary due to different module resolution or missing files.

**Warning Signs:**
- "Works on my machine" but fails in Docker/production
- `Bun.embeddedFiles` empty in development
- Different paths returned by file imports

**Prevention:**
- Test with compiled binary in CI
- Document that `Bun.embeddedFiles` only works in compiled binary
- Provide development fallback that mimics production behavior
- Use same route loading path for dev and prod

**Phase:** Phase 3 (Build Integration) - Test matrix must include compiled binary

---

### 9. Large Route Directory Bloating Binary (LOW)

**Risk:** Embedding many route files significantly increases binary size, especially if routes import large dependencies.

**Warning Signs:**
- Binary size grows unexpectedly large (>100MB)
- Build time increases significantly
- Memory usage higher than expected

**Prevention:**
- Tree-shake unused exports from route files
- Use `--minify` flag in build
- Lazy load heavy dependencies within route handlers
- Monitor binary size in CI

**Phase:** Phase 3 (Build Integration) - Size monitoring

---

### 10. Cross-Platform Route Path Handling (LOW)

**Risk:** Route paths work on macOS/Linux but fail on Windows due to path separator differences.

**Warning Signs:**
- Routes work on developer Mac, fail on Windows CI
- Backslashes appearing in route patterns
- Path normalization errors

**Prevention:**
- Always use forward slashes in route patterns
- Normalize paths at build time
- Test on Windows in CI if Windows is a target

**Phase:** Phase 3 (Build Integration) - Path normalization

---

## Error Handling Pitfalls

### 11. Inconsistent Error Response Format (HIGH)

**Risk:** Custom routes return errors in different format than system routes, breaking client error handling.

**Warning Signs:**
- Client code has special cases for different endpoints
- `error.message` exists on some responses, `error.error` on others
- Status codes inconsistent for same error type

**Prevention:**
- Provide `errorResponse()` helper in route context
- Enforce PocketBase-compatible error format: `{ error: string }`
- Validate error format at build/test time
- Document error response contract

**Phase:** Phase 4 (Unified Error Handling) - Core feature of this milestone

**PocketBase error format to match:**
```typescript
// System routes already use this pattern
function errorResponse(message: string, status: number): Response {
  return Response.json({ error: message }, { status });
}
```

---

### 12. Unhandled Promise Rejections in Handlers (HIGH)

**Risk:** Async route handlers throw but error isn't caught, causing 500 with no useful message or hanging request.

**Warning Signs:**
- Requests hang with no response
- Generic "Internal Server Error" with no details
- Unhandled rejection warnings in logs

**Prevention:**
- Wrap all route handlers in try/catch at framework level
- Use Bun.serve `error` handler for fallback
- Log full error stack in development
- Return consistent error response on any throw

**Phase:** Phase 4 (Unified Error Handling) - Error boundary

**Bun.serve already supports error handler:**
```typescript
Bun.serve({
  routes: { ... },
  error(error) {
    console.error(error);
    return new Response("Internal Server Error", { status: 500 });
  }
});
```

---

### 13. Error Messages Leaking Internal Details (MEDIUM)

**Risk:** Error messages expose stack traces, SQL queries, or file paths in production.

**Warning Signs:**
- Error responses contain full stack traces
- SQL syntax visible in error messages
- Internal file paths exposed

**Prevention:**
- Sanitize error messages in production
- Use generic message + error code pattern
- Log detailed errors server-side only
- Never expose raw database errors

**Phase:** Phase 4 (Unified Error Handling) - Error sanitization

---

## Phase-Specific Warnings

| Phase | Likely Pitfall | Mitigation |
|-------|---------------|------------|
| Phase 1: Route Loading | Dynamic route discovery (#1), Export convention (#2) | Build-time manifest generation, strict TypeScript types |
| Phase 2: Context Injection | Context scope leakage (#3), Missing auth (#6), Hook bypass (#7) | Immutable context, reuse existing auth middleware |
| Phase 3: Build Integration | Missing route files (#4), Dev/prod divergence (#8) | Explicit build entrypoints, CI testing with binary |
| Phase 4: Error Handling | Inconsistent format (#11), Unhandled rejections (#12) | Centralized error helper, framework-level try/catch |

## Sources

- [Bun HTTP Server Documentation](https://bun.sh/docs/api/http) - Routes configuration, error handling
- [Bun Single-File Executable](https://bun.sh/docs/bundler/executables) - Embedding files, compilation pitfalls
- [Bun FileSystemRouter](https://bun.com/docs/api/file-system-router) - File-based routing patterns
- [GitHub Issue: Embed directory in executable](https://github.com/oven-sh/bun/issues/5445) - Known embedding limitations
- [GitHub Issue: Dynamic imports in compile](https://github.com/oven-sh/bun/issues/11732) - Non-static import issues
- [Next.js Route Handlers](https://nextjs.org/docs/app/api-reference/file-conventions/route) - Export convention patterns
- [Express Error Handling](https://expressjs.com/en/guide/error-handling.html) - Middleware error patterns
- [Hono HTTPException](https://hono.dev/docs/api/exception) - Framework error handling
- [PocketBase Error Handling](https://github.com/pocketbase/pocketbase/discussions/196) - Error format conventions
- BunBase `src/api/server.ts` - Existing error handling patterns
- BunBase `src/core/hooks.ts` - Existing hook middleware pattern
