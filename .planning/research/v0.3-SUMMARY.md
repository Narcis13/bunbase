# Research Summary: BunBase v0.3

**Project:** BunBase v0.3 - Custom API Endpoints
**Domain:** Backend-as-a-Service (BaaS) - extending validated v0.2 foundation
**Researched:** 2026-01-30
**Confidence:** HIGH

## Executive Summary

BunBase v0.3 adds two features: custom API routes and unified error handling. Research reveals that **no new dependencies are needed** — Bun's native APIs provide everything required. The main challenge is architectural: routes must be discoverable at build time (not runtime) for binary embedding, requiring a manifest generation step.

The recommended approach follows modern conventions (Next.js/SvelteKit-style export handlers) while maintaining PocketBase API compatibility for error responses. Custom routes get full access to BunBase context (database, records, auth, files, realtime) via dependency injection.

Key risk: **Routes cannot be discovered dynamically at runtime** in a compiled binary. Build-time manifest generation is mandatory. Additional pitfalls include export naming conventions (uppercase `GET`/`POST`), context scope leakage between requests, and error format inconsistency.

## Key Findings

### Recommended Stack

**No new dependencies needed.** Bun provides all required capabilities natively:

- **Route handling:** `Bun.serve()` routes with method-specific handlers
- **Path parameters:** Native `:param` syntax support
- **File scanning:** `Bun.Glob` for build-time route discovery
- **Binary embedding:** Static imports bundled by `bun build --compile`

**Existing dependencies (no changes):**
- zod ^3.24.0 — request validation (optional)
- jose ^6.1.3 — JWT auth context
- Everything else already in BunBase

**Explicitly NOT adding:**
- Hono/Express — Bun.serve() routes are sufficient
- path-to-regexp — Bun handles route patterns natively
- http-errors — Simple Error subclass is enough

### Expected Features

**Must have (table stakes):**
- File-based route definition (`routes/` directory)
- Export named handlers (`export const GET`, `export const POST`)
- Full BunBase context injection (db, records, auth, files, realtime)
- Path parameters via `[id]` folder convention
- PocketBase-compatible error format `{ code, message, data }`
- Build-time route discovery for binary embedding

**Should have (differentiators):**
- Type-safe RouteContext interface
- Records API with hooks (`ctx.records.create()`)
- Error factory helpers (`throw new BadRequestError()`)
- Development hot reload support

**Defer to v0.4+:**
- PUT/PATCH/DELETE methods (GET/POST sufficient for 95% of cases)
- Route-level middleware chains
- Automatic request body validation
- WebSocket routes (SSE already covers realtime)

### Architecture Approach

**New components:**
1. `src/api/context.ts` — RouteContext interface and factory
2. `src/api/errors.ts` — ApiError class hierarchy and unified handler
3. `src/api/custom-routes.ts` — Route loader (dev: dynamic, prod: generated)
4. `scripts/generate-routes.ts` — Build-time manifest generator
5. `src/api/generated-routes.ts` — AUTO-GENERATED static imports

**Modified components:**
- `src/api/server.ts` — Accept custom routes parameter, merge into routes object
- `src/cli.ts` — Load and pass custom routes to server
- `package.json` — Add `build:routes` script

**Route loading flow:**
```
Development:
  Bun.Glob scans routes/ → dynamic imports → route object

Production (binary):
  Build script scans routes/ → generates static imports → bundled in binary
```

### PocketBase Error Format

```json
{
  "code": 400,
  "message": "Something went wrong",
  "data": {
    "title": {
      "code": "validation_required",
      "message": "Title is required"
    }
  }
}
```

### Critical Pitfalls

Research identified 13 pitfalls. Top 5 by risk:

1. **Dynamic Route Discovery at Runtime (HIGH)** — Routes cannot be found with filesystem scanning in a compiled binary. Prevention: Generate static imports at build time.

2. **Handler Export Convention Mismatch (HIGH)** — Users export `get` instead of `GET`, route silently fails. Prevention: Strict TypeScript types, build-time validation.

3. **Context Injection Scope Leakage (HIGH)** — Shared context modified by one request affects others. Prevention: Immutable context design, request-scoped data only.

4. **Inconsistent Error Response Format (HIGH)** — Custom routes return different error shape than system routes. Prevention: Provide `errorResponse()` helper, enforce PocketBase format.

5. **Unhandled Promise Rejections (HIGH)** — Async handlers throw without being caught. Prevention: Framework-level try/catch wrapper around all handlers.

## Implications for Roadmap

Based on dependency analysis and architecture patterns, recommend **4-phase build order**:

### Phase 14: Foundation (Context & Errors)

**Goal:** Establish patterns all other code will use

**Delivers:**
- `BunBaseContext` TypeScript interface
- `ApiError` class hierarchy (BadRequest, Unauthorized, NotFound, etc.)
- `withErrorHandling` middleware wrapper
- Unified `handleApiError()` function

**Why first:** Context types must exist before route handlers can use them. Error handling must be uniform before routes are created.

### Phase 15: Route Loading

**Goal:** Discover and load custom route handlers

**Delivers:**
- Route manifest generator script (`scripts/generate-routes.ts`)
- `loadCustomRoutes()` function
- Path conversion rules (`routes/users/[id].ts` → `/api/users/:id`)
- Export validation (reject lowercase `get`, warn on missing handlers)

**Why second:** Route loading must work before routes can be integrated into server.

### Phase 16: Server Integration

**Goal:** Wire custom routes into BunBase server

**Delivers:**
- Modified `createServer()` to accept custom routes
- Context factory function (`createBunBaseContext()`)
- Route handler wrapping with context + error handling
- CLI changes to load routes at startup

**Why third:** Depends on context types and route loader being ready.

### Phase 17: Build Pipeline & Testing

**Goal:** Ensure everything works in compiled binary

**Delivers:**
- `build:routes` npm script
- Updated build sequence (routes → admin → compile)
- Example custom routes (`routes/health.ts`, `routes/stats.ts`)
- Binary embedding verification tests

**Why last:** Must verify all components work in development first, then test production binary.

### Phase Ordering Rationale

```
Phase 14 (Foundation) → Phase 15 (Route Loading)
     |                         |
     |                         v
     +-----------------> Phase 16 (Server Integration)
                               |
                               v
                       Phase 17 (Build Pipeline)
```

Each phase depends on the previous. Foundation provides types for route loading. Route loading provides handlers for server integration. Server integration provides the runtime for build testing.

### Research Flags

**All phases use standard patterns (skip deep research):**
- Phase 14: Error handling patterns well-documented
- Phase 15: File-based routing is industry standard
- Phase 16: Existing server.ts provides template
- Phase 17: Build scripts follow existing pattern

**Phases needing testing focus (not research):**
- Phase 15: Export naming validation edge cases
- Phase 17: Compiled binary route embedding verification

## Confidence Assessment

| Area | Confidence | Notes |
|------|------------|-------|
| Stack | HIGH | No new dependencies; Bun native APIs verified |
| Features | HIGH | PocketBase/Next.js patterns well-documented |
| Architecture | HIGH | Extends existing v0.2 patterns cleanly |
| Pitfalls | HIGH | 13 pitfalls identified with clear mitigations |

**Overall confidence:** HIGH

The two features (custom routes, unified errors) are architecturally independent and well-understood. The main complexity is build-time route manifest generation, which has a clear solution. No blocking unknowns.

### Gaps to Address

**During Phase 14:**
- Exact error code vocabulary (adopt PocketBase codes)
- Whether to migrate existing endpoints to new format (recommend: gradual)

**During Phase 15:**
- Nested dynamic routes (`routes/[collection]/[id].ts`) — decide if supported

**During Phase 16:**
- Custom route namespace (`/api/` vs `/api/custom/`) — decision needed

**None of these gaps block implementation.** All have reasonable defaults.

## Sources

### Stack Research
- [Bun.serve() Routing Documentation](https://bun.com/docs/runtime/http/routing)
- [Bun Bundler Documentation](https://bun.sh/docs/bundler)
- [Bun Single-File Executables](https://bun.sh/docs/bundler/executables)

### Features Research
- [PocketBase JS Routing](https://pocketbase.io/docs/js-routing/)
- [PocketBase Error Handling](https://pocketbase.io/docs/go-routing/)
- [Next.js Route Handlers](https://nextjs.org/docs/app/api-reference/file-conventions/route)

### Architecture Research
- [Bun FileSystemRouter](https://bun.com/docs/api/file-system-router)
- BunBase `src/api/server.ts` analysis

### Pitfalls Research
- [GitHub: Bun compile embedding issues](https://github.com/oven-sh/bun/issues/5445)
- [GitHub: Bun dynamic imports in compile](https://github.com/oven-sh/bun/issues/11732)
- BunBase existing error handling patterns

---
*Research completed: 2026-01-30*
*Ready for roadmap: yes*
