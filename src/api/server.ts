/**
 * HTTP Server for BunBase REST API
 *
 * Exposes CRUD operations for collection records via HTTP endpoints.
 * Uses Bun.serve() with route definitions following PocketBase conventions.
 * Serves admin UI at /_/ routes via Bun HTML imports.
 */

import { initDatabase } from "../core/database";
import {
  getRecord,
  listRecordsWithQuery,
  createRecordWithHooks,
  updateRecordWithHooks,
  deleteRecordWithHooks,
  createRecordWithFiles,
  updateRecordWithFiles,
} from "../core/records";
import {
  isMultipartRequest,
  parseMultipartRequest,
} from "../storage/multipart";
import { getFilePath, fileExists } from "../storage/files";
import { addFileUrls, addFileUrlsToList } from "../storage/urls";
import {
  getAllCollections,
  getFields,
  createCollection,
  updateCollection,
  deleteCollection,
  addField,
  updateField,
  removeField,
} from "../core/schema";
import { getDatabase } from "../core/database";
import { parseQueryOptions } from "../core/query";
import { HookManager } from "../core/hooks";
import {
  createAdmin,
  verifyAdminPassword,
  getAdminByEmail,
  updateAdminPassword,
} from "../auth/admin";
import { createAdminToken } from "../auth/jwt";
import { requireAdmin, extractBearerToken, optionalUser } from "../auth/middleware";
import { initEmailService, type SmtpConfig } from "../email";
import {
  requestEmailVerification,
  confirmEmailVerification,
  requestPasswordReset,
  confirmPasswordReset,
} from "../auth/tokens";
import { verifyUserToken } from "../auth/user-jwt";
import { createUser, loginUser, refreshTokens } from "../auth/user";
import { isAuthCollection } from "../core/schema";
import { registerFileCleanupHook } from "../storage/hooks";
import { RealtimeManager } from "../realtime/manager";
import { formatSSEMessage, formatSSEComment } from "../realtime/sse";
import { registerRealtimeHooks } from "../realtime/hooks";
import { nanoid } from "nanoid";

// Import pre-built admin UI assets for embedding in binary
// These are generated by scripts/build-admin.ts
import adminHtml from "../../dist/admin/index.html" with { type: "text" };
import adminJs from "../../dist/admin/main.js" with { type: "text" };
import adminCss from "../../dist/admin/globals.css" with { type: "text" };

// Re-export HookManager for external registration
export { HookManager } from "../core/hooks";

// Re-export RealtimeManager for external access
export { RealtimeManager } from "../realtime/manager";

/**
 * Create an error response with consistent format.
 *
 * @param message - Error message
 * @param status - HTTP status code
 * @returns Response with JSON error body
 */
function errorResponse(message: string, status: number): Response {
  return Response.json({ error: message }, { status });
}

/**
 * Map error messages to HTTP status codes.
 *
 * @param error - Error thrown by Phase 1 operations
 * @returns Appropriate HTTP status code
 */
function mapErrorToStatus(error: Error): number {
  const msg = error.message.toLowerCase();
  if (msg.includes("not found")) return 404;
  if (msg.includes("validation failed")) return 400;
  if (msg.includes("invalid filter field")) return 400;
  if (msg.includes("invalid sort field")) return 400;
  if (msg.includes("already exists")) return 409;
  // Default to 400 for application errors (including hook cancellations)
  // 500 is reserved for unexpected system errors
  return 400;
}

/**
 * Get record count for a collection.
 *
 * @param collectionName - Name of the collection
 * @returns Number of records in the collection
 */
function getRecordCount(collectionName: string): number {
  const db = getDatabase();
  const result = db.prepare(`SELECT COUNT(*) as count FROM ${collectionName}`).get() as { count: number };
  return result.count;
}

/**
 * Create the HTTP server with all CRUD routes.
 *
 * @param port - Port to listen on (default: 8090)
 * @param hooks - Optional HookManager instance for lifecycle hooks
 * @param realtime - Optional RealtimeManager instance for SSE connections
 * @returns The Bun.Server instance
 */
export function createServer(
  port: number = 8090,
  hooks?: HookManager,
  realtime?: RealtimeManager
) {
  // Create default hooks instance if not provided
  const hookManager = hooks ?? new HookManager();

  // Create default realtime instance if not provided
  const realtimeManager = realtime ?? new RealtimeManager();

  return Bun.serve({
    port,
    routes: {
      // List records and create record
      "/api/collections/:name/records": {
        /**
         * GET /api/collections/:name/records
         * List all records in a collection with optional query filters
         * Supports pagination, sorting, filtering
         * Respects collection view rules
         * File field values are transformed to full URLs
         */
        GET: async (req) => {
          try {
            const { name } = req.params;
            const user = await optionalUser(req);
            const authContext = { isAdmin: false, user };
            const url = new URL(req.url);
            const options = parseQueryOptions(url);
            const result = listRecordsWithQuery(name, options, authContext);

            // Add file URLs to each record in response
            const fields = getFields(name);
            const baseUrl = `${url.protocol}//${url.host}`;
            result.items = addFileUrlsToList(result.items, fields, baseUrl, name);

            return Response.json(result);
          } catch (error) {
            const err = error as Error;
            if (err.message === 'Access denied') {
              return errorResponse(err.message, 403);
            }
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },

        /**
         * POST /api/collections/:name/records
         * Create a new record in a collection (with lifecycle hooks)
         * Supports both JSON and multipart/form-data for file uploads
         * Respects collection create rules
         * File field values are transformed to full URLs in response
         */
        POST: async (req) => {
          try {
            const { name } = req.params;
            const user = await optionalUser(req);
            const authContext = { isAdmin: false, user };

            let record: Record<string, unknown>;

            if (isMultipartRequest(req)) {
              // Handle multipart form data (with files)
              const { data, files } = await parseMultipartRequest(req);
              record = await createRecordWithFiles(
                name,
                data,
                files,
                hookManager,
                req,
                authContext
              );
            } else {
              // Handle JSON request (no files)
              const body = await req.json();
              record = await createRecordWithHooks(name, body, hookManager, req, authContext);
            }

            // Add file URLs to response
            const fields = getFields(name);
            const url = new URL(req.url);
            const baseUrl = `${url.protocol}//${url.host}`;
            const recordWithUrls = addFileUrls(record, fields, baseUrl, name);

            return Response.json(recordWithUrls, { status: 201 });
          } catch (error) {
            const err = error as Error;
            if (err.message === 'Access denied') {
              return errorResponse(err.message, 403);
            }
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
      },

      // File serving endpoint
      "/api/files/:collection/:record/:filename": {
        /**
         * GET /api/files/:collection/:record/:filename
         * Serve a file from storage with access control
         * Respects collection view rules (uses same auth as record view)
         */
        GET: async (req) => {
          try {
            const { collection, record: recordId, filename } = req.params;
            const user = await optionalUser(req);
            const authContext = { isAdmin: false, user };

            // Verify record exists and user can view it
            // This enforces collection view rules for file access
            const recordData = getRecord(collection, recordId, authContext);
            if (!recordData) {
              return errorResponse("Not found", 404);
            }

            // Check file exists
            const exists = await fileExists(collection, recordId, filename);
            if (!exists) {
              return errorResponse("File not found", 404);
            }

            // Get file path and serve
            const filePath = getFilePath(collection, recordId, filename);
            const file = Bun.file(filePath);

            // Return file - Bun automatically sets Content-Type from extension
            return new Response(file);
          } catch (error) {
            const err = error as Error;
            if (err.message === "Access denied") {
              return errorResponse(err.message, 403);
            }
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
      },

      // Realtime SSE endpoint
      "/api/realtime": {
        /**
         * GET /api/realtime
         * Establish SSE connection for realtime updates
         * Sends PB_CONNECT event immediately with clientId
         * Maintains keep-alive pings every 30 seconds
         */
        GET: async (req) => {
          const clientId = nanoid();
          const signal = req.signal;

          return new Response(
            new ReadableStream({
              type: "direct",
              async pull(controller: ReadableStreamDirectController) {
                // Send PB_CONNECT event with clientId
                const connectMsg = formatSSEMessage({
                  event: "PB_CONNECT",
                  data: { clientId },
                  id: nanoid(),
                });
                await controller.write(connectMsg);
                await controller.flush();

                // Register client with manager
                realtimeManager.registerClient(clientId, controller);

                // Ping loop - every 30 seconds
                const pingInterval = 30000;
                while (!signal.aborted) {
                  await Bun.sleep(pingInterval);
                  if (!signal.aborted) {
                    try {
                      const ping = formatSSEComment("ping");
                      await controller.write(ping);
                      await controller.flush();
                      realtimeManager.updateActivity(clientId);
                    } catch {
                      break; // Connection error, exit loop
                    }
                  }
                }

                // Cleanup on disconnect
                realtimeManager.removeClient(clientId);
                try {
                  controller.close();
                } catch {
                  // Already closed
                }
              },
            }),
            {
              status: 200,
              headers: {
                "Content-Type": "text/event-stream",
                "Cache-Control": "no-cache, no-transform",
                Connection: "keep-alive",
                "X-Accel-Buffering": "no",
              },
            }
          );
        },

        /**
         * POST /api/realtime
         * Manage subscriptions for an established SSE connection
         * Requires clientId from PB_CONNECT event
         * Optionally accepts Authorization header for user context
         */
        POST: async (req) => {
          try {
            interface SubscriptionRequest {
              clientId: string;
              subscriptions?: string[];
            }

            const body = (await req.json()) as SubscriptionRequest;

            if (!body.clientId) {
              return Response.json(
                { error: "clientId is required" },
                { status: 400 }
              );
            }

            // Verify client exists
            const client = realtimeManager.getClient(body.clientId);
            if (!client) {
              return Response.json(
                { error: "Invalid client ID" },
                { status: 404 }
              );
            }

            // Extract optional user auth
            const user = await optionalUser(req);

            // If client already has auth, verify it matches (prevent hijacking)
            if (client.user && user && client.user.id !== user.id) {
              return Response.json(
                { error: "Authorization mismatch" },
                { status: 403 }
              );
            }

            // Set auth context if provided and not already set
            if (user && !client.user) {
              realtimeManager.setClientAuth(body.clientId, user);
            }

            // Update subscriptions (empty array = unsubscribe all)
            const subscriptions = body.subscriptions ?? [];
            realtimeManager.setSubscriptions(body.clientId, subscriptions);

            return new Response(null, { status: 204 });
          } catch {
            return Response.json(
              { error: "Invalid request body" },
              { status: 400 }
            );
          }
        },
      },

      // Single record operations
      "/api/collections/:name/records/:id": {
        /**
         * GET /api/collections/:name/records/:id
         * Get a single record by ID
         * Respects collection view rules
         * File field values are transformed to full URLs
         */
        GET: async (req) => {
          try {
            const { name, id } = req.params;
            const user = await optionalUser(req);
            const authContext = { isAdmin: false, user };
            const record = getRecord(name, id, authContext);
            if (!record) {
              return errorResponse(
                `Record "${id}" not found in collection "${name}"`,
                404
              );
            }

            // Add file URLs to response
            const fields = getFields(name);
            const url = new URL(req.url);
            const baseUrl = `${url.protocol}//${url.host}`;
            const recordWithUrls = addFileUrls(record, fields, baseUrl, name);

            return Response.json(recordWithUrls);
          } catch (error) {
            const err = error as Error;
            if (err.message === 'Access denied') {
              return errorResponse(err.message, 403);
            }
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },

        /**
         * PATCH /api/collections/:name/records/:id
         * Update a record by ID (with lifecycle hooks)
         * Supports both JSON and multipart/form-data for file uploads
         * Respects collection update rules
         * File field values are transformed to full URLs in response
         */
        PATCH: async (req) => {
          try {
            const { name, id } = req.params;
            const user = await optionalUser(req);
            const authContext = { isAdmin: false, user };

            let record: Record<string, unknown>;

            if (isMultipartRequest(req)) {
              // Handle multipart form data (with files)
              const { data, files } = await parseMultipartRequest(req);
              record = await updateRecordWithFiles(
                name,
                id,
                data,
                files,
                hookManager,
                req,
                authContext
              );
            } else {
              // Handle JSON request (no files)
              const body = await req.json();
              record = await updateRecordWithHooks(name, id, body, hookManager, req, authContext);
            }

            // Add file URLs to response
            const fields = getFields(name);
            const url = new URL(req.url);
            const baseUrl = `${url.protocol}//${url.host}`;
            const recordWithUrls = addFileUrls(record, fields, baseUrl, name);

            return Response.json(recordWithUrls);
          } catch (error) {
            const err = error as Error;
            if (err.message === 'Access denied') {
              return errorResponse(err.message, 403);
            }
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },

        /**
         * DELETE /api/collections/:name/records/:id
         * Delete a record by ID (with lifecycle hooks)
         * Respects collection delete rules
         */
        DELETE: async (req) => {
          try {
            const { name, id } = req.params;
            const user = await optionalUser(req);
            const authContext = { isAdmin: false, user };
            await deleteRecordWithHooks(name, id, hookManager, req, authContext);
            return new Response(null, { status: 204 });
          } catch (error) {
            const err = error as Error;
            if (err.message === 'Access denied') {
              return errorResponse(err.message, 403);
            }
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
      },

      // User authentication routes (for auth collections)
      "/api/collections/:name/auth/signup": {
        /**
         * POST /api/collections/:name/auth/signup
         * Create a new user account in an auth collection
         */
        POST: async (req) => {
          try {
            const { name } = req.params;

            // Validate it's an auth collection
            if (!isAuthCollection(name)) {
              return errorResponse(`"${name}" is not an auth collection`, 400);
            }

            const { email, password } = await req.json();
            if (!email || !password) {
              return errorResponse("Email and password required", 400);
            }

            const result = await createUser(name, email, password);
            if (!result.success) {
              return errorResponse(result.error!, 400);
            }

            return Response.json({ user: result.user }, { status: 201 });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, 400);
          }
        },
      },

      "/api/collections/:name/auth/login": {
        /**
         * POST /api/collections/:name/auth/login
         * Authenticate user and return tokens
         */
        POST: async (req) => {
          try {
            const { name } = req.params;

            if (!isAuthCollection(name)) {
              return errorResponse(`"${name}" is not an auth collection`, 400);
            }

            const { email, password } = await req.json();
            if (!email || !password) {
              return errorResponse("Email and password required", 400);
            }

            const result = await loginUser(name, email, password);
            if (!result.success) {
              // Use 401 for auth failures
              return errorResponse(result.error!, 401);
            }

            return Response.json({
              token: result.accessToken,
              refreshToken: result.refreshToken,
              user: result.user,
            });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, 400);
          }
        },
      },

      "/api/collections/:name/auth/refresh": {
        /**
         * POST /api/collections/:name/auth/refresh
         * Refresh access token using refresh token
         */
        POST: async (req) => {
          try {
            const { name } = req.params;

            if (!isAuthCollection(name)) {
              return errorResponse(`"${name}" is not an auth collection`, 400);
            }

            const { refreshToken } = await req.json();
            if (!refreshToken) {
              return errorResponse("Refresh token required", 400);
            }

            const result = await refreshTokens(refreshToken);
            if (!result.success) {
              return errorResponse(result.error!, 401);
            }

            return Response.json({
              token: result.accessToken,
              refreshToken: result.refreshToken,
            });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, 400);
          }
        },
      },

      "/api/collections/:name/auth/request-verification": {
        /**
         * POST /api/collections/:name/auth/request-verification
         * Request email verification (requires user auth)
         */
        POST: async (req) => {
          try {
            const { name } = req.params;

            if (!isAuthCollection(name)) {
              return errorResponse(`"${name}" is not an auth collection`, 400);
            }

            // Get user from token using extractBearerToken
            const token = extractBearerToken(req);
            if (!token) {
              return errorResponse("Unauthorized", 401);
            }

            const payload = await verifyUserToken(token, "access");
            if (!payload || payload.collectionName !== name) {
              return errorResponse("Unauthorized", 401);
            }

            // Determine base URL from request
            const url = new URL(req.url);
            const baseUrl = `${url.protocol}//${url.host}`;

            const result = await requestEmailVerification(
              name,
              payload.userId,
              baseUrl
            );
            if (!result.success) {
              return errorResponse(result.error!, 400);
            }

            return Response.json({ message: "Verification email sent" });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, 400);
          }
        },
      },

      "/api/collections/:name/auth/confirm-verification": {
        /**
         * POST /api/collections/:name/auth/confirm-verification
         * Confirm email verification with token
         * Also supports GET for direct link clicking
         */
        POST: async (req) => {
          try {
            const { name } = req.params;

            if (!isAuthCollection(name)) {
              return errorResponse(`"${name}" is not an auth collection`, 400);
            }

            const { token } = await req.json();
            if (!token) {
              return errorResponse("Token required", 400);
            }

            const result = await confirmEmailVerification(token);
            if (!result.success) {
              return errorResponse(result.error!, 400);
            }

            return Response.json({ message: "Email verified successfully" });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, 400);
          }
        },

        GET: async (req) => {
          try {
            const { name } = req.params;

            if (!isAuthCollection(name)) {
              return errorResponse(`"${name}" is not an auth collection`, 400);
            }

            const url = new URL(req.url);
            const token = url.searchParams.get("token");
            if (!token) {
              return errorResponse("Token required", 400);
            }

            const result = await confirmEmailVerification(token);
            if (!result.success) {
              // Return HTML error for GET requests (user clicked link)
              return new Response(
                `<html><body><h1>Verification Failed</h1><p>${result.error}</p></body></html>`,
                { status: 400, headers: { "Content-Type": "text/html" } }
              );
            }

            // Return HTML success for GET requests
            return new Response(
              `<html><body><h1>Email Verified!</h1><p>Your email has been verified successfully. You can close this page.</p></body></html>`,
              { headers: { "Content-Type": "text/html" } }
            );
          } catch (error) {
            const err = error as Error;
            return new Response(
              `<html><body><h1>Error</h1><p>${err.message}</p></body></html>`,
              { status: 400, headers: { "Content-Type": "text/html" } }
            );
          }
        },
      },

      "/api/collections/:name/auth/request-reset": {
        /**
         * POST /api/collections/:name/auth/request-reset
         * Request password reset (email enumeration safe - always returns same message)
         */
        POST: async (req) => {
          try {
            const { name } = req.params;

            if (!isAuthCollection(name)) {
              // Don't reveal collection type info
              return Response.json({
                message: "If an account exists, a reset email has been sent",
              });
            }

            const { email } = await req.json();
            if (!email) {
              return errorResponse("Email required", 400);
            }

            const url = new URL(req.url);
            const baseUrl = `${url.protocol}//${url.host}`;

            await requestPasswordReset(name, email, baseUrl);

            return Response.json({
              message: "If an account exists, a reset email has been sent",
            });
          } catch {
            // Always return success to prevent enumeration
            return Response.json({
              message: "If an account exists, a reset email has been sent",
            });
          }
        },
      },

      "/api/collections/:name/auth/confirm-reset": {
        /**
         * POST /api/collections/:name/auth/confirm-reset
         * Confirm password reset with token and new password
         */
        POST: async (req) => {
          try {
            const { name } = req.params;

            if (!isAuthCollection(name)) {
              return errorResponse(`"${name}" is not an auth collection`, 400);
            }

            const { token, newPassword } = await req.json();
            if (!token || !newPassword) {
              return errorResponse("Token and new password required", 400);
            }

            const result = await confirmPasswordReset(token, newPassword);
            if (!result.success) {
              return errorResponse(result.error!, 400);
            }

            return Response.json({ message: "Password reset successfully" });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, 400);
          }
        },

        /**
         * GET /api/collections/:name/auth/confirm-reset
         * Return HTML form for password reset (user clicked link)
         */
        GET: async (req) => {
          const url = new URL(req.url);
          const token = url.searchParams.get("token");

          if (!token) {
            return new Response(
              `<html><body><h1>Error</h1><p>Token required</p></body></html>`,
              { status: 400, headers: { "Content-Type": "text/html" } }
            );
          }

          return new Response(
            `<!DOCTYPE html>
<html>
<head>
  <title>Reset Password</title>
  <style>
    body { font-family: system-ui, sans-serif; max-width: 400px; margin: 50px auto; padding: 20px; }
    input { width: 100%; padding: 10px; margin: 10px 0; box-sizing: border-box; }
    button { width: 100%; padding: 10px; background: #0066cc; color: white; border: none; cursor: pointer; }
    button:hover { background: #0055aa; }
    .error { color: red; }
    .success { color: green; }
  </style>
</head>
<body>
  <h1>Reset Password</h1>
  <form id="resetForm">
    <input type="hidden" name="token" value="${token}">
    <label>New Password:</label>
    <input type="password" name="newPassword" required minlength="8" placeholder="Enter new password">
    <label>Confirm Password:</label>
    <input type="password" name="confirmPassword" required placeholder="Confirm new password">
    <button type="submit">Reset Password</button>
  </form>
  <p id="message"></p>
  <script>
    document.getElementById('resetForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const form = e.target;
      const newPassword = form.newPassword.value;
      const confirmPassword = form.confirmPassword.value;
      if (newPassword !== confirmPassword) {
        document.getElementById('message').innerHTML = '<span class="error">Passwords do not match</span>';
        return;
      }
      try {
        const res = await fetch('', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ token: form.token.value, newPassword })
        });
        const data = await res.json();
        if (res.ok) {
          document.getElementById('message').innerHTML = '<span class="success">Password reset! You can now log in.</span>';
          form.style.display = 'none';
        } else {
          document.getElementById('message').innerHTML = '<span class="error">' + (data.error || 'Reset failed') + '</span>';
        }
      } catch (err) {
        document.getElementById('message').innerHTML = '<span class="error">Request failed</span>';
      }
    });
  </script>
</body>
</html>`,
            { headers: { "Content-Type": "text/html" } }
          );
        },
      },

      // Admin authentication routes
      "/_/api/auth/login": {
        /**
         * POST /_/api/auth/login
         * Authenticate admin with email/password and return JWT token
         */
        POST: async (req) => {
          try {
            const { email, password } = await req.json();
            if (!email || !password) {
              return errorResponse("Email and password required", 400);
            }
            const admin = await verifyAdminPassword(email, password);
            if (!admin) {
              return errorResponse("Invalid credentials", 401);
            }
            const token = await createAdminToken(admin.id);
            return Response.json({ token, admin });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, 400);
          }
        },
      },

      "/_/api/auth/password": {
        /**
         * POST /_/api/auth/password
         * Change admin password (requires valid JWT)
         */
        POST: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          const admin = adminOrError;
          try {
            const { newPassword } = await req.json();
            if (!newPassword || newPassword.length < 8) {
              return errorResponse(
                "Password must be at least 8 characters",
                400
              );
            }
            await updateAdminPassword(admin.id, newPassword);
            return Response.json({ message: "Password updated" });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, 400);
          }
        },
      },

      "/_/api/auth/me": {
        /**
         * GET /_/api/auth/me
         * Get current admin info (requires valid JWT)
         */
        GET: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          return Response.json(adminOrError);
        },
      },

      // Collections API for admin UI
      "/_/api/collections/:name/fields/:fieldName": {
        /**
         * PATCH /_/api/collections/:name/fields/:fieldName
         * Update a field in a collection (requires admin auth)
         */
        PATCH: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          const { name, fieldName } = req.params;
          try {
            const updates = await req.json();
            const field = updateField(name, fieldName, updates);
            return Response.json(field);
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
        /**
         * DELETE /_/api/collections/:name/fields/:fieldName
         * Remove a field from a collection (requires admin auth)
         */
        DELETE: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          const { name, fieldName } = req.params;
          try {
            removeField(name, fieldName);
            return new Response(null, { status: 204 });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
      },

      "/_/api/collections/:name/fields": {
        /**
         * GET /_/api/collections/:name/fields
         * Get fields for a specific collection (requires admin auth)
         */
        GET: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;

          const { name } = req.params;
          try {
            const fields = getFields(name);
            return Response.json(fields);
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
        /**
         * POST /_/api/collections/:name/fields
         * Add a field to a collection (requires admin auth)
         */
        POST: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          const { name } = req.params;
          try {
            const fieldData = await req.json();
            if (!fieldData.name || !fieldData.type) {
              return errorResponse("Field name and type are required", 400);
            }
            const field = addField(name, {
              name: fieldData.name,
              type: fieldData.type,
              required: fieldData.required ?? false,
              options: fieldData.options ?? null,
            });
            return Response.json(field, { status: 201 });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
      },

      "/_/api/collections/:name": {
        /**
         * PATCH /_/api/collections/:name
         * Rename a collection (requires admin auth)
         */
        PATCH: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          const { name } = req.params;
          try {
            const { newName } = await req.json();
            if (!newName || typeof newName !== "string") {
              return errorResponse("New collection name is required", 400);
            }
            const collection = updateCollection(name, newName);
            return Response.json(collection);
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
        /**
         * DELETE /_/api/collections/:name
         * Delete a collection and its data (requires admin auth)
         */
        DELETE: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          const { name } = req.params;
          try {
            deleteCollection(name);
            return new Response(null, { status: 204 });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
      },

      "/_/api/collections": {
        /**
         * GET /_/api/collections
         * List all collections with field and record counts (requires admin auth)
         */
        GET: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;

          try {
            const collections = getAllCollections();
            const result = collections.map((c) => ({
              ...c,
              fieldCount: getFields(c.name).length,
              recordCount: getRecordCount(c.name),
            }));
            return Response.json(result);
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
        /**
         * POST /_/api/collections
         * Create a new collection with optional fields (requires admin auth)
         */
        POST: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          try {
            const { name, fields } = await req.json();
            if (!name || typeof name !== "string") {
              return errorResponse("Collection name is required", 400);
            }
            const collection = createCollection(name, fields || []);
            return Response.json(collection, { status: 201 });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
      },

      // Admin UI static assets - serve with correct MIME types
      "/_/assets/main.js": () =>
        new Response(adminJs, {
          headers: { "Content-Type": "application/javascript" },
        }),
      "/_/assets/globals.css": () =>
        new Response(adminCss, {
          headers: { "Content-Type": "text/css" },
        }),

      // Admin UI routes - serve HTML for SPA routing
      "/_/": () =>
        new Response(adminHtml, {
          headers: { "Content-Type": "text/html" },
        }),
      "/_/*": () =>
        new Response(adminHtml, {
          headers: { "Content-Type": "text/html" },
        }),
    },

    /**
     * Fallback for unmatched routes
     */
    fetch(req) {
      return errorResponse("Not found", 404);
    },
  });
}

/**
 * Generate a random password for initial admin.
 * Uses alphanumeric characters (excluding ambiguous ones like 0, O, l, 1)
 *
 * @returns A 16-character random password
 */
function generateRandomPassword(): string {
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789";
  let result = "";
  for (let i = 0; i < 16; i++) {
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}

/**
 * Start the server with database initialization.
 * Creates initial admin account if none exists.
 *
 * @param port - Port to listen on (default: 8090)
 * @param dbPath - Database file path (default: "bunbase.db")
 * @param hooks - Optional HookManager instance for lifecycle hooks
 * @param smtpConfig - Optional SMTP configuration for email service
 * @param realtime - Optional RealtimeManager instance for SSE connections
 * @returns The Bun.Server instance
 */
export async function startServer(
  port: number = 8090,
  dbPath: string = "bunbase.db",
  hooks?: HookManager,
  smtpConfig?: SmtpConfig | null,
  realtime?: RealtimeManager
) {
  initDatabase(dbPath);

  // Create hook manager if not provided
  const hookManager = hooks ?? new HookManager();

  // Create realtime manager if not provided
  const realtimeManager = realtime ?? new RealtimeManager();

  // Register file cleanup hook for automatic file deletion on record delete
  registerFileCleanupHook(hookManager);

  // Register realtime hooks for broadcasting record changes to SSE subscribers
  registerRealtimeHooks(hookManager, realtimeManager);

  // Start inactivity cleanup (check every minute)
  realtimeManager.startInactivityCleanup(60000);

  // Initialize email service if configured
  if (smtpConfig) {
    initEmailService(smtpConfig);
    console.log(`Email service configured (${smtpConfig.host}:${smtpConfig.port})`);
  }

  // Create initial admin if none exists
  const existingAdmin = getAdminByEmail("admin@bunbase.local");
  if (!existingAdmin) {
    const password = Bun.env.BUNBASE_ADMIN_PASSWORD || generateRandomPassword();
    await createAdmin("admin@bunbase.local", password);
    if (!Bun.env.BUNBASE_ADMIN_PASSWORD) {
      console.log(`Initial admin created: admin@bunbase.local`);
      console.log(`Generated password: ${password}`);
      console.log(
        `Set BUNBASE_ADMIN_PASSWORD env var to use a specific password.`
      );
    }
  }

  const server = createServer(port, hookManager, realtimeManager);
  console.log(`BunBase running at http://localhost:${port}`);
  return server;
}

// Start server when run directly
if (import.meta.main) {
  startServer();
}
