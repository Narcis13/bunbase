/**
 * HTTP Server for BunBase REST API
 *
 * Exposes CRUD operations for collection records via HTTP endpoints.
 * Uses Bun.serve() with route definitions following PocketBase conventions.
 * Serves admin UI at /_/ routes via Bun HTML imports.
 */

import { initDatabase } from "../core/database";
import {
  getRecord,
  listRecordsWithQuery,
  createRecordWithHooks,
  updateRecordWithHooks,
  deleteRecordWithHooks,
} from "../core/records";
import {
  getAllCollections,
  getFields,
  createCollection,
  updateCollection,
  deleteCollection,
  addField,
  updateField,
  removeField,
} from "../core/schema";
import { getDatabase } from "../core/database";
import { parseQueryOptions } from "../core/query";
import { HookManager } from "../core/hooks";
import {
  createAdmin,
  verifyAdminPassword,
  getAdminByEmail,
  updateAdminPassword,
} from "../auth/admin";
import { createAdminToken } from "../auth/jwt";
import { requireAdmin } from "../auth/middleware";
import { initEmailService, type SmtpConfig } from "../email";

// Import pre-built admin UI assets for embedding in binary
// These are generated by scripts/build-admin.ts
import adminHtml from "../../dist/admin/index.html" with { type: "text" };
import adminJs from "../../dist/admin/main.js" with { type: "text" };
import adminCss from "../../dist/admin/globals.css" with { type: "text" };

// Re-export HookManager for external registration
export { HookManager } from "../core/hooks";

/**
 * Create an error response with consistent format.
 *
 * @param message - Error message
 * @param status - HTTP status code
 * @returns Response with JSON error body
 */
function errorResponse(message: string, status: number): Response {
  return Response.json({ error: message }, { status });
}

/**
 * Map error messages to HTTP status codes.
 *
 * @param error - Error thrown by Phase 1 operations
 * @returns Appropriate HTTP status code
 */
function mapErrorToStatus(error: Error): number {
  const msg = error.message.toLowerCase();
  if (msg.includes("not found")) return 404;
  if (msg.includes("validation failed")) return 400;
  if (msg.includes("invalid filter field")) return 400;
  if (msg.includes("invalid sort field")) return 400;
  if (msg.includes("already exists")) return 409;
  // Default to 400 for application errors (including hook cancellations)
  // 500 is reserved for unexpected system errors
  return 400;
}

/**
 * Get record count for a collection.
 *
 * @param collectionName - Name of the collection
 * @returns Number of records in the collection
 */
function getRecordCount(collectionName: string): number {
  const db = getDatabase();
  const result = db.prepare(`SELECT COUNT(*) as count FROM ${collectionName}`).get() as { count: number };
  return result.count;
}

/**
 * Create the HTTP server with all CRUD routes.
 *
 * @param port - Port to listen on (default: 8090)
 * @param hooks - Optional HookManager instance for lifecycle hooks
 * @returns The Bun.Server instance
 */
export function createServer(port: number = 8090, hooks?: HookManager) {
  // Create default hooks instance if not provided
  const hookManager = hooks ?? new HookManager();

  return Bun.serve({
    port,
    routes: {
      // List records and create record
      "/api/collections/:name/records": {
        /**
         * GET /api/collections/:name/records
         * List records with query support (filter, sort, pagination, expand)
         */
        GET: (req) => {
          try {
            const { name } = req.params;
            const url = new URL(req.url);
            const options = parseQueryOptions(url);
            const result = listRecordsWithQuery(name, options);
            return Response.json(result);
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },

        /**
         * POST /api/collections/:name/records
         * Create a new record in a collection (with lifecycle hooks)
         */
        POST: async (req) => {
          try {
            const { name } = req.params;
            const body = await req.json();
            const record = await createRecordWithHooks(name, body, hookManager, req);
            return Response.json(record, { status: 201 });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
      },

      // Single record operations
      "/api/collections/:name/records/:id": {
        /**
         * GET /api/collections/:name/records/:id
         * Get a single record by ID
         */
        GET: (req) => {
          try {
            const { name, id } = req.params;
            const record = getRecord(name, id);
            if (!record) {
              return errorResponse(
                `Record "${id}" not found in collection "${name}"`,
                404
              );
            }
            return Response.json(record);
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },

        /**
         * PATCH /api/collections/:name/records/:id
         * Update a record by ID (with lifecycle hooks)
         */
        PATCH: async (req) => {
          try {
            const { name, id } = req.params;
            const body = await req.json();
            const record = await updateRecordWithHooks(name, id, body, hookManager, req);
            return Response.json(record);
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },

        /**
         * DELETE /api/collections/:name/records/:id
         * Delete a record by ID (with lifecycle hooks)
         */
        DELETE: async (req) => {
          try {
            const { name, id } = req.params;
            await deleteRecordWithHooks(name, id, hookManager, req);
            return new Response(null, { status: 204 });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
      },

      // Admin authentication routes
      "/_/api/auth/login": {
        /**
         * POST /_/api/auth/login
         * Authenticate admin with email/password and return JWT token
         */
        POST: async (req) => {
          try {
            const { email, password } = await req.json();
            if (!email || !password) {
              return errorResponse("Email and password required", 400);
            }
            const admin = await verifyAdminPassword(email, password);
            if (!admin) {
              return errorResponse("Invalid credentials", 401);
            }
            const token = await createAdminToken(admin.id);
            return Response.json({ token, admin });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, 400);
          }
        },
      },

      "/_/api/auth/password": {
        /**
         * POST /_/api/auth/password
         * Change admin password (requires valid JWT)
         */
        POST: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          const admin = adminOrError;
          try {
            const { newPassword } = await req.json();
            if (!newPassword || newPassword.length < 8) {
              return errorResponse(
                "Password must be at least 8 characters",
                400
              );
            }
            await updateAdminPassword(admin.id, newPassword);
            return Response.json({ message: "Password updated" });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, 400);
          }
        },
      },

      "/_/api/auth/me": {
        /**
         * GET /_/api/auth/me
         * Get current admin info (requires valid JWT)
         */
        GET: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          return Response.json(adminOrError);
        },
      },

      // Collections API for admin UI
      "/_/api/collections/:name/fields/:fieldName": {
        /**
         * PATCH /_/api/collections/:name/fields/:fieldName
         * Update a field in a collection (requires admin auth)
         */
        PATCH: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          const { name, fieldName } = req.params;
          try {
            const updates = await req.json();
            const field = updateField(name, fieldName, updates);
            return Response.json(field);
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
        /**
         * DELETE /_/api/collections/:name/fields/:fieldName
         * Remove a field from a collection (requires admin auth)
         */
        DELETE: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          const { name, fieldName } = req.params;
          try {
            removeField(name, fieldName);
            return new Response(null, { status: 204 });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
      },

      "/_/api/collections/:name/fields": {
        /**
         * GET /_/api/collections/:name/fields
         * Get fields for a specific collection (requires admin auth)
         */
        GET: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;

          const { name } = req.params;
          try {
            const fields = getFields(name);
            return Response.json(fields);
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
        /**
         * POST /_/api/collections/:name/fields
         * Add a field to a collection (requires admin auth)
         */
        POST: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          const { name } = req.params;
          try {
            const fieldData = await req.json();
            if (!fieldData.name || !fieldData.type) {
              return errorResponse("Field name and type are required", 400);
            }
            const field = addField(name, {
              name: fieldData.name,
              type: fieldData.type,
              required: fieldData.required ?? false,
              options: fieldData.options ?? null,
            });
            return Response.json(field, { status: 201 });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
      },

      "/_/api/collections/:name": {
        /**
         * PATCH /_/api/collections/:name
         * Rename a collection (requires admin auth)
         */
        PATCH: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          const { name } = req.params;
          try {
            const { newName } = await req.json();
            if (!newName || typeof newName !== "string") {
              return errorResponse("New collection name is required", 400);
            }
            const collection = updateCollection(name, newName);
            return Response.json(collection);
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
        /**
         * DELETE /_/api/collections/:name
         * Delete a collection and its data (requires admin auth)
         */
        DELETE: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          const { name } = req.params;
          try {
            deleteCollection(name);
            return new Response(null, { status: 204 });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
      },

      "/_/api/collections": {
        /**
         * GET /_/api/collections
         * List all collections with field and record counts (requires admin auth)
         */
        GET: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;

          try {
            const collections = getAllCollections();
            const result = collections.map((c) => ({
              ...c,
              fieldCount: getFields(c.name).length,
              recordCount: getRecordCount(c.name),
            }));
            return Response.json(result);
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
        /**
         * POST /_/api/collections
         * Create a new collection with optional fields (requires admin auth)
         */
        POST: async (req) => {
          const adminOrError = await requireAdmin(req);
          if (adminOrError instanceof Response) return adminOrError;
          try {
            const { name, fields } = await req.json();
            if (!name || typeof name !== "string") {
              return errorResponse("Collection name is required", 400);
            }
            const collection = createCollection(name, fields || []);
            return Response.json(collection, { status: 201 });
          } catch (error) {
            const err = error as Error;
            return errorResponse(err.message, mapErrorToStatus(err));
          }
        },
      },

      // Admin UI static assets - serve with correct MIME types
      "/_/assets/main.js": () =>
        new Response(adminJs, {
          headers: { "Content-Type": "application/javascript" },
        }),
      "/_/assets/globals.css": () =>
        new Response(adminCss, {
          headers: { "Content-Type": "text/css" },
        }),

      // Admin UI routes - serve HTML for SPA routing
      "/_/": () =>
        new Response(adminHtml, {
          headers: { "Content-Type": "text/html" },
        }),
      "/_/*": () =>
        new Response(adminHtml, {
          headers: { "Content-Type": "text/html" },
        }),
    },

    /**
     * Fallback for unmatched routes
     */
    fetch(req) {
      return errorResponse("Not found", 404);
    },
  });
}

/**
 * Generate a random password for initial admin.
 * Uses alphanumeric characters (excluding ambiguous ones like 0, O, l, 1)
 *
 * @returns A 16-character random password
 */
function generateRandomPassword(): string {
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789";
  let result = "";
  for (let i = 0; i < 16; i++) {
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}

/**
 * Start the server with database initialization.
 * Creates initial admin account if none exists.
 *
 * @param port - Port to listen on (default: 8090)
 * @param dbPath - Database file path (default: "bunbase.db")
 * @param hooks - Optional HookManager instance for lifecycle hooks
 * @param smtpConfig - Optional SMTP configuration for email service
 * @returns The Bun.Server instance
 */
export async function startServer(
  port: number = 8090,
  dbPath: string = "bunbase.db",
  hooks?: HookManager,
  smtpConfig?: SmtpConfig | null
) {
  initDatabase(dbPath);

  // Initialize email service if configured
  if (smtpConfig) {
    initEmailService(smtpConfig);
    console.log(`Email service configured (${smtpConfig.host}:${smtpConfig.port})`);
  }

  // Create initial admin if none exists
  const existingAdmin = getAdminByEmail("admin@bunbase.local");
  if (!existingAdmin) {
    const password = Bun.env.BUNBASE_ADMIN_PASSWORD || generateRandomPassword();
    await createAdmin("admin@bunbase.local", password);
    if (!Bun.env.BUNBASE_ADMIN_PASSWORD) {
      console.log(`Initial admin created: admin@bunbase.local`);
      console.log(`Generated password: ${password}`);
      console.log(
        `Set BUNBASE_ADMIN_PASSWORD env var to use a specific password.`
      );
    }
  }

  const server = createServer(port, hooks);
  console.log(`BunBase running at http://localhost:${port}`);
  return server;
}

// Start server when run directly
if (import.meta.main) {
  startServer();
}
